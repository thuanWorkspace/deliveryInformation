/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../chunks/tslib.es6","../../../../core/Accessor","../../../../core/has","../../../../core/promiseUtils","../../../../core/accessorSupport/decorators/property","../../../../core/accessorSupport/ensureType","../../../../core/arrayUtils","../../../../core/accessorSupport/decorators/subclass","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/spatialReferenceUtils","../../../../layers/support/TileInfo","../../viewStateUtils","../../engine/Bitmap","../../tiling/TileInfoView","../../tiling/TileKey"],(function(e,t,i,o,r,a,s,n,p,d,c,h,l,m,u){"use strict";const g=p.create(),y=[0,0],_=new u(0,0,0,0),f={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let x=class extends t{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=f.hidpi,this.imageMaxWidth=f.imageMaxWidth,this.imageMaxHeight=f.imageMaxHeight,this.imageRotationSupported=f.imageRotationSupported,this.imageNormalizationSupported=f.imageNormalizationSupported,this.update=o.debounce((async(e,t)=>{if(o.throwIfAborted(t),!e.stationary||this.destroyed)return;const i=e.state,r=d.getInfo(i.spatialReference),a=this.hidpi?e.pixelRatio:1,s=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0],n=this.imageMaxWidth??0,p=this.imageMaxHeight??0;s?(y[0]=i.worldScreenWidth,y[1]=i.size[1]):this.imageRotationSupported?(y[0]=i.size[0],y[1]=i.size[1]):h.getOuterSize(y,i);const c=Math.floor(y[0]*a)>n||Math.floor(y[1]*a)>p,l=r&&(i.extent.xmin<r.valid[0]||i.extent.xmax>r.valid[1]),m=!this.imageNormalizationSupported&&l,u=!c&&!m,g=this.imageRotationSupported?i.rotation:0,_=this.container.children.slice();if(u){const e=s?i.paddedViewState.center:i.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(i,y,e,i.resolution,g,a,t)}else{let e=Math.min(n,p);m&&(e=Math.min(i.worldScreenWidth,e)),this._imagePromise=this._tiledExport(i,e,a,t)}try{const e=await this._imagePromise??[];o.throwIfAborted(t);const i=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=e;for(const t of _)e.includes(t)||i.push(t.fadeOut().then((()=>{t.remove(),t.destroy()})));for(const t of e)i.push(t.fadeIn());await Promise.all(i)}catch(f){this._imagePromise=null,o.throwIfAbortError(f)}}),5e3),this.updateExports=o.debounce((async e=>{const t=[];for(const i of this.container.children){if(!i.visible||!i.stage)return;t.push(e(i).then((()=>{i.invalidateTexture(),i.requestRender()})))}this._imagePromise=o.eachAlways(t).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((e=>e.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(e,t,i,r,a,s){const n=await this.fetchSource(e,Math.floor(t*a),Math.floor(i*a),{rotation:r,pixelRatio:a,signal:s});o.throwIfAborted(s);const p=new l.Bitmap(null,!0);return p.x=e.xmin,p.y=e.ymax,p.resolution=e.width/t,p.rotation=r,p.pixelRatio=a,p.opacity=0,this.container.addChild(p),await p.setSourceAsync(n,s),o.throwIfAborted(s),p}async _singleExport(e,t,i,o,r,a,s){h.getBBox(g,i,o,t);const n=p.toExtent(g,e.spatialReference);return[await this._export(n,t[0],t[1],r,a,s)]}_tiledExport(e,t,i,o){const r=c.create({size:t,spatialReference:e.spatialReference,scales:[e.scale]}),a=new m(r),s=a.getTileCoverage(e);if(!s)return null;const n=[];return s.forEach(((r,s,d,c)=>{_.set(r,s,d,0),a.getTileBounds(g,_);const h=p.toExtent(g,e.spatialReference);n.push(this._export(h,t,t,0,i,o).then((e=>(0!==c&&(_.set(r,s,d,c),a.getTileBounds(g,_),e.x=g[0],e.y=g[3]),e))))})),Promise.all(n)}};e.__decorate([r.property()],x.prototype,"_imagePromise",void 0),e.__decorate([r.property()],x.prototype,"bitmaps",void 0),e.__decorate([r.property()],x.prototype,"container",void 0),e.__decorate([r.property()],x.prototype,"fetchSource",void 0),e.__decorate([r.property()],x.prototype,"hidpi",void 0),e.__decorate([r.property()],x.prototype,"imageMaxWidth",void 0),e.__decorate([r.property()],x.prototype,"imageMaxHeight",void 0),e.__decorate([r.property()],x.prototype,"imageRotationSupported",void 0),e.__decorate([r.property()],x.prototype,"imageNormalizationSupported",void 0),e.__decorate([r.property()],x.prototype,"requestUpdate",void 0),e.__decorate([r.property()],x.prototype,"updating",null),x=e.__decorate([n.subclass("esri.views.2d.layers.support.ExportStrategy")],x);return x}));
