/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../TimeExtent","../../../../../core/Evented","../../../../../core/has","../../../../../core/promiseUtils","../../../../../core/accessorSupport/diffUtils","../../../../../core/support/UpdatingHandles","../../../../../layers/support/arcgisLayerUrl","../../../../../rest/support/Query","./DataTileSubscription","../support/UpdateToken"],(function(e,t,s,i,r,o,n,a,u,c,d){"use strict";function h(e,t){const s=new Set;return e&&e.forEach((e=>s.add(e))),t&&t.forEach((e=>s.add(e))),s.has("*")?["*"]:Array.from(s)}class l{constructor(e){this.updatingHandles=new n.UpdatingHandles,this.events=new s,this._resolver=r.createResolver(),this._didEdit=!1,this._subscriptions=new Map,this._outSR=e.outSR,this._serviceInfo=e.serviceInfo,this._onTileUpdateMessage=e.onMessage,this._arcadeLayerSchema=e.arcadeLayerSchema}destroy(){for(const e of this._subscriptions.values())e.abort();this.updatingHandles.destroy()}get subscriptions(){return this._subscriptions.values()}async _onMessage(e){const t=this._subscriptions.get(e.id);if(!t)return;const s={...e,remove:e.remove??[],status:e.status??d.UpdateToken.empty()};return r.ignoreAbortErrors(this._onTileUpdateMessage(s,t.options))}update(e,s){const r=s.fields.length;s.outFields=h(this._schema?.outFields,s.outFields),s.outFields=s.outFields.length>=.75*r?["*"]:s.outFields,s.outFields.sort();const n=o.diff(this._schema,s);if(!n)return;i("esri-2d-update-debug")&&console.debug("Applying Update - Source:",n);const u="orderByFields"in this._serviceInfo&&this._serviceInfo.orderByFields?this._serviceInfo.orderByFields:this._serviceInfo.objectIdField+" ASC",c=this._serviceInfo.source,d={returnCentroid:!(null!==c&&"object"==typeof c&&"path"in c&&a.isHostedAgolService(c.path))&&"esriGeometryPolygon"===this._serviceInfo.geometryType,returnGeometry:!0,timeReferenceUnknownClient:"stream"!==this._serviceInfo.type&&this._serviceInfo.timeReferenceUnknownClient,outFields:s.outFields,outSpatialReference:this._outSR,orderByFields:[u],where:s.definitionExpression||"1=1",gdbVersion:s.gdbVersion,historicMoment:s.historicMoment,timeExtent:s.timeExtent?t.fromJSON(s.timeExtent):null},l=this._schema&&o.hasDiff(n,"outFields");this._schema&&o.hasDiffAny(n,["timeExtent","definitionExpression","gdbVersion","historicMoment","customParameters"])&&(e.why.mesh.push("Layer filter and/or custom parameters changed"),e.why.source.push("Layer filter and/or custom parameters changed"),e.mesh=!0,e.source=!0,e.queryFilter=!0),l&&(e.why.source.push("Layer required fields changed"),e.source=!0),o.diff(d,this._queryInfo)&&(this._queryInfo=d),this._schema=s,this._resolver.resolve()}whenInitialized(){return this._resolver.promise}async applyUpdate(e){if(e.queryFilter||e.source&&this._didEdit)return this.refresh(e.version),void(this._didEdit=!1);this._subscriptions.forEach((t=>t.applyUpdate(e))),await this.resend()}refresh(e,t){for(const s of this._tiles())this.unsubscribe(s),this.subscribe(s,e)}subscribe(e,t){const s=new c.DataTileSubscription(e,t);return this._subscriptions.set(e.id,s),s}unsubscribe(e){const t=this.getSubscription(e.id);null!=t&&t.abort(),this._subscriptions.delete(e.id)}createQuery(e={}){const t=this._queryInfo.historicMoment?new Date(this._queryInfo.historicMoment):null;return new u({...this._queryInfo,historicMoment:t,...e})}getSubscription(e){return this._subscriptions.has(e)?this._subscriptions.get(e):null}async queryLastEditDate(){throw new Error("Service does not support query type")}async query(e,t){throw new Error("Service does not support query")}*_tiles(){const e=Array.from(this._subscriptions.values());for(const t of e)yield t.tile}async edit(e,t){return this.updatingHandles.addPromise(this._edit(e,t))}async _edit(e,t){const s=Array.from(this._subscriptions.values()),o=s.map((({tile:e})=>e));for(const i of s)i.removeIds(t);if(e.length){const s=o.map((t=>{const s=this.createTileQuery(t);return s.objectIds=e,{tile:t,query:s}})).map((async({tile:e,query:t})=>({tile:e,result:await this.query(t,{query:{tile:i("esri-tiles-debug")?e.id.replaceAll("/","."):void 0}}),query:t}))),n=(await r.eachAlwaysValues(s)).map((async({tile:s,result:i})=>{if(!i.hasFeatures&&!t.length&&!e.length)return;const r=this._subscriptions.get(s.key.id);r&&r.edit(i,e)}));await Promise.allSettled(n)}this._didEdit=!0}}e.DataTileSource=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
