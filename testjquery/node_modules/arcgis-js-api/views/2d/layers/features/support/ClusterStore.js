/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../geometry","../../../../../core/Evented","../../../../../core/has","../../../../../core/accessorSupport/diffUtils","../../../../../geohash/GeohashTree","../../../../../geohash/geohashUtils","../../../../../geometry/support/aaBoundingBox","../../../../../geometry/support/Ellipsoid","../../../../../geometry/support/spatialReferenceUtils","../../../../../layers/graphics/featureConversionUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/OptimizedGeometry","../../../../../layers/graphics/data/projectionSupport","../../../../../layers/support/FieldsIndex","../../../engine/webgl/definitions","../../../engine/webgl/DisplayId","../FeatureStore2D","../Store2D","./FeatureSetReaderJSON","../../../../../geometry/SpatialReference","../../../../../geometry/Polygon","../../../../../geometry/Extent"],(function(e,t,s,r,i,a,o,h,l,n,u,d,c,g,f,_,p,m,y,I,b,v,S){"use strict";const R=12,x=64,M=1,F=h.create();class C extends d.OptimizedFeatureWithGeometry{constructor(e,t,s,r,i){super(new c([],[t,s]),r,null,e),this.geohashBoundsInfo=i}get count(){return this.attributes.cluster_count}static create(e,t,s,r,i,a,o,h){const l=new C(t,s,r,a,o);return l.displayId=e.createDisplayId(!0),l.referenceId=h,l.tileLevel=i,l}update(e,t,s,r,i,a){return this.geometry.coords[0]=e,this.geometry.coords[1]=t,this.tileLevel=s,this.attributes=r,this.geohashBoundsInfo=i,this.referenceId=null,this.referenceId=a,this}toJSON(){return{attributes:{...this.attributes,aggregateId:this.objectId,referenceId:1===this.attributes.cluster_count?this.referenceId:null},geometry:{x:this.geometry.coords[0],y:this.geometry.coords[1]}}}}function B(e){return 57.29577951308232*e}class L extends y.Store2D{constructor(e,t,r,i){super(e,r),this.type="cluster",this.events=new s,this.objectIdField="aggregateId",this.featureAdapter=m.featureAdapter,this._geohashLevel=0,this._tileLevel=0,this._aggregateValueRanges={},this._aggregateValueRangesChanged=!1,this._geohashBuf=[],this._clusters=new Map,this._tiles=new Map,this._serviceInfo=i,this.geometryInfo=e.geometryInfo,this._spatialReference=t,this._projectionSupportCheck=g.checkProjectionSupport(t,b.WGS84),this._bitsets.geohash=r.getBitset(r.createBitset()),this._bitsets.inserted=r.getBitset(r.createBitset())}destroy(){this._tree.destroy()}get featureSpatialReference(){return this._spatialReference}get fields(){return this._fields}async updateSchema(e,t){const s=this._schema;try{await super.updateSchema(e,t),await this._projectionSupportCheck}catch(h){}this._fields=[...this._schema.params.fields,{name:"referenceId",alias:"referenceId",type:"esriFieldTypeInteger"}];!!this._fields.some((e=>"cluster_count"===e.name))||this._fields.push({name:"cluster_count",alias:"cluster_count",type:"esriFieldTypeInteger"}),this._fieldsIndex=new f(this._fields);const o=i.diff(s,t);t&&(null!=o||e.source||e.storage.filters)?((i.hasDiff(o,"params.fields")||!this._tree||e.source)&&(this._tree&&this._tree.destroy(),this._tree=new a.GeohashTree(this._statisticFields,this._serviceInfo),this._rebuildTree(),r("esri-2d-update-debug")&&console.debug("Aggregate mesh needs update due to tree changing")),r("esri-2d-update-debug")&&console.debug("Applying Update - ClusterStore:",o),e.targets[t.name]=!0,e.mesh=!1,this._aggregateValueRanges={}):s&&(e.mesh=!0)}clear(){this._rebuildTree()}sweepFeatures(e,t){this._bitsets.inserted.forEachSet((s=>{if(!e.has(s)){const e=t.lookupByDisplayIdUnsafe(s);this._remove(e)}}))}sweepAggregates(e,t,s){this._clusters.forEach(((r,i)=>{r&&r.tileLevel!==s&&(e.releaseDisplayId(r.displayId),t.unsetAttributeData(r.displayId),this._clusters.delete(i))}))}onTileData(e,t,s,r,i,a=!0){if(!this._schema||null==t.addOrUpdate)return t;this.events.emit("changed");const o=this._getTransforms(e,this._spatialReference);{const e=t.addOrUpdate.getCursor();for(;e.next();)this._update(e,r)}if(t.status.mesh||!a)return t;const h=new Array,l=this._schema.params.clusterRadius;this._getClustersForTile(h,e,l,s,o),t.addOrUpdate=I.FeatureSetReaderJSON.fromOptimizedFeatures(h,{fields:this.fields,fieldsIndex:this._fieldsIndex,geometryType:"esriGeometryPoint",objectIdField:this.objectIdField}),t.addOrUpdate.attachStorage(s),t.clear=!0,t.end=!0;{const r=t.addOrUpdate.getCursor();for(;r.next();){const t=r.getDisplayId();this._bitsets.computed.unset(t),this.setComputedAttributes(s,r,t,e.scale,i)}}return this._aggregateValueRangesChanged&&t.end&&(this.events.emit("valueRangesChanged",{valueRanges:this._aggregateValueRanges}),this._aggregateValueRangesChanged=!1),t}onTileUpdate({added:e,removed:t}){if(e.length){const t=e[0].level;this._tileLevel=t,this._setGeohashLevel(t)}if(!this._schema)return;const s=this._schema.params.clusterRadius;t.forEach((e=>{this._tiles.delete(e.key.id),this._markTileClustersForDeletion(e,s)}))}getAggregate(e){for(const t of this._clusters.values())if((t?.displayId&p.displayIdTexelMask)==(e&p.displayIdTexelMask))return t.toJSON();return null}getAggregates(){const e=[];for(const t of this._clusters.values())t?.tileLevel===this._tileLevel&&e.push(t.toJSON());return e}getDisplayId(e){const t=this._clusters.get(e);return t?t.displayId:null}getFeatureDisplayIdsForAggregate(e){const t=this._clusters.get(e);return t?this._tree.getRegionDisplayIds(t.geohashBoundsInfo):[]}getDisplayIdForReferenceId(e){for(const t of this._clusters.values())if(t?.referenceId===e)return t.displayId;return null}getAggregateValueRanges(){return this._aggregateValueRanges}forEach(e){this._clusters.forEach((t=>{if(!t)return;const s=t.toJSON(),r=I.FeatureSetReaderJSON.fromFeatures([s],{objectIdField:this.objectIdField,globalIdField:null,geometryType:this.geometryInfo.geometryType,fields:this.fields,fieldsIndex:this._fieldsIndex}).getCursor();r.next(),e(r)}))}forEachInBounds(e,t){}forEachBounds(e,t){const{hasM:s,hasZ:r}=this.geometryInfo;for(const i of e){const e=u.getBoundsOptimizedGeometry(F,i.readGeometry(),r,s);null!=e&&t(e)}}size(){let e=0;return this.forEach((t=>e++)),e}_rebuildTree(){this._bitsets.computed.clear(),this._bitsets.inserted.clear(),this._tree&&this._tree.clear()}_remove(e){const t=e.getDisplayId(),s=e.getXHydrated(),r=e.getYHydrated(),i=this._geohashBuf[2*t],a=this._geohashBuf[2*t+1];this._bitsets.inserted.has(t)&&(this._bitsets.inserted.unset(t),this._tree.removeCursor(e,s,r,i,a,this._geohashLevel))}_update(e,t){const s=e.getDisplayId(),r=this._bitsets.inserted,i=t.isVisible(s);if(i===r.has(s))return;if(!i)return void this._remove(e);const a=e.getXHydrated(),o=e.getYHydrated();if(!this._setGeohash(s,a,o))return;const h=this._geohashBuf[2*s],l=this._geohashBuf[2*s+1];this._tree.insertCursor(e,s,a,o,h,l,this._geohashLevel),r.set(s)}_setGeohash(e,t,s){if(this._bitsets.geohash.has(e))return!0;const r=this._geohashBuf;if(this._spatialReference.isWebMercator){const i=B(t/l.earth.radius),a=i-360*Math.floor((i+180)/360),h=B(Math.PI/2-2*Math.atan(Math.exp(-s/l.earth.radius)));o.setGeohashBuf(r,e,h,a,R)}else{const i={x:t,y:s},a=g.project(i,this._spatialReference,b.WGS84);if(!a)return!1;o.setGeohashBuf(r,e,a.y,a.x,R)}return this._bitsets.geohash.set(e),!0}_getClustersForTile(e,t,s,r,i,a=!0){const o=this._schema.params.clusterPixelBuffer,h=2*s,l=Math.ceil(2**t.key.level*_.tileSize/h)+1,n=Math.ceil(o/h)+0,c=Math.ceil(_.tileSize/h),{row:g,col:f}=t.key,p=f*_.tileSize,m=g*_.tileSize,y=Math.floor(p/h)-n,I=Math.floor(m/h)-n,b=y+c+2*n,v=I+c+2*n,S=t.tileInfoView.getLODInfoAt(t.key.level);for(let _=y;_<=b;_++)for(let s=I;s<=v;s++){let o=_;S.wrap&&(o=_<0?_+l:_%l);const h=S.wrap&&_<0,n=S.wrap&&_%l!==_,c=this._lookupCluster(r,S,t.key.level,o,s,t);if(null!=c){let t=null;if(i&&(t=h?i.left:n?i.right:i.tile),a&&null==t)continue;if(!c.count)continue;if(null!=t&&a){const s=c.geometry.clone();let r=c.attributes;s.coords[0]=u.quantizeX(t,s.coords[0]),s.coords[1]=u.quantizeY(t,s.coords[1]),1===c.count&&null!=c.referenceId&&(r={...c.attributes,referenceId:c.referenceId});const i=new d.OptimizedFeature(s,r);i.displayId=c.displayId,e.push(i)}}}}_getGeohashLevel(e){return Math.min(Math.ceil(e/2+2),R)}_setGeohashLevel(e){const t=this._getGeohashLevel(e),s=(Math.floor(t/M)+1)*M-1;if(this._geohashLevel!==s)return this._geohashLevel=s,this._rebuildTree(),void this._bitsets.geohash.clear()}_getTransforms(e,t){const s={originPosition:"upperLeft",scale:[e.resolution,e.resolution],translate:[e.bounds[0],e.bounds[3]]},r=n.getInfo(t);if(!r)return{tile:s,left:null,right:null};const[i,a]=r.valid;return{tile:s,left:{...s,translate:[a,e.bounds[3]]},right:{...s,translate:[i-a+e.bounds[0],e.bounds[3]]}}}_getClusterId(e,t,s){return(15&e)<<28|(16383&t)<<14|16383&s}_markForDeletion(e,t,s){const r=this._getClusterId(e,t,s);this._clusters.delete(r)}_getClusterBounds(e,t,s){const r=this._schema.params.clusterRadius,i=2*r;let a=s%2?t*i:t*i-r;const o=s*i;let h=a+i;const l=o-i,n=2**e.level*_.tileSize;e.wrap&&a<0&&(a=0),e.wrap&&h>n&&(h=n);const u=a/_.tileSize,d=o/_.tileSize,c=h/_.tileSize,g=l/_.tileSize;return[e.getXForColumn(u),e.getYForRow(d),e.getXForColumn(c),e.getYForRow(g)]}_getGeohash(e,t,s){const r={geohashX:0,geohashY:0};return o.setGeohashXY(r,t,e,s),r}_getGeohashBounds(e,t){const s=this._getGeohashLevel(e.key.level);if(this._spatialReference.isWebMercator){const[e,r,i,a]=t,h={x:e,y:r},n={x:i,y:a};let u=0,d=0,c=0,g=0;{const e=B(h.x/l.earth.radius);u=e-360*Math.floor((e+180)/360),d=B(Math.PI/2-2*Math.atan(Math.exp(-h.y/l.earth.radius)))}{const e=B(n.x/l.earth.radius);c=e-360*Math.floor((e+180)/360),g=B(Math.PI/2-2*Math.atan(Math.exp(-n.y/l.earth.radius)))}const f={geohashX:0,geohashY:0},_={geohashX:0,geohashY:0};o.setGeohashXY(f,d,u,s),o.setGeohashXY(_,g,c,s);return{bounds:[e,r,i,a],geohashBounds:{xLL:f.geohashX,yLL:f.geohashY,xTR:_.geohashX,yTR:_.geohashY},level:s}}const r=v.fromExtent(S.fromBounds(t,this._spatialReference)),i=g.project(r,this._spatialReference,b.WGS84,{densificationStep:e.resolution*x});if(!i)return null;const a=u.convertFromPolygon(new c,i,!1,!1),h=a.coords.filter(((e,t)=>!(t%2))),n=a.coords.filter(((e,t)=>t%2)),d=Math.min(...h),f=Math.min(...n),_=Math.max(...h),p=Math.max(...n),m=this._getGeohash(d,f,s),y=this._getGeohash(_,p,s);return{bounds:t,geohashBounds:{xLL:m.geohashX,yLL:m.geohashY,xTR:y.geohashX,yTR:y.geohashY},level:s}}_lookupCluster(e,t,s,r,i,a){const o=this._getClusterId(s,r,i),h=this._clusters.get(o),l=this._getClusterBounds(t,r,i),n=this._getGeohashBounds(a,l);if(null==n)return null;const u=this._tree.getRegionStatistics(n),{count:d,xTotal:c,yTotal:g,referenceId:f}=u,_=d?c/d:0,p=d?g/d:0;if(0===d)return this._clusters.set(o,null),null;const m={cluster_count:d,...u.attributes},y=null!=h?h.update(_,p,s,m,n,f):C.create(e,o,_,p,s,m,n,f);if(0===d){const[e,t,s,r]=l;y.geometry.coords[0]=(e+s)/2,y.geometry.coords[1]=(t+r)/2}return this._clusters.set(o,y),this._updateAggregateValueRangeForCluster(y,y.tileLevel),y}_updateAggregateValueRangeForCluster(e,t){const s=this._aggregateValueRanges[t]||{minValue:1/0,maxValue:0},r=s.minValue,i=s.maxValue;s.minValue=Math.min(r,e.count),s.maxValue=Math.max(i,e.count),this._aggregateValueRanges[t]=s,r===s.minValue&&i===s.maxValue||(this._aggregateValueRangesChanged=!0)}_markTileClustersForDeletion(e,t){const s=2*t,r=Math.ceil(_.tileSize/s),{row:i,col:a}=e.key,o=a*_.tileSize,h=i*_.tileSize,l=Math.floor(o/s),n=Math.floor(h/s);for(let u=l;u<l+r;u++)for(let t=n;t<n+r;t++)this._markForDeletion(e.key.level,u,t)}}e.ClusterInfo=C,e.ClusterStore=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
