/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","exports","../../../../core/has","../../../../core/accessorSupport/diffUtils","../../../../support/arcadeOnDemand","../../arcade/callExpressionWithCursor"],(function(e,s,t,i,a,r){"use strict";class c{constructor(e,s){this._canCacheExpressionValue=!1,this._sourceInfo=e,this._storage=s,this._bitsets={computed:s.getBitset(s.createBitset())}}get storage(){return this._storage}invalidate(){this._bitsets.computed.clear()}async updateSchema(e,s){const a=i.diff(this._schema,s);if(this._schema=s,!s||null==a||!i.hasDiff(a,"attributes"))return;t("esri-2d-update-debug")&&console.debug("Applying Update - Store:",a),this._bitsets.computed.clear(),e.targets[s.name]=!0;const r=s.attributes,c=[],o=[];for(const t in r){const e=r[t];switch(e.type){case"field":break;case"expression":c.push(this._createArcadeComputedField(e));break;case"label-expression":c.push(this._createLabelArcadeComputedField(e));break;case"statistic":o.push(e)}}this._computedFields=await Promise.all(c),this._canCacheExpressionValue=!this._computedFields.some((e=>"expression"===e.type&&null!=e.expression&&e.expression.referencesScale())),this._statisticFields=o}setComputedAttributes(e,s,t,i,a){const r=this._bitsets.computed;if(!this._canCacheExpressionValue||!r.has(t)){r.set(t);for(const r of this._computedFields){const c=this._evaluateField(s,r,i,a);switch(r.resultType){case"numeric":e.setComputedNumericAtIndex(t,r.fieldIndex,c);break;case"string":e.setComputedStringAtIndex(t,r.fieldIndex,c)}}}}async _createArcadeComputedField(e){const s=this._sourceInfo.spatialReference,t=this._sourceInfo.fieldsIndex;return{...e,expression:await a.createRendererExpression(e.valueExpression,s,t)}}async _createLabelArcadeComputedField(s){const t=this._sourceInfo.spatialReference,i=this._sourceInfo.fieldsIndex,{createLabelFunction:a}=await new Promise(((s,t)=>e(["../../../../layers/support/labelFormatUtils"],s,t))),r=await a(s.label,i,t);return{...s,builder:r}}_evaluateField(e,s,t,i){switch(s.type){case"label-expression":{const t=e.readArcadeFeature();return s.builder.evaluate(t,i)||""}case"expression":{const{expression:a}=s;return r(a,e,{$view:{scale:t,timeZone:i}})}}}}s.Store2D=c,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})}));
