/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/promiseUtils","../utils","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/Texture","../../../../webgl/TextureDescriptor","../../../../webgl/VertexArrayObject","../../../../webgl/VertexElementDescriptor"],(function(t,e,a,r,s,i,o,n,l){"use strict";class c{constructor(t){this._params=t,this.animated=!1}isCompatible(t){if(!(t instanceof c))return!1;if(!a.timeExtentsEqual(this._params.timeExtent,t._params.timeExtent))return!1;let e=!0;return e=e&&this._params.loadImagery===t._params.loadImagery,e=e&&this._params.color.kind===t._params.color.kind,e=e&&this._params.opacity.kind===t._params.opacity.kind,e}async load(t,a){const{extent:r,size:s}=t;e.throwIfAborted(a);const i=await this._params.loadImagery(r,s[0],s[1],this._params.timeExtent,a);return new _(i,{color:this._params.color,opacity:this._params.opacity})}render(t,e,r){const{context:i}=t,{program:o}=r;i.setFaceCullingEnabled(!1),i.setBlendingEnabled(!0),i.setBlendFunction(s.BlendFactor.ONE,s.BlendFactor.ONE_MINUS_SRC_ALPHA),i.useProgram(o),o.setUniformMatrix3fv("u_dvsMat3",e.dvsMat3),i.bindTexture(r.texture,0),o.setUniform1i("u_texture",0),o.setUniform1f("u_Min",r.min),o.setUniform1f("u_Max",r.max),a.setUniforms(o,"color","vec4",this._params.color),a.setUniforms(o,"opacity","float",this._params.opacity),i.bindVAO(r.vertexArray),i.drawArrays(s.PrimitiveType.TRIANGLE_STRIP,0,4)}}const m=new Map;m.set("a_position",0),m.set("a_texcoord",1);const p={geometry:[new l.VertexElementDescriptor("a_position",2,s.DataType.UNSIGNED_SHORT,0,8),new l.VertexElementDescriptor("a_texcoord",2,s.DataType.UNSIGNED_SHORT,4,8)]},h={vsPath:"raster/flow/imagery",fsPath:"raster/flow/imagery",attributes:m};class _{constructor(t,e){this._flowData=t,this._values=e}attach(t){const{context:e}=t,{width:a,height:l}=this._flowData,c={geometry:r.BufferObject.createVertex(e,s.Usage.STATIC_DRAW,new Uint16Array([0,0,0,1,a,0,1,1,0,l,0,0,a,l,1,0]))},_=new n.VertexArrayObject(e,m,p,c),d=[];"ramp"===this._values.color.kind&&d.push("vvColor"),"ramp"===this._values.opacity.kind&&d.push("vvOpacity");const u=t.painter.materialManager.getProgram(h,d);let f=1e6,x=-1e6;for(let r=0;r<l;r++)for(let t=0;t<a;t++)if(0!==this._flowData.mask[r*a+t]){const e=this._flowData.data[2*(r*a+t)],s=this._flowData.data[2*(r*a+t)+1],i=Math.sqrt(e*e+s*s);f=Math.min(f,i),x=Math.max(x,i)}const w=new Uint8Array(4*a*l);for(let r=0;r<l;r++)for(let t=0;t<a;t++)if(0!==this._flowData.mask[r*a+t]){const e=this._flowData.data[2*(r*a+t)],s=this._flowData.data[2*(r*a+t)+1],i=(Math.sqrt(e*e+s*s)-f)/(x-f);w[4*(r*a+t)]=255*i,w[4*(r*a+t)+1]=0,w[4*(r*a+t)+2]=0,w[4*(r*a+t)+3]=255}else w[4*(r*a+t)]=0,w[4*(r*a+t)+1]=0,w[4*(r*a+t)+2]=0,w[4*(r*a+t)+3]=0;const y=new o.TextureDescriptor;y.internalFormat=s.PixelFormat.RGBA,y.wrapMode=s.TextureWrapMode.CLAMP_TO_EDGE,y.flipped=!0,y.width=a,y.height=l;const g=new i.Texture(e,y,w);this.vertexArray=_,this.program=u,this.texture=g,this.min=f,this.max=x,this._flowData=null}detach(){this.vertexArray.dispose(),this.texture.dispose()}get ready(){return this.program.compiled}}t.Imagery=c,t.ImageryResources=_,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
