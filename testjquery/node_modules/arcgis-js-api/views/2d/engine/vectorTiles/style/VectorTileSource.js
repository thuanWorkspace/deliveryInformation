/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../../core/lang","../../../../../core/urlUtils","../../../../../geometry/Extent","../../../../../layers/support/TileInfo","../../../../../layers/support/TilemapCache","../TilemapIndex","../TilemapRequest","./VectorTilesRequestManager"],(function(e,t,i,l,s,r,n,a){"use strict";class o{constructor(a,o,u){this.tilemap=null,this.tileInfo=null,this.capabilities=null,this.fullExtent=null,this.initialExtent=null,this.name=a,this.sourceUrl=o;const p=t.urlToObject(this.sourceUrl),h=e.clone(u),c=h.tiles;if(p)for(let e=0;e<c.length;e++){const i=t.urlToObject(c[e]);i&&(t.isAbsolute(i.path)||(i.path=t.join(p.path,i.path)),c[e]=t.addQueryParameters(i.path,{...p.query,...i.query}))}this.tileServers=c;const f=u.capabilities&&u.capabilities.split(",").map((e=>e.toLowerCase().trim())),m=!0===u?.exportTilesAllowed,d=!0===f?.includes("tilemap"),x=m&&u.hasOwnProperty("maxExportTilesCount")?u.maxExportTilesCount:0;this.capabilities={operations:{supportsExportTiles:m,supportsTileMap:d},exportTiles:m?{maxExportTilesCount:+x}:null},this.tileInfo=l.fromJSON(h.tileInfo);const y=u.tileMap?t.addQueryParameters(t.join(p.path,u.tileMap),p.query??{}):null;d?(this.type="vector-tile",this.tilemap=new n(new s.TilemapCache({layer:{parsedUrl:p,tileInfo:this.tileInfo},minLOD:h.minLOD??this.tileInfo.lods[0].level,maxLOD:h.maxLOD??this.tileInfo.lods[this.tileInfo.lods.length-1].level}),y)):y&&(this.tilemap=new r(y)),this.fullExtent=i.fromJSON(u.fullExtent),this.initialExtent=i.fromJSON(u.initialExtent)}destroy(){this.tilemap?.destroy()}async getRefKey(e,t){return await(this.tilemap?.dataKey(e,t))??e}requestTile(e,t,i,l){const s=this.tileServers[t%this.tileServers.length];return a.request(s,e,t,i,l)}isCompatibleWith(e){const t=this.tileInfo,i=e.tileInfo;if(!t.spatialReference.equals(i.spatialReference))return!1;if(!t.origin.equals(i.origin))return!1;if(Math.round(t.dpi)!==Math.round(i.dpi))return!1;const l=t.lods,s=i.lods,r=Math.min(l.length,s.length);for(let n=0;n<r;n++){const e=l[n],t=s[n];if(e.level!==t.level||Math.round(e.scale)!==Math.round(t.scale))return!1}return!0}}return o}));
