/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../MemoryBuffer","./enums","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(t,e,n,o,s){"use strict";class a{constructor(t){this._locations=new Map,this._key=t}get key(){return this._key}get type(){return 7&this._key}defines(){return[]}getStride(){return this._layoutInfo||this._buildAttributesInfo(),this._stride}getAttributeLocations(){return 0===this._locations.size&&this._buildAttributesInfo(),this._locations}getLayoutInfo(){return this._layoutInfo||this._buildAttributesInfo(),this._layoutInfo}getEncodingInfos(){return this._propertyEncodingInfo||this._buildAttributesInfo(),this._propertyEncodingInfo}getUniforms(){return this._uniforms||this._buildAttributesInfo(),this._uniforms}getShaderHeader(){return this._shaderHeader||this._buildAttributesInfo(),this._shaderHeader}getShaderMain(){return this._shaderMain||this._buildAttributesInfo(),this._shaderMain}setDataUniforms(t,e,n,o,s){const a=this.getUniforms();for(const r of a){const{name:a,type:i,getValue:c}=r,u=c(n,e,o,s);if(null!==u)switch(i){case"float":t.setUniform1f(a,u);break;case"vec2":t.setUniform2fv(a,u);break;case"vec4":t.setUniform4fv(a,u)}}}encodeAttributes(t,e,o,s){const a=this.attributesInfo(),r=this.getEncodingInfos(),i=[];let c=0,u=0;for(const y of Object.keys(r)){const d=r[y],{type:l,precisionFactor:f,isLayout:_}=a[y],p=_?o.getLayoutProperty(y):o.getPaintProperty(y),h=p.interpolator?.getInterpolationRange(e);let T=0;for(const o of d){const{offset:a,bufferElementsToAdd:r}=o;if(r>0){for(let t=0;t<r;t++)i.push(0);c+=u,u=o.bufferElementsToAdd}const y=s??p.getValue(h?h[T]:e,t);switch(l){case n.EncodingType.R8_SIGNED:case n.EncodingType.R8_UNSIGNED:i[c]|=this._encodeByte(y*(f||1),8*a);break;case n.EncodingType.R16_SIGNED:case n.EncodingType.R16_UNSIGNED:i[c]|=this._encodeShort(y*(f||1),8*a);break;case n.EncodingType.R8G8_SIGNED:case n.EncodingType.R8G8_UNSIGNED:i[c]|=this._encodeByte(y*(f||1),8*a),i[c]|=this._encodeByte(y*(f||1),8*a+8);break;case n.EncodingType.R16G16_SIGNED:case n.EncodingType.R16G16_UNSIGNED:i[c]|=this._encodeShort(y*(f||1),8*a),i[c]|=this._encodeShort(y*(f||1),8*a+16);break;case n.EncodingType.R8G8B8A8_SIGNED:case n.EncodingType.R8G8B8A8_UNSIGNED:i[c]|=this._encodeByte(y*(f||1),8*a),i[c]|=this._encodeByte(y*(f||1),8*a+8),i[c]|=this._encodeByte(y*(f||1),8*a+16),i[c]|=this._encodeByte(y*(f||1),8*a+24);break;case n.EncodingType.R8G8B8A8_COLOR:i[c]=this._encodeColor(y);break;case n.EncodingType.R16G16B16A16_DASHARRAY:case n.EncodingType.R16G16B16A16_PATTERN:this._encodePattern(c,i,y);break;default:throw new Error("Unsupported encoding type")}T++}}return i}getAtributeState(t){let e=0;const n=3+2*t;return e|=this._bit(n),e|=this._bit(n+1)<<1,e}_buildAttributesInfo(){const t=[],e={},s={};let r=-1;const i=this.attributesInfo(),c=this.attributes();let u=-1;for(const o of c){u++;const c=this.getAtributeState(u);if(c===n.AttributeStatus.UNIFORM||c===n.AttributeStatus.UNUSED)continue;const y=i[o],d=[];e[o]=d;const l=y.type;for(let e=0;e<c;e++){const{dataType:e,bytesPerElement:n,count:o,normalized:i}=a._encodingInfo[l],c=n*o,u=`${e}-${!0===i}`;let y=s[u],f=0;if(!y||y.count+o>4)r++,y={dataIndex:r,count:0,offset:0},4!==o&&(s[u]=y),t.push({location:-1,name:"a_data_"+r,count:o,type:e,normalized:i}),f=Math.ceil(Math.max(c/4,1));else{const e=t[y.dataIndex];e.count+=o;f=Math.ceil(Math.max(e.count*n/4,1))-Math.ceil(Math.max(y.offset/4,1))}d.push({dataIndex:y.dataIndex,offset:y.offset,bufferElementsToAdd:f}),y.offset+=c,y.count+=o}}for(const n of t)switch(n.type){case o.DataType.BYTE:case o.DataType.UNSIGNED_BYTE:n.count=4;break;case o.DataType.SHORT:case o.DataType.UNSIGNED_SHORT:n.count+=n.count%2}this._buildVertexBufferLayout(t);let y=0;const d=this._layoutInfo.geometry;for(const n of d)this._locations.set(n.name,y++);const l=this._layoutInfo.opacity;if(l)for(const n of l)this._locations.set(n.name,y++);this._buildShaderInfo(t,e),this._propertyEncodingInfo=e}_buildVertexBufferLayout(t){const e={},n=this.geometryInfo();let o=n[0].stride;if(0===t.length)e.geometry=n;else{const a=[];let i=o;for(const e of t)o+=r(e.type)*e.count;for(const t of n)a.push(new s.VertexElementDescriptor(t.name,t.count,t.type,t.offset,o,t.normalized));for(const e of t)a.push(new s.VertexElementDescriptor(e.name,e.count,e.type,i,o,e.normalized)),i+=r(e.type)*e.count;e.geometry=a}this.opacityInfo()&&(e.opacity=this.opacityInfo()),this._layoutInfo=e,this._stride=o}_buildShaderInfo(t,e){let o="\n",s="\n";const r=[];for(const n of t)o+=`attribute ${this._getType(n.count)} ${n.name};\n`;const c=this.attributes(),u=this.attributesInfo();let y=-1;for(const d of c){y++;const{name:t,type:c,precisionFactor:l,isLayout:f}=u[d],_=l&&1!==l?" * "+1/l:"",{bytesPerElement:p,count:h}=a._encodingInfo[c],T=t=>`a_data_${t.dataIndex}${i(h,t.offset,p)}`;switch(this.getAtributeState(y)){case n.AttributeStatus.UNIFORM:{const e=this._getType(h),a=`u_${t}`;r.push({name:a,type:e,getValue:(t,e,o,s)=>{const a=f?t.getLayoutValue(d,e):t.getPaintValue(d,e);if(c===n.EncodingType.R16G16B16A16_DASHARRAY){const n=t.getDashKey(a,t.getLayoutValue("line-cap",e)),o=s.getMosaicItemPosition(n,!1);if(null==o)return null;const{tl:r,br:i}=o;return[r[0],i[1],i[0],r[1]]}if(c===n.EncodingType.R16G16B16A16_PATTERN){const t=s.getMosaicItemPosition(a,!d.includes("line-"));if(null==t)return null;const{tl:e,br:n}=t;return[e[0],n[1],n[0],e[1]]}if(c===n.EncodingType.R8G8B8A8_COLOR){const t=a[3];return[t*a[0],t*a[1],t*a[2],t]}return a}}),o+=`uniform ${e} ${a};\n`,s+=`${e} ${t} = ${a};\n`}break;case n.AttributeStatus.DATA_DRIVEN:{const n=T(e[d][0]);s+=`${this._getType(h)} ${t} = ${n}${_};\n`}break;case n.AttributeStatus.INTERPOLATED_DATA_DRIVEN:{const n=`u_t_${t}`;r.push({name:n,type:"float",getValue:(t,e,n,o)=>(f?t.getLayoutProperty(d):t.getPaintProperty(d)).interpolator.interpolationUniformValue(n,e)}),o+=`uniform float ${n};\n`;const a=T(e[d][0]),i=T(e[d][1]);s+=`${this._getType(h)} ${t} = mix(${a}${_}, ${i}${_}, ${n});\n`}}}this._shaderHeader=o,this._shaderMain=s,this._uniforms=r}_bit(t){return(this._key&1<<t)>>t}_getType(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4"}throw new Error("Invalid count")}_encodeColor(t){const n=255*t[3];return e.i8888to32(t[0]*n,t[1]*n,t[2]*n,n)}_encodePattern(t,e,n){if(!n?.rect)return;const o=2,s=n.rect,a=n.width,r=n.height;e[t]=this._encodeShort(s.x+o,0),e[t]|=this._encodeShort(s.y+o+r,16),e[t+1]=this._encodeShort(s.x+o+a,0),e[t+1]|=this._encodeShort(s.y+o,16)}_encodeByte(t,e){return(255&t)<<e}_encodeShort(t,e){return(65535&t)<<e}}a._encodingInfo={[n.EncodingType.R8_SIGNED]:{dataType:o.DataType.BYTE,bytesPerElement:1,count:1,normalized:!1},[n.EncodingType.R8_UNSIGNED]:{dataType:o.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:1,normalized:!1},[n.EncodingType.R16_SIGNED]:{dataType:o.DataType.SHORT,bytesPerElement:2,count:1,normalized:!1},[n.EncodingType.R16_UNSIGNED]:{dataType:o.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:1,normalized:!1},[n.EncodingType.R8G8_SIGNED]:{dataType:o.DataType.BYTE,bytesPerElement:1,count:2,normalized:!1},[n.EncodingType.R8G8_UNSIGNED]:{dataType:o.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:2,normalized:!1},[n.EncodingType.R16G16_SIGNED]:{dataType:o.DataType.SHORT,bytesPerElement:2,count:2,normalized:!1},[n.EncodingType.R16G16_UNSIGNED]:{dataType:o.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:2,normalized:!1},[n.EncodingType.R8G8B8A8_SIGNED]:{dataType:o.DataType.BYTE,bytesPerElement:1,count:4,normalized:!1},[n.EncodingType.R8G8B8A8_UNSIGNED]:{dataType:o.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!1},[n.EncodingType.R8G8B8A8_COLOR]:{dataType:o.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!0},[n.EncodingType.R16G16B16A16_DASHARRAY]:{dataType:o.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1},[n.EncodingType.R16G16B16A16_PATTERN]:{dataType:o.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1}};const r=t=>{switch(t){case o.DataType.FLOAT:case o.DataType.INT:case o.DataType.UNSIGNED_INT:return 4;case o.DataType.SHORT:case o.DataType.UNSIGNED_SHORT:return 2;case o.DataType.BYTE:case o.DataType.UNSIGNED_BYTE:return 1}},i=(t,e,n)=>{const o=e/n;if(1===t)switch(o){case 0:return".x";case 1:return".y";case 2:return".z";case 3:return".w"}else if(2===t)switch(o){case 0:return".xy";case 1:return".yz";case 2:return".zw"}else if(3===t)switch(o){case 0:return".xyz";case 1:return".yzw"}return""};t.VTLMaterial=a,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
