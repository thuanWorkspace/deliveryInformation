/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/workers/workers","./GlyphMosaic","./GlyphSource","./SpriteMosaic","../../tiling/TileKey"],(function(t,e,s,r,i,o,n,l,a){"use strict";class c{constructor(t,e,s){this._layer=t,this._styleRepository=e,this.devicePixelRatio=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=e.abortMaybe(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const e=this._layer.currentStyleInfo.glyphsUrl,l=new n(e?r.addQueryParameters(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new o(1024,1024,l),this._broadcastPromise=i.open("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then((e=>{if(this._layer&&(this._connection?.close(),this._connection=e,this._layer&&!this._connection.closed)){const r=e.broadcast("setStyle",this._layer.currentStyleInfo.style,t);Promise.all(r).catch((t=>s.throwIfNotAbortError(t)))}}))}_requestSprite(t){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const r=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,r&&(this._inputSignalEventListener=u(e),r.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=e,o={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,o),this._spriteSourcePromise.then((t=>{s.throwIfAbortError(i),this._spriteMosaic=new l(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}))}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(t){const e=new l(1024,1024,250);return e.setSpriteSource(t),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,e}async setStyle(t,e){await this._broadcastPromise,this._styleRepository=t,this._requestSprite();const s=new n(this._layer.currentStyleInfo.glyphsUrl?r.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new o(1024,1024,s),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",e)),this._broadcastPromise}fetchTileData(t,e){return this._getRefKeys(t,e).then((t=>{const s=this._layer.sourceNameToSource,r=[];for(const e in s)r.push(e);return this._getSourcesData(r,t,e)}))}parseTileData(t,e){const s=t&&t.data;if(!s)return Promise.resolve(null);const{sourceName2DataAndRefKey:r,transferList:i}=s;return 0===Object.keys(r).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:r,styleLayerUIDs:t.styleLayerUIDs},{...e,transferList:i})))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,e,r){const i=a.pool.acquire(t.id),o=this._layer.sourceNameToSource[e],{level:n,row:l,col:c}=i;a.pool.release(i);try{return{protobuff:await o.requestTile(n,l,c,r),sourceName:e}}catch(u){if(s.isAbortError(u))throw u;return{protobuff:null,sourceName:e}}}_getRefKeys(t,e){const s=this._layer.sourceNameToSource,r=new Array;for(const i in s){const o=s[i].getRefKey(t,e);r.push(o)}return Promise.allSettled(r)}_getSourcesData(t,e,s){const r=[];for(let i=0;i<e.length;i++){const o=e[i],n="fulfilled"===o.status?o.value:null;if(null==n||null==t[i])r.push(null);else{const e=this._getTilePayload(n,t[i],s);r.push(e)}}return Promise.allSettled(r).then((t=>{const s={},r=[];for(let i=0;i<t.length;i++){const o=t[i],n="fulfilled"===o.status?o.value:null,l=n?.protobuff;if(!n||!l?.byteLength)continue;const a=e[i],c="fulfilled"===a.status?a.value:null;if(c){const t=c.id;s[n.sourceName]={refKey:t,protobuff:l},r.push(l)}}return{sourceName2DataAndRefKey:s,transferList:r}}))}}function u(t){return()=>t.abort()}t.TileHandler=c,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
