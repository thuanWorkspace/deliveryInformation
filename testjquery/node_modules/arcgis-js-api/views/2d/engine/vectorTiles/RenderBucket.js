/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../core/typedArrayUtil","./enums","./decluttering/util","../../../webgl/BufferObject","../../../webgl/enums","../../../webgl/VertexArrayObject"],(function(e,t,r,s,n,i,a,o){"use strict";class c{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this._data=e;let r=1;const s=new Uint32Array(e);this.layerUIDs=[];const n=s[r++];for(let i=0;i<n;i++)this.layerUIDs[i]=s[r++];this.bufferDataOffset=r,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(e){null!=this._data&&(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}class f extends c{constructor(e,t){super(e,t),this.type=s.BucketType.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.lineIndexStart=r[n++],this.lineIndexCount=r[n++];const i=r[n++];if(i>0){this.patternMap=new Map;for(let e=0;e<i;e++){const e=r[n++],t=r[n++],s=r[n++];this.patternMap.set(e,[t,s])}}this.bufferDataOffset=n}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=t.disposeMaybe(this.vao)}doPrepareForRendering(e,t,r){const s=new Uint32Array(t),n=new Int32Array(s.buffer),c=s[r++],f=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,c));r+=c;const u=s[r++],h=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,u));r+=u;const y=this.layer.lineMaterial;this.vao=new o.VertexArrayObject(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:f},h)}}class u extends c{constructor(e,t){super(e,t),this.type=s.BucketType.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.fillIndexStart=r[n++],this.fillIndexCount=r[n++],this.outlineIndexStart=r[n++],this.outlineIndexCount=r[n++];const i=r[n++];if(i>0){this.patternMap=new Map;for(let e=0;e<i;e++){const e=r[n++],t=r[n++],s=r[n++];this.patternMap.set(e,[t,s])}}this.bufferDataOffset=n}get memoryUsed(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=t.disposeMaybe(this.fillVAO),this.outlineVAO=t.disposeMaybe(this.outlineVAO)}doPrepareForRendering(e,t,r){const s=new Uint32Array(t),n=new Int32Array(s.buffer),c=s[r++],f=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,c));r+=c;const u=s[r++],h=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,u));r+=u;const y=s[r++],l=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,y));r+=y;const d=s[r++],A=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,d));r+=d;const b=this.layer,g=b.fillMaterial,I=b.outlineMaterial;this.fillVAO=new o.VertexArrayObject(e,g.getAttributeLocations(),g.getLayoutInfo(),{geometry:f},h),this.outlineVAO=new o.VertexArrayObject(e,I.getAttributeLocations(),I.getLayoutInfo(),{geometry:l},A)}}class h extends c{constructor(e,t,r){super(e,t),this.type=s.BucketType.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const i=new Uint32Array(e),a=new Int32Array(e),o=new Float32Array(e);let c=this.bufferDataOffset;this.isIconSDF=!!i[c++];const f=i[c++];for(let s=0;s<f;s++){const e=i[c++],t=i[c++],r=i[c++];this.iconPerPageElementsMap.set(e,[t,r])}const u=i[c++];for(let s=0;s<u;s++){const e=i[c++],t=i[c++],r=i[c++];this.glyphPerPageElementsMap.set(e,[t,r])}const h=i[c++],y=i[c++];this.iconOpacity=new Int32Array(h),this.textOpacity=new Int32Array(y),c=n.deserializeSymbols(i,a,o,c,this.symbols,r),this.bufferDataOffset=c}get memoryUsed(){return(this.data?.byteLength??0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+r.estimateSize(this.iconOpacity)+r.estimateSize(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const[t,r]of this.iconPerPageElementsMap)e+=r[1];for(const[t,r]of this.glyphPerPageElementsMap)e+=r[1];return e/3}doDestroy(){this.iconVAO=t.disposeMaybe(this.iconVAO),this.textVAO=t.disposeMaybe(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,t=this.iconVAO.vertexBuffers.opacity;e.length>0&&e.byteLength===t.byteLength&&t.setSubData(e,0,0,e.length);const r=this.textOpacity,s=this.textVAO.vertexBuffers.opacity;r.length>0&&r.byteLength===s.byteLength&&s.setSubData(r,0,0,r.length)}doPrepareForRendering(e,t,r){const s=new Uint32Array(t),n=new Int32Array(s.buffer),c=s[r++],f=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,c));r+=c;const u=s[r++],h=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,u));r+=u;const y=s[r++],l=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,y));r+=y;const d=s[r++],A=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,d));r+=d;const b=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,this.iconOpacity.buffer),g=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,this.textOpacity.buffer),I=this.layer,p=I.iconMaterial,O=I.textMaterial;this.iconVAO=new o.VertexArrayObject(e,p.getAttributeLocations(),p.getLayoutInfo(),{geometry:f,opacity:b},h),this.textVAO=new o.VertexArrayObject(e,O.getAttributeLocations(),O.getLayoutInfo(),{geometry:l,opacity:g},A)}}class y extends c{constructor(e,t){super(e,t),this.type=s.BucketType.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.circleIndexStart=r[n++],this.circleIndexCount=r[n++],this.bufferDataOffset=n}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=t.disposeMaybe(this.vao)}doPrepareForRendering(e,t,r){const s=new Uint32Array(t),n=new Int32Array(s.buffer),c=s[r++],f=i.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,new Int32Array(n.buffer,4*r,c));r+=c;const u=s[r++],h=i.BufferObject.createIndex(e,a.Usage.STATIC_DRAW,new Uint32Array(s.buffer,4*r,u));r+=u;const y=this.layer.circleMaterial;this.vao=new o.VertexArrayObject(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:f},h)}}e.CircleRenderBucket=y,e.FillRenderBucket=u,e.LineRenderBucket=f,e.RenderBucketBase=c,e.SymbolRenderBucket=h,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
