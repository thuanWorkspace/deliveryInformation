/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../core/pbf","../../../../core/promiseUtils","../../../../geometry/libtess","../../../../geometry/support/TileClipper","./Feature","./IndexMemoryBuffer","./SourceLayerData","./VertexMemoryBuffer","./buckets/CircleBucket","./buckets/FillBucket","./buckets/LineBucket","./buckets/SymbolBucket","./style/StyleDefinition","../../tiling/enums"],(function(e,t,r,s,i,l,n,o,a,c,u,f,y,h){"use strict";const p=8,_=14,d=16;class T{constructor(t,r,i,l,n){if(this._pbfTiles={},this._tileClippers={},this._client=i,this._tile=r,n){this._styleLayerUIDs=new Set;for(const e of n)this._styleLayerUIDs.add(e)}this._styleRepository=l,this._layers=this._styleRepository?.layers??[];const[o,a,c]=r.tileKey.split("/").map(parseFloat);this._level=o;const u=p+Math.max((this._level-_)*d,0);for(const f of Object.keys(t)){const r=t[f];this._pbfTiles[f]=new e(new Uint8Array(r.protobuff),new DataView(r.protobuff));if(r.refKey){const[e]=r.refKey.split("/").map(parseFloat),t=o-e;if(t>0){const e=(1<<t)-1,r=a&e,i=c&e;this._tileClippers[f]=new s.TileClipper(t,r,i,8,u)}}this._tileClippers[f]||(this._tileClippers[f]=new s.SimpleBuilder)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}async parse(e){const t=r.loadLibtess(),s=this._initialize(e),{returnedBuckets:i}=s;this._processLayers(s),this._linkReferences(s),this._filterFeatures(s);const l=[],n=new Set,o=(e,t)=>{n.has(e)||(l.push({name:e,repeat:t}),n.add(e))},a={};for(const r of i)r.getResources(r.tileClipper,o,a);if(this._tile.status===h.TileStatus.INVALID)return[];const c=this._fetchResources(l,a,e);return Promise.all([...c,t]).then((()=>this._processFeatures(s.returnedBuckets)))}_initialize(e){const t=e?.signal;return{signal:t,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,layers:r,zoom:s,sourceNameToTileClipper:i,sourceNameToUniqueSourceLayerBuckets:l,sourceNameToUniqueSourceLayers:n,returnedBuckets:o,layerIdToBucket:a,referencerUIDToReferencedId:c}=e;for(let u=r.length-1;u>=0;u--){const e=r[u];if(!this._canParseStyleLayer(e.uid)||e.minzoom&&s<Math.floor(e.minzoom)||e.maxzoom&&s>=e.maxzoom||e.type===y.StyleLayerType.BACKGROUND)continue;if(!t[e.source]||!i[e.source])continue;const f=t[e.source],h=i[e.source],p=e.sourceLayer,_=f[p];if(_){let t=n[e.source];if(t||(t=n[e.source]=new Set),t.add(e.sourceLayer),e.refLayerId)c.set(e.uid,e.refLayerId);else{const t=this._createBucket(e);if(t){t.layerUIDs=[e.uid],t.layerExtent=_.extent,t.tileClipper=h;let r=l[e.source];r||(r=l[e.source]={});let s=r[p];s||(s=r[p]=[]),s.push(t),o.push(t),a[e.id]=t}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:r}=e;r.forEach(((e,r)=>{t[e]&&t[e].layerUIDs.push(r)}))}_filterFeatures(e){const{signal:r,sourceNameToTileData:s,sourceNameToUniqueSourceLayerBuckets:l,sourceNameToUniqueSourceLayers:n}=e,o=10*this._level,a=10*(this._level+1),c=[],u=[];for(const t of Object.keys(n)){n[t].forEach((e=>{c.push(e),u.push(t)}))}for(let f=0;f<c.length;f++){const e=u[f],n=c[f];if(!s[e]||!l[e])continue;const y=s[e][n],h=l[e][n];if(!h||0===h.length)continue;if(t.isAborted(r))return;const p=y.getData();for(;p.nextTag(2);){const e=p.getMessage(),t=new i(e,y);e.release();const r=t.values;if(r){const e=r._minzoom;if(e&&e>=a)continue;const t=r._maxzoom;if(t&&t<=o)continue}for(const s of h)s.pushFeature(t)}}}_fetchResources(e,t,r){const s=[],i=this._tile.getWorkerTileHandler();let l,n;e.length>0&&(l=i.fetchSprites(e,this._client,r),s.push(l));for(const o in t){const e=t[o];e.size>0&&(n=i.fetchGlyphs(this._tile.tileKey,o,e,this._client,r),s.push(n))}return s}_processFeatures(e){const t=e.filter((e=>e.hasFeatures()||this._canParseStyleLayer(e.layer.uid)));for(const r of t)r.processFeatures(r.tileClipper);return t}_parseTileData(e){const t={};for(const r of Object.keys(e)){const s=e[r],i={};for(;s.next();)switch(s.tag()){case 3:{const e=s.getMessage(),t=new n(e);e.release(),i[t.name]=t;break}default:s.skip()}t[r]=i}return t}_createBucket(e){switch(e.type){case y.StyleLayerType.BACKGROUND:return null;case y.StyleLayerType.FILL:return this._createFillBucket(e);case y.StyleLayerType.LINE:return this._createLineBucket(e);case y.StyleLayerType.CIRCLE:return this._createCircleBucket(e);case y.StyleLayerType.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new c(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new o.FillVertexBuffer(e.fillMaterial.getStride()),new l.TriangleIndexBuffer,new o.OutlineVertexBuffer(e.outlineMaterial.getStride()),new l.TriangleIndexBuffer)}_createLineBucket(e){return new u(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new o.LineVertexBuffer(e.lineMaterial.getStride()),new l.TriangleIndexBuffer)}_createCircleBucket(e){return new a(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new o.CircleVertexBuffer(e.circleMaterial.getStride()),new l.TriangleIndexBuffer)}_createSymbolBucket(e){const t=this._tile;return new f(e,this._level,new o.SymbolVertexBuffer(e.iconMaterial.getStride()),new l.TriangleIndexBuffer,new o.SymbolVertexBuffer(e.textMaterial.getStride()),new l.TriangleIndexBuffer,t.placementEngine,t.getWorkerTileHandler())}}return T}));
