/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","exports","../../../../../core/arrayUtils","../../../../../core/Error","../../../../../core/Logger","../../../../../core/LRUCache","../../../../../support/arcadeOnDemand","../../../arcade/callExpressionWithFeature","../../../layers/support/cimSymbolUtils"],(function(e,t,r,s,i,a,n,l,o){"use strict";const u=i.getLogger("esri/views/2d/engine/webgl/util/Matcher");async function c(e,t,r,s){switch(e.type){case"simple":case"heatmap":return d.fromBasicRenderer(e,t,r,s);case"map":return p.fromUVRenderer(e,t,r,s);case"interval":return m.fromCBRenderer(e,t,r,s);case"dictionary":return b.fromDictionaryRenderer(e,t,r,s);case"pie-chart":return h.fromPieChartRenderer(e,t,r,s);case"subtype":return h.fromSubtypes(e,t,r,s)}}class d{constructor(){this.type="feature",this._defaultResult=null}static async fromBasicRenderer(e,t,r,s){const i=new d;if(e.symbol){const a=await o.expandSymbol(e.symbol,r,s),n=t.createTemplateGroup(a,null);i.setDefault(n)}return i}static async fromPieChartRenderer(e,t,r,s){const i=new d;if(e.markerSymbol){const a=await o.expandSymbol(e.markerSymbol,r,s);let n;e.fillSymbol&&(n=await o.expandSymbol(e.fillSymbol,r,s));const l=t.createTemplateGroup(a,n);i.setDefault(l)}return i}size(){return 1}getDefault(){return this._defaultResult}setDefault(e){this._defaultResult=e}match(e,t,r,s,i){return this.getDefault()}async analyze(e,t,r,s,i,a){return null}}class h extends d{constructor(e,t){super(),this._subMatchers=e,this._subtypeField=t}static async fromSubtypes(e,t,r,s){const i=new Map,a=[];for(const n in e.renderers){const l=parseInt(n,10),o=c(e.renderers[n],t,r,s).then((e=>i.set(l,e)));a.push(o)}return await Promise.all(a),new h(i,e.subtypeField)}match(e,t,r,s,i){const a=t.readAttribute(this._subtypeField),n=this._subMatchers.get(a);return n?n.match(e,t,r,s,i):null}}class m extends d{constructor(e,t,r,s){super(),this.type="interval",this._intervals=[],this._isMaxInclusive=t,this._fieldIndex=s,this._field=e,this._normalizationInfo=r}static async fromCBRenderer(e,t,r,s){const{isMaxInclusive:i,normalizationField:a,normalizationTotal:n,normalizationType:l}=e,u=e.field,c=new m(u,i,{normalizationField:a,normalizationTotal:n,normalizationType:l},e.fieldIndex),d=await o.expandSymbol(e.backgroundFillSymbol,r,s);await Promise.all(e.intervals.map((async e=>{const i=await o.expandSymbol(e.symbol,r,s),a=t.createTemplateGroup(i,d),n={min:e.min,max:e.max};c.add(n,a)})));const h=await o.expandSymbol(e.defaultSymbol,r,s);if(h){const e=t.createTemplateGroup(h,d);c.setDefault(e)}return c}add(e,t){this._intervals.push({interval:e,result:t}),this._intervals.sort(((e,t)=>e.interval.min-t.interval.min))}size(){return super.size()+this._intervals.length}match(e,t,r,s,i){if(null==this._fieldIndex&&!this._field)return this.getDefault();const a=null!=this._fieldIndex?t.getComputedNumericAtIndex(this._fieldIndex):this._getValueFromField(t);if(null==a||isNaN(a)||a===1/0||a===-1/0)return this.getDefault();for(let n=0;n<this._intervals.length;n++){const{interval:e,result:t}=this._intervals[n],r=a>=e.min,s=this._isMaxInclusive?a<=e.max:a<e.max;if(r&&s)return t}return this.getDefault()}_needsNormalization(){const e=this._normalizationInfo;return e&&(e.normalizationField||e.normalizationTotal||e.normalizationType)}_getValueFromField(e){const t=e.readAttribute(this._field);if(!this._needsNormalization()||null==t)return t;const{normalizationField:r,normalizationTotal:s,normalizationType:i}=this._normalizationInfo,a=e.readAttribute(r)??1;if(i)switch(i){case"esriNormalizeByField":return a?t/a:void 0;case"esriNormalizeByLog":return Math.log(t)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return t/s*100;default:return void u.error(`Found unknown normalization type: ${i}`)}else u.error("Normalization is required, but no type was set!")}}class p extends d{constructor(e,t,r){super(),this.type="map",this._nullResult=null,this._resultsMap=new Map,this._fields=[],this._fieldsIndex=r,this._fields=e,this._seperator=t||""}static async fromUVRenderer(e,t,r,s){const i=e.fieldDelimiter,a=[e.field];e.field2&&a.push(e.field2),e.field3&&a.push(e.field3);const n=await o.expandSymbol(e.backgroundFillSymbol,r,s),l=new p(a,i,e.fieldIndex);await Promise.all(e.map.map((async(e,i)=>{const a=await o.expandSymbol(e.symbol,r,s),u=i+1,c=t.createTemplateGroup(a,n,u);"<Null>"===e.value?l.setNullResult(c):l.add(e.value,c)})));const u=await o.expandSymbol(e.defaultSymbol,r,s);if(u){const e=Number.MAX_SAFE_INTEGER,r=t.createTemplateGroup(u,n,e);l.setDefault(r)}return l}setNullResult(e){this._nullResult=e}add(e,t){this._resultsMap.set(e.toString(),t)}size(){return super.size()+this._resultsMap.size}match(e,t,r,s,i){if(null==this._fieldsIndex&&!this._fields)return this.getDefault();const a=null!=this._fieldsIndex?t.getComputedStringAtIndex(this._fieldsIndex):this._getValueFromFields(t);if(null!==this._nullResult&&(null==a||""===a||"<Null>"===a))return this._nullResult;if(null==a)return this.getDefault();const n=a.toString();return this._resultsMap.has(n)?this._resultsMap.get(n):this.getDefault()}_getValueFromFields(e){const t=[];for(const r of this._fields){const s=e.readAttribute(r);null==s||""===s?t.push("<Null>"):t.push(s)}return t.join(this._seperator)}}async function f(e,t){const r=e||1;if("number"==typeof r)return(e,t,s)=>r;const s=await n.createRendererExpression(r,t.spatialReference,t.fields);return(e,r,i)=>l(s,e,{$view:i},t.geometryType,r)||1}let y;async function _(){return y||(y=new Promise(((t,r)=>e(["../../../layers/features/createSymbolSchema"],t,r)))),y}class b extends d{constructor(e,t,r,s,i,n){super(),this.type="dictionary",this._groupIdCache=new a.LRUCache(100),this._loader=e,this._fieldMap=e.fieldMap,this._symbolFields=e.getSymbolFields(),this._templates=t,this._info=r,this._scaleFn=s,this._schemaUtilsModule=i,this._symbolOptions=n}static async fromDictionaryRenderer(t,r,s,i){const[{DictionaryLoader:a},n]=await Promise.all([new Promise(((t,r)=>e(["../../../../../renderers/support/DictionaryLoader"],t,r))),_()]),l=new a(t.url,t.config,t.fieldMap);await l.fetchResources({spatialReference:s.spatialReference,fields:s.fields});const o=await f(t.scaleExpression,s);return new b(l,r,s,o,n,t.symbolOptions)}async _analyzeFeature(e,t,r,i,a){const n=e.readLegacyFeature(),l=this._scaleFn(n,r,i),c=this._attributeHash(n)+"-"+l,d=this._groupIdCache.get(c);if(d)return d;const h={...i,spatialReference:this._info.spatialReference,abortOptions:a,fields:this._info.fields},m=await this._loader.getSymbolAsync(n,h),p=this._schemaUtilsModule.createSymbolSchema(m,this._symbolOptions),f=o.expandSymbol(p,this._info,t,a).then((e=>{if("expanded-cim"!==e?.type)return u.error(new s("mapview-bad-type",`Found unexpected type ${e?.type} in dictionary response`)),null;e.hash+="-"+l;for(const t of e.layers)t.scaleFactor=l,t.templateHash+="-"+l;return this._templates.createTemplateGroup(e,null)}));return this._groupIdCache.put(c,f,1),f}async analyze(e,t,s,i,a,n){const l=t.getCursor(),o=[];for(;l.next();)o.push(this._analyzeFeature(l,s,i,a,n));return Promise.all(o).then((e=>e.filter(r.isSome)))}match(e,t,r,s,i){return null}_attributeHash(e){let t="";for(const r of this._symbolFields){const s=this._fieldMap?.[r];s&&(t+=e.attributes[s]+"-")}return t}}t.DictionaryMatcher=b,t.FeatureMatcher=d,t.IntervalMatcher=m,t.MapMatcher=p,t.SubtypeMatcher=h,t.createMatcher=c,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
