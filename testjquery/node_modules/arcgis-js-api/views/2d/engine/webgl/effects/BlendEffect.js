/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/Error","../../../../../core/Logger","../../../../../core/maybe","../enums","../VertexStream","../shaders/BlendPrograms","../../../../webgl/enums","../../../../webgl/Texture","../../../../webgl/TextureDescriptor"],(function(e,t,r,s,a,i,n,o,d,u){"use strict";const c=r.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");class l{constructor(){this._size=[0,0]}dispose(e){this._backBufferTexture=s.disposeMaybe(this._backBufferTexture),this._quad=s.disposeMaybe(this._quad)}draw(e,r,s,i,d){const{context:u,drawPhase:l}=e;if(this._setupShader(u),i&&"normal"!==i&&l!==a.WGLDrawPhase.LABEL)return void this._drawBlended(e,r,s,i,d);const f=n.createProgramTemplate("normal"),h=u.programCache.acquire(f.shaders.vertexShader,f.shaders.fragmentShader,f.attributes);if(!h)return void c.error(new t("mapview-BlendEffect",'Error creating shader program for blend mode "normal"'));u.useProgram(h),r.setSamplingMode(s),u.bindTexture(r,0),h.setUniform1i("u_layerTexture",0),h.setUniform1f("u_opacity",d),u.setBlendingEnabled(!0),u.setBlendFunction(o.BlendFactor.ONE,o.BlendFactor.ONE_MINUS_SRC_ALPHA);const _=this._quad;_.draw(),_.unbind(),h.dispose()}_drawBlended(e,r,s,a,i){const{context:d,state:u,pixelRatio:l,inFadeTransition:f}=e,{size:h}=u,_=d.getBoundFramebufferObject();let m,b;null!=_?(m=_.width,b=_.height):(m=Math.round(l*h[0]),b=Math.round(l*h[1])),this._createOrResizeTexture(e,m,b);const g=this._backBufferTexture;_.copyToTexture(0,0,m,b,0,0,g),d.setStencilTestEnabled(!1),d.setStencilWriteMask(0),d.setBlendingEnabled(!0),d.setDepthTestEnabled(!1),d.setDepthWriteEnabled(!1);const p=n.createProgramTemplate(a),x=d.programCache.acquire(p.shaders.vertexShader,p.shaders.fragmentShader,p.attributes);if(!x)return void c.error(new t("mapview-BlendEffect",`Error creating shader program for blend mode ${a}`));d.useProgram(x),g.setSamplingMode(s),d.bindTexture(g,0),x.setUniform1i("u_backbufferTexture",0),r.setSamplingMode(s),d.bindTexture(r,1),x.setUniform1i("u_layerTexture",1),x.setUniform1f("u_opacity",i),x.setUniform1f("u_inFadeOpacity",f?1:0),d.setBlendFunction(o.BlendFactor.ONE,o.BlendFactor.ZERO);const T=this._quad;T.draw(),T.unbind(),x.dispose(),d.setBlendFunction(o.BlendFactor.ONE,o.BlendFactor.ONE_MINUS_SRC_ALPHA)}_setupShader(e){this._quad||(this._quad=new i(e,[-1,-1,1,-1,-1,1,1,1]))}_createOrResizeTexture(e,t,r){const{context:s}=e;if(null===this._backBufferTexture||t!==this._size[0]||r!==this._size[1]){if(this._backBufferTexture)this._backBufferTexture.resize(t,r);else{const e=new u.TextureDescriptor;e.internalFormat=o.PixelFormat.RGBA,e.wrapMode=o.TextureWrapMode.CLAMP_TO_EDGE,e.width=t,e.height=r,this._backBufferTexture=new d.Texture(s,e)}this._size[0]=t,this._size[1]=r}}}e.BlendEffect=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
