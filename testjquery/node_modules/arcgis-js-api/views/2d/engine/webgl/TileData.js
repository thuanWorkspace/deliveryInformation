/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/arrayUtils","./enums","./MemoryRequirements","./TileBufferData","./TileDisplayData","./Utils","./WGLDisplayRecord","./cpuMapped/DisplayRecordReader","./mesh/VertexBuffer","./mesh/VertexVector","./util/Writer"],(function(e,t,r,s,a,i,o,n,f,l,c,u){"use strict";const d=new s,D=new s,y=5;function p(e,t){const r={};for(const s in e){const a={data:o.allocateTypedArrayBuffer(t,e[s]),stride:e[s]};r[s]=a}return r}function h(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}function m(e){const t=[[],[],[],[],[]],r=e;for(const s of r)for(const e of s.displayRecords)t[e.geometryType].push(e);return t}class x{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){if(d.reset(),!this.tileDisplayData)return;const e=m(this.tileDisplayData.displayObjects);for(const t of e)for(const e of t)e&&d.needMore(e.geometryType,e.meshData?e.meshData.vertexCount:e.vertexCount,e.meshData?e.meshData.indexData.length:e.indexCount);const r=e.length,s=new a;for(let a=0;a<r;++a){s.geometries[a].indexBuffer=new Uint32Array(Math.round(t.ReallocGrowthFactor*d.indicesFor(a)));const e=[],r=this.tileBufferData?.geometries[a].vertexBuffer;if(!r)continue;for(const t in r)e.push(r[t].stride);const i=x._computeVertexAlignment(e),n=Math.round(t.ReallocGrowthFactor*d.verticesFor(a)),f=x._align(n,i);for(const t in r){const e=r[t].stride;s.geometries[a].vertexBuffer[t]={stride:e,data:o.allocateTypedArrayBuffer(f,e)}}}D.reset(),this.tileDisplayData.displayList?.clear();for(let t=0;t<r;++t){const r=e[t];for(const e of r){if(e.meshData)e.writeMeshDataToBuffers(D.verticesFor(t),s.geometries[t].vertexBuffer,D.indicesFor(t),s.geometries[t].indexBuffer),e.meshData=null;else{const r=this.tileBufferData?.geometries[t];if(r){const a=r.vertexBuffer,i=r.indexBuffer,n=s.geometries[t].vertexBuffer,f=s.geometries[t].indexBuffer,l=D.verticesFor(t),c=D.indicesFor(t);o.copyMeshData(l,c,n,f,e,a,i),e.vertexFrom=l,e.indexFrom=c}}D.needMore(t,e.vertexCount,e.indexCount)}}const{displayList:i,displayObjects:n}=this.tileDisplayData;if(i)for(const t of n)i.addToList(t.displayRecords);this.tileBufferData=s}getStrides(){const e=[],t=this.tileBufferData?.geometries;if(!t)return e;for(let r=0;r<t.length;++r){const s=t[r];e[r]={};for(const t in s.vertexBuffer)e[r][t]=s.vertexBuffer[t].stride}return e}clone(){const e=new x;return e.tileBufferData=this.tileBufferData?.clone()??null,e.tileDisplayData=this.tileDisplayData?.clone()??null,e}_guessSize(){const e=this.tileDisplayData?.displayObjects??[],t=Math.min(e.length,4),r=12,s=40;let a=0;for(let i=0;i<t;i++)a=Math.max(a,e[i].displayRecords.length);return 2*(e.length*r+e.length*a*s)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new u(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}}static fromVertexData(e,t){const s={},a=new Map;for(const r of t)a.set(r.id,r);return o.forEachGeometryType((t=>{const i=e.data[t];if(null!=i){const e=f.DisplayRecordReader.from(i.records).getCursor();for(;e.next();){const r=e.id,s=e.materialKey,i=e.indexFrom,o=e.indexCount,f=e.vertexFrom,l=e.vertexCount,c=a.get(r),u=new n(r,t,s);u.indexFrom=i,u.indexCount=o,u.vertexFrom=f,u.vertexCount=l,c.displayRecords.push(u)}s[t]=l.VertexBuffers.fromVertexData(i,t)}else s[t]=new c.VertexVectors(t,0,r.WGLSymbologyType.DEFAULT).intoBuffers()})),x.fromMeshData({displayObjects:t,vertexBuffersMap:s})}static fromMeshData(e){const t=new x,r=new i,s=new a;r.displayObjects=e.displayObjects;for(const a in e.vertexBuffersMap){const t=a,r=e.vertexBuffersMap[t];s.geometries[t].indexBuffer=r.indexBuffer,s.geometries[t].vertexBuffer=r.namedBuffers}return t.tileDisplayData=r,t.tileBufferData=s,t}static bind(e,t){const r=new x;return r.tileDisplayData=e,r.tileBufferData=t,r}static create(e,t){const r=new x;r.tileDisplayData=new i,r.tileDisplayData.displayObjects=e;const s=[0,0,0,0,0],o=[0,0,0,0,0],f=[[],[],[],[],[]];for(const a of e)for(const e of a.displayRecords)f[e.geometryType].push(e),s[e.geometryType]+=e.meshData.vertexCount,o[e.geometryType]+=e.meshData.indexData.length;const l=new a,c=h(t);for(let a=0;a<y;a++){const e=new Uint32Array(o[a]),t=p(c[a],s[a]);n.writeAllMeshDataToBuffers(f[a],t,e),l.geometries[a]={indexBuffer:e,vertexBuffer:t}}return r.tileBufferData=l,r}static _align(e,t){const r=e%t;return 0===r?e:e+(t-r)}static _computeVertexAlignment(e){let t=!1,r=!1;for(const s of e)s%4==2?t=!0:s%4!=0&&(r=!0);return r?4:t?2:1}}e.TileData=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
