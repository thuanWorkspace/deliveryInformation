/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../../core/screenUtils","../../../../../../chunks/mat2d","../../../../../../chunks/mat2df32","../../../../../../chunks/vec2","../../../../../../chunks/vec2f32","../../alignmentUtils","../../number","../../Rect","../../collisions/BoundingBox"],(function(t,e,s,i,n,o,h,r,a,c){"use strict";const d=26,f=4,l=d+f,u=d-6,g=3,m=8,_=Math.PI/180,p=8,x=1.5;class y{constructor(t,e,s,n){this._rotationT=i.create(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const o=s.rect,h=new Float32Array(8);t*=n,e*=n;const r=s.code?o.width*n:s.metrics.width,a=s.code?o.height*n:s.metrics.height;this.width=r,this.height=a,h[0]=t,h[1]=e,h[2]=t+r,h[3]=e,h[4]=t,h[5]=e+a,h[6]=t+r,h[7]=e+a,this._data=h,this._setTextureCoords(o),this._scale=n,this._mosaic=s,this.x=t,this.y=e,this.maxOffset=Math.max(t+r,e+a)}get mosaic(){return this._mosaic}set angle(t){this._angle=t,s.fromRotation(this._rotationT,-t),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:e}=this._mosaic.metrics,n=e*this._scale,o=Math.abs(t)*this._scale,h=new Float32Array(8);h[0]=this.x,h[1]=this.y,h[2]=this.x+n,h[3]=this.y,h[4]=this.x,h[5]=this.y+o,h[6]=this.x+n,h[7]=this.y+o;const r=s.multiply(i.create(),this._rotationT,this._transform);i.transformMany(h,h,r);let a=1/0,d=1/0,f=0,l=0;for(let s=0;s<4;s++){const t=h[2*s],e=h[2*s+1];a=Math.min(a,t),d=Math.min(d,e),f=Math.max(f,t),l=Math.max(l,e)}const u=f-a,g=l-d,m=a+u/2,_=d+g/2;this._bounds=new c(m,_,u,g)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(t){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const e=this._offsets,n=new Float32Array(8),o=s.multiply(i.create(),this._rotationT,this._transform);i.transformMany(n,t,o),e.upperLeft=r.i1616to32(n[0]*m,n[1]*m),e.upperRight=r.i1616to32(n[2]*m,n[3]*m),e.lowerLeft=r.i1616to32(n[4]*m,n[5]*m),e.lowerRight=r.i1616to32(n[6]*m,n[7]*m)}_setTextureCoords({x:t,y:e,width:s,height:i}){this._texcoords={upperLeft:r.i1616to32(t,e),upperRight:r.i1616to32(t+s,e),lowerLeft:r.i1616to32(t,e+i),lowerRight:r.i1616to32(t+s,e+i)}}}const w=(t,e)=>({code:0,page:0,sdf:!0,rect:new a(0,0,11,8),textureBinding:e,metrics:{advance:0,height:4,width:t,left:0,top:0}});function M(t,e){return t.forEach((t=>n.transformMat2d(t,t,e))),{upperLeft:r.i1616to32(m*t[0][0],m*t[0][1]),upperRight:r.i1616to32(m*t[1][0],m*t[1][1]),lowerLeft:r.i1616to32(m*t[2][0],m*t[2][1]),lowerRight:r.i1616to32(m*t[3][0],m*t[3][1])}}class b{constructor(t,e,s){this._rotation=0,this._decorate(t,e,s),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=e.length>1,this._hasRotation=0!==s.angle,this._transform=this._createGlyphTransform(this.bounds,s),this._borderLineSize=s.borderLineSize,(s.borderLineSize||s.hasBackground)&&([this.bounds,this.background]=this.shapeBackground(this._transform));for(const i of t)i.setTransform(this._transform)}setRotation(t){if(0===t&&0===this._rotation)return;this._rotation=t;const e=this._transform,n=s.fromRotation(i.create(),t);s.multiply(e,n,e);for(const s of this.glyphs)s.setTransform(this._transform)}_decorate(t,e,s){if(!s.decoration||"none"===s.decoration||!t.length)return;const i=s.scale,n="underline"===s.decoration?l:u,o=t[0].textureBinding;for(const h of e){const e=h.startX*i,s=h.startY*i,r=(h.width+h.glyphWidthEnd)*i;t.push(new y(e,s+n*i,w(r,o),1))}}shapeBackground(t){const s=p,{xmin:i,ymin:n,xmax:o,ymax:h,x:r,y:a,width:d,height:f}=this.bounds,l=Math.min(d,f)+2*s-x,u=Math.min(e.pt2px(this._borderLineSize||0),l),g=(x+u)/2,m=this._borderLineSize?g:0,_=[i-s,n-s],y=[o+s,n-s],w=[i-s,h+s],b=[o+s,h+s],B=M([[_[0]-g,_[1]-g],[y[0]+g,y[1]-g],[_[0]+m,_[1]+m],[y[0]-m,y[1]+m]],t),L=M([[w[0]+m,w[1]-m],[b[0]-m,b[1]-m],[w[0]-g,w[1]+g],[b[0]+g,b[1]+g]],t),R=M([[_[0]-g,_[1]-g],[_[0]+m,_[1]+m],[w[0]-g,w[1]+g],[w[0]+m,w[1]-m]],t),T=M([[y[0]-m,y[1]+m],[y[0]+g,y[1]-g],[b[0]-m,b[1]-m],[b[0]+g,b[1]+g]],t),v={main:M([_,y,w,b],t),top:B,bot:L,left:R,right:T};return[new c(r,a,d+2*g,f+2*g),v]}get boundsT(){const t=this.bounds,e=n.set(o.create(),t.x,t.y);if(n.transformMat2d(e,e,this._transform),this._hasRotation){const s=Math.max(t.width,t.height);return new c(e[0],e[1],s,s)}return new c(e[0],e[1],t.width,t.height)}_createBounds(t){let e=1/0,s=1/0,i=0,n=0;for(const r of t)e=Math.min(e,r.xTopLeft),s=Math.min(s,r.yTopLeft),i=Math.max(i,r.xBottomRight),n=Math.max(n,r.yBottomRight);const o=i-e,h=n-s;return new c(e+o/2,s+h/2,o,h)}_createGlyphTransform(t,e){const h=_*e.angle,r=i.create(),a=o.create();return s.translate(r,r,n.set(a,e.xOffset,-e.yOffset)),e.isCIM?s.rotate(r,r,h):(s.translate(r,r,n.set(a,t.x,t.y)),s.rotate(r,r,h),s.translate(r,r,n.set(a,-t.x,-t.y))),r}}class B{constructor(t,e,s,i,n,o){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(e,s)),this.end=Math.max(0,Math.max(e,s)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=n,this.yMax=o}}const L=t=>10===t,R=t=>32===t;function T(t,e,s){const i=new Array,n=1/s.scale,o=s.maxLineWidth*n,h=e?t.length-1:0,r=e?-1:t.length,a=e?-1:1;let c=h,d=0,f=0,l=c,u=l,g=0,m=1/0,_=0;for(;c!==r;){const{code:e,metrics:s}=t[c],n=Math.abs(s.top);if(L(e)||R(e)||(m=Math.min(m,n),_=Math.max(_,n+s.height)),L(e))c!==h&&(i.push(new B(t,l,c-a,d,m,_)),m=1/0,_=0),d=0,l=c+a,u=c+a,f=0;else if(R(e))u=c+a,f=0,g=s.advance,d+=s.advance;else if(d>o){if(u!==l){const e=u-2*a;d-=g,i.push(new B(t,l,e,d-f,m,_)),m=1/0,_=0,l=u,d=f}else i.push(new B(t,l,c-a,d,m,_)),m=1/0,_=0,l=c,u=c,d=0;d+=s.advance,f+=s.advance}else d+=s.advance,f+=s.advance;c+=a}const p=new B(t,l,c-a,d,m,_);return p.start>=0&&p.end<t.length&&i.push(p),i}function v(t,e){let s=0;for(let o=0;o<t.length;o++){const{width:e}=t[o];s=Math.max(e,s)}const i="underline"===e.decoration?f:0,n=t[0].yMin;return{x:0,y:n,height:t[t.length-1].yMax+e.lineHeight*(t.length-1)+i-n,width:s}}function S(t,e,s){const i=s.scale,n=new Array,o=T(t,e,s),r=v(o,s),{vAlign:a,hAlign:c}=s,f=a===h.VAlign.Baseline?1:0,l=f?0:a-1,u=(1-f)*-r.y+l*(r.height/2)+(f?1:0)*-d;for(let h=0;h<o.length;h++){const{start:e,end:r,width:a}=o[h];let d=-1*(c+1)*(a/2)-g;const f=h*s.lineHeight+u-g;o[h].startX=d,o[h].startY=f;for(let s=e;s<=r;s++){const e=t[s];if(L(e.code))continue;const o=new y(d+e.metrics.left,f-e.metrics.top,e,i);d+=e.metrics.advance,n.push(o)}}return new b(n,o,s)}t.ShapedGlyph=y,t.ShapingInfo=b,t.shapeGlyphs=S,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
