/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../../../core/Error","../../../../../../core/Logger","../../../../../../core/mathUtils","../../../../../../core/screenUtils","../../../../../../chunks/mat2d","../../../../../../chunks/mat2df32","../../../../../../symbols/cim/enums","../../alignmentUtils","../../color","../../definitions","../../enums","../../number","../../materialKey/MaterialKey","./segmentUtils","./WGLTextTemplate"],(function(e,t,i,r,n,o,a,s,l,h,c,m,_,g,d){"use strict";const u=t.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate"),p=(t,i="mapview-labeling")=>u.error(new e(i,t)),f=1,y=0,b=4,x=25;function L(e,t){const r=!!e.minScale&&t.scaleToZoom(e.minScale)||0;return i.clamp(r,0,25.5)}function P(e,t){const r=!!e.maxScale&&t.scaleToZoom(e.maxScale)||255;return i.clamp(r,0,25.5)}function v(e){const t=new Map;return i=>(t.has(i)||t.set(i,e(i)),t.get(i))}const S=v((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t})),A=e=>Math.floor(127*e+127),M=e=>Math.floor(e*h.minMaxZoomPrecisionFactor),w=e=>Math.round(e*(254/360));class B extends d{constructor(e,t,i,n){super(e,i.font?.size,i.haloSize||0,i.font?.size,i.color&&l.premultiplyAlphaRGBAArray(i.color)||0,i.haloColor&&l.premultiplyAlphaRGBAArray(i.haloColor)||0,i.horizontalAlignment,i.verticalAlignment,s.isMapAligned(t.labelPlacement)?a.Alignment.MAP:a.Alignment.SCREEN,i.font?.decoration,!1,i.angle||0,i.xoffset,i.yoffset,i.lineWidth,i.lineHeight,null,null,!1,null,null,i.backgroundColor&&l.premultiplyAlphaRGBAArray(i.backgroundColor),i.borderLineColor&&l.premultiplyAlphaRGBAArray(i.borderLineColor),i.borderLineSize),this._outLineLabelAngle=0,this._refPlacementPadding=0,this._refPlacementDirX=0,this._refPlacementDirY=0,this._refOffsetX=0,this._refOffsetY=0,this._zoomLevel=0,this.geometryType=c.WGLGeometryType.LABEL,this._allowOverrun=t.allowOverrun??!1,this._repeatLabel=t.repeatLabel??!0,this._labelPosition=t.labelPosition??"curved";const o=L(t,n),m=P(t,n),g=t.labelPlacement,[d,u]=s.getAlignmentFromPlacement(g);this._xAlignD=d,this._yAlignD=u,this._minZoom=o,this._maxZoom=m,this._minBackgroundZoom=o,this._maxBackgroundZoom=m,this._refPlacementPadding=r.pt2px(i.haloSize)+h.textPlacementPadding,this._repeatLabelDistance=t.repeatLabelDistance?r.pt2px(t.repeatLabelDistance):128;const p=_.LabelMaterialKey.load(e);p.sdf=!0,this._materialKey=p.data}static fromLabelClass(e,t){if("esriServerLinePlacementCenterAlong"===e.labelPlacement){const t=e.symbol;t.xoffset=0,t.yoffset=0,t.angle=0,t.font.decoration="none"}return new B(e.materialKey,e,e.symbol,t)}get _shapedBox(){return this._shapingInfo.bounds}setZoomLevel(e){this._zoomLevel=e}bindReferenceTemplate(e){let t=s.getXDirection(this._xAlignD),i=s.getYDirection(this._yAlignD);if(this._refOffsetX=0,this._refOffsetY=0,null==e)return void(this._refSymbolAndPlacementOffset=m.i8888to32(0,0,A(t),A(i)));if("circle"===e.boundsType&&(t||i)){const e=Math.sqrt(t*t+i*i);t/=e,i/=e}const r=Math.max(e.height,e.width),n=this._refPlacementPadding*b;this._refSymbolAndPlacementOffset=m.i8888to32(n,r,A(t),A(i)),this._referenceSize=r,this._refPlacementDirX=t,this._refPlacementDirY=i,this._refOffsetX=e.xOffset,this._refOffsetY=e.yOffset}_write(e,t){if(null==this._shapingInfo)return;const i=this._shapingInfo,r=t.getDisplayId(),n="esriGeometryPolygon"===t.geometryType?t.readLegacyCentroid():t.readLegacyGeometry();if(n)switch(this._current={out:e,inId:r,inShaping:i,zoomLevel:this._zoomLevel},"esriGeometryPolyline"===t.geometryType&&"curved"===this._labelPosition&&(this._borderLineColor||this._backgroundColor)&&u.warnOnce("TextSymbol properties 'borderLineColor', 'borderLineSize', and 'backgroundColor' are not supported in curved labels"),t.geometryType){case"esriGeometryPolyline":this._placeLineLabels(n);break;case"esriGeometryPoint":case"esriGeometryPolygon":this._placePointLabels(n);break;default:p(`Geometry of type ${t.geometryType} is not supported`)}}_isVisible(e,t){const i=M(this._current.zoomLevel);return M(e)<=i&&i<=M(t)}_placePointLabels(e){const{out:t,inId:i,inShaping:r}=this._current;this._writeGlyphs(t,i,e,r)}_placeLineLabels(e){const t=g.smoothPaths(e.paths,this._current.inShaping.bounds.width),i=this._placeSubdivGlyphs.bind(this),r=(this._shapedBox.width+this._repeatLabelDistance)/(1<<f);for(const n of t)g.pathDivide(n,r,i,this._repeatLabel)}_placeSubdivGlyphs(e,t,i,r){const n=S(t),o=this._shapedBox.width/(1<<f),a=Math.sqrt(this._repeatLabelDistance)/(1<<f),s=Math.min(i,r-i),l=this._current.inShaping.isMultiline?x:Math.log2(s/(a+o/2)),h=0===t?l:Math.min(n,l),c=Math.max(this._minZoom,this._current.zoomLevel+f-h),m=this._current.zoomLevel-c,_=this._shapedBox.width/2*2**m;this._current.inShaping.isMultiline?0===t&&this._placeStraight(e,c):this._allowOverrun&&m<0?this._placeStraightAlong(e,this._minZoom):"parallel"===this._labelPosition?this._placeStraightAlong(e,c):"curved"===this._labelPosition&&this._placeCurved(e,c,_)}_placeStraight(e,t){const{out:i,inId:r,inShaping:n}=this._current,o=Math.ceil(e.angle*(180/Math.PI)%360),a=Math.ceil((e.angle*(180/Math.PI)+180)%360);this._outLineLabelAngle=w(o),this._writeGlyphs(i,r,e,n,t),this._outLineLabelAngle=w(a),this._writeGlyphs(i,r,e,n,t)}_placeCurved(e,t,i){const{out:r,inId:n}=this._current;r.metricStart(n,t,e.x,e.y,0,0,0,0);const o=e.clone(),a=e.angle*(180/Math.PI)%360,s=(e.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=w(a),this._placeFirst(o,t,1),this._placeBack(e,o,t,i,1),this._placeForward(e,o,t,i,1),this._outLineLabelAngle=w(s),this._placeFirst(o,t,0),this._placeBack(e,o,t,i,0),this._placeForward(e,o,t,i,0),r.metricEnd()}_placeStraightAlong(e,t){const{out:i,inId:r,inShaping:a}=this._current;i.metricStart(r,t,e.x,e.y,0,0,0,0);const s=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,c=a.glyphs.length>0&&(this._borderLineColor||this._backgroundColor);if(this._maxBackgroundZoom=x,this._minBackgroundZoom=Math.max(t,0),c){const t=_.LabelMaterialKey.load(this._materialKey);t.textureBinding=a.glyphs[0].textureBinding;const s=n.fromRotation(o.create(),-e.angle),[c,m]=a.shapeBackground(s);this._outLineLabelAngle=w(l),i.recordStart(r,t.data,this.geometryType,!0),this._writeBackgroundGeometry(i,r,e,c,m),i.recordEnd(),this._outLineLabelAngle=w(h),i.recordStart(r,t.data,this.geometryType,!0),this._writeBackgroundGeometry(i,r,e,c,m),i.recordEnd()}this._outLineLabelAngle=w(l),this._placeFirst(s,t,1,!0),this._outLineLabelAngle=w(h),this._placeFirst(s,t,0,!0),i.metricEnd()}_placeBack(e,t,i,r,n){const o=e.clone();let a=e.backwardLength+y;for(;o.prev()&&!(a>=r);)this._placeOnSegment(o,t,a,i,-1,n),a+=o.length+y}_placeForward(e,t,i,r,n){const o=e.clone();let a=e.remainingLength+y;for(;o.next()&&!(a>=r);)this._placeOnSegment(o,t,a,i,1,n),a+=o.length+y}_placeFirst(e,t,i,r=!1){const n=e,o=this._current.inShaping,a=o.glyphs,s=this._current.zoomLevel,{out:l,inId:h}=this._current;for(const c of a){const a=c.x>o.bounds.x?i:1-i,m=a*e.remainingLength+(1-a)*e.backwardLength,_=Math.abs(c.x+c.width/2-o.bounds.x),g=Math.max(0,s+Math.log2(_/(m+y))),d=Math.max(t,r?0:g);if(c.maxZoom=x,c.angle=e.angle+(1-i)*Math.PI,c.minZoom=d,this._writeGlyph(l,h,n.x,n.y,c),i&&this._isVisible(c.minZoom,c.maxZoom)){const e=c.bounds;l.metricBoxWrite(e.center[0],e.center[1],e.width,e.height)}}}_placeOnSegment(e,t,i,r,n,o){const a=this._current.inShaping.glyphs,{out:s,inId:l}=this._current,h=this._current.inShaping,c=this._current.zoomLevel,m=e.dx/e.length,_=e.dy/e.length,g={x:e.x+i*-n*m,y:e.y+i*-n*_};for(const d of a){const a=d.x>h.bounds.x?o:1-o;if(!(a&&1===n||!a&&-1===n))continue;const m=Math.abs(d.x+d.width/2-h.bounds.x),_=Math.max(0,c+Math.log2(m/i)-.1),u=Math.max(r,c+Math.log2(m/(i+e.length+y)));if(0!==_&&(d.angle=e.angle+(1-o)*Math.PI,d.minZoom=u,d.maxZoom=_,this._writeGlyph(s,l,g.x,g.y,d),o&&this._isVisible(d.minZoom,d.maxZoom))){const i=d.bounds,r=e.x-t.x,n=e.y-t.y;s.metricBoxWrite(i.center[0]+r,i.center[1]+n,i.width,i.height)}}}_writeGlyphs(e,t,i,r,n=this._minZoom){if(i.x<0||i.x>=512||i.y<0||i.y>=512)return;if(r.glyphs.length>0&&(this._borderLineColor||this._backgroundColor)){const n=_.LabelMaterialKey.load(this._materialKey);n.textureBinding=r.glyphs[0].textureBinding,e.recordStart(t,n.data,this.geometryType,!0),this._writeBackgroundGeometry(e,t,i,r.bounds,r.background),e.recordEnd()}const o=i.x+this._refOffsetX,a=i.y-this._refOffsetY;for(const c of r.glyphs)c.minZoom=n,c.maxZoom=this._maxZoom,this._writeGlyph(e,t,o,a,c);const s=this._refPlacementDirX,l=this._refPlacementDirY,h=r.boundsT;e.metricStart(t,n,o,a,s,l,this._referenceSize,this._materialKey),e.metricBoxWrite(h.center[0],h.center[1],h.width,h.height),e.metricEnd()}_writeVertexCommon(e,t,i,r){const n=this._color,o=this._haloColor,a=m.i8888to32(0,0,this._size,this._haloSize),s=Math.max(r.minZoom,this._minZoom),l=Math.min(r.maxZoom,this._maxZoom),h=m.i8888to32(M(s),M(l),this._outLineLabelAngle,0);e.vertexWrite(i),e.vertexWrite(t),e.vertexWrite(n),e.vertexWrite(o),e.vertexWrite(a),e.vertexWrite(this._refSymbolAndPlacementOffset),e.vertexWrite(h)}_writeBackgroundVertex(e,t,i,r,n,o){const a=m.i8888to32(0,0,this._size,this._haloSize),s=m.i8888to32(0,0,0,0),l=m.i8888to32(M(this._minBackgroundZoom),M(this._maxBackgroundZoom),this._outLineLabelAngle,1);e.vertexWrite(i),e.vertexWrite(t),e.vertexWrite(r),e.vertexWrite(s),e.vertexWrite(a),e.vertexWrite(this._refSymbolAndPlacementOffset),e.vertexWrite(l),e.vertexWrite(n),e.vertexWrite(o),e.vertexEnd()}}return B}));
