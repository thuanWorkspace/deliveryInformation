/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../core/has","./FreeList","./Utils"],(function(e,t,r){"use strict";const i=["FILL","LINE","MARKER","TEXT","LABEL"];function s(e){const t=e.getStrides(),r={};for(let s=0;s<t.length;s++)r[i[s]]=t[s];return r}const o=.5;class n{constructor(e,i,s,o){this._strides=e,this._displayList=i,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const n in e){this._freeListsAndStorage[n]={vtxFreeList:o?new t.FreeList(o):null,idxFreeList:o?new t.FreeList(o):null,vertexBuffers:{},indexBuffer:o?new Uint32Array(o):null};for(const t in e[n])this._freeListsAndStorage[n].vertexBuffers[t]={data:o?r.allocateTypedArrayBuffer(o,e[n][t]):null,stride:e[n][t]}}}static fromTileData(e,o){const d=s(e),a=[0,0,0,0,0],x=[0,0,0,0,0];for(const t of e.tileDisplayData.displayObjects)for(const e of t.displayRecords)a[e.geometryType]=Math.max(a[e.geometryType],e.vertexFrom+e.vertexCount),x[e.geometryType]=Math.max(x[e.geometryType],e.indexFrom+e.indexCount);const u=new n(d,e.tileDisplayData.displayList,o,void 0),c=e.tileBufferData?.geometries??[];for(let s=0;s<c.length;++s){const e=a[s],o=x[s],n=c[s],d=i[s],f=u._storageFor(d),l=c[s].indexBuffer;f.indexBuffer=l,f.idxFreeList=new t.FreeList(l.length),f.idxFreeList.allocate(o);let v=0;for(const t in n.vertexBuffer){const e=c[s].vertexBuffer[t];f.vertexBuffers[t].data=e.data,f.vertexBuffers[t].stride=e.stride;const i=r.strideToPackingFactor(e.stride),o=e.data.length*i/e.stride;v||(v=o)}f.vtxFreeList=new t.FreeList(v),f.vtxFreeList.allocate(e)}return u}delete(e){const t=i[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0}setMeshData(e,t,s,o,n){const d=i[e.geometryType];let a,x;e.meshData=null,void 0===e.vertexFrom?(x=t.vertexCount,a=this._allocateVertices(d,x)):t.vertexCount>e.vertexCount?(this._freeVertices(d,e.vertexFrom,e.vertexCount),x=t.vertexCount,a=this._allocateVertices(d,x)):t.vertexCount===e.vertexCount?(a=e.vertexFrom,x=e.vertexCount):(this._freeVertices(d,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),a=e.vertexFrom,x=t.vertexCount);let u,c,f,l=!0;if(void 0===e.indexFrom?(u=n,f=t.indexCount,c=this._allocateIndices(d,f)):t.indexCount>e.indexCount?(u=this._displayList.removeFromList(e),this._freeIndices(d,e.indexFrom,e.indexCount),f=t.indexCount,c=this._allocateIndices(d,f)):t.indexCount===e.indexCount?(l=!1,c=e.indexFrom,f=e.indexCount):(u=this._displayList.removeFromList(e),this._freeIndices(d,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),c=e.indexFrom,f=t.indexCount),-1!==a&&-1!==c){const i=this._storageFor(d);if(r.copyMeshData(a,c,i.vertexBuffers,i.indexBuffer,t,s,o),e.vertexFrom=a,e.indexFrom=c,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount)}return l&&this._displayList.addToList(e,u),!0}return-1!==a&&this._freeVertices(d,a,x),-1!==c&&this._freeIndices(d,c,f),e.setMeshDataFromBuffers(t,s,o),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const s=t.vertexBuffer,o=t.indexBuffer,n=i[e.geometryType],d=this._allocateVertices(n,e.vertexCount);if(-1===d)return this._freeVertices(n,d,e.vertexCount),!1;const a=this._allocateIndices(n,e.indexCount);if(-1===a)return this._freeVertices(n,d,e.vertexCount),this._freeIndices(n,a,e.indexCount),!1;const x=this._storageFor(n);if(r.copyMeshData(d,a,x.vertexBuffers,x.indexBuffer,e,s,o),e.vertexFrom=d,e.indexFrom=a,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in s)this._dirtyMap.markDirtyVertices(e.geometryType,t,d,e.vertexCount)}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const r=this._storageFor(e),i=r.vtxFreeList?.allocate(t);if(null==i||-1===i)return-1;const s=r.vtxFreeList?.fragmentation;return null==s||s>o?-1:i}_freeVertices(e,t,r){const i=this._storageFor(e);i.vtxFreeList?.free(t,r)}_freeIndices(e,t,r){const i=this._storageFor(e);i.idxFreeList?.free(t,r)}_allocateIndices(e,t){const r=this._storageFor(e),i=r.idxFreeList?.allocate(t);if(null==i||-1===i)return-1;const s=r.idxFreeList?.fragmentation;return null==s||s>o?-1:i}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}return n}));
