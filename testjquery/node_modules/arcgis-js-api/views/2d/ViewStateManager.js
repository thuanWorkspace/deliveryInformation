/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../chunks/tslib.es6","../../geometry","../../Viewpoint","../../core/Accessor","../../core/Error","../../core/has","../../core/Logger","../../core/reactiveUtils","../../core/screenUtils","../../core/Warning","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/accessorSupport/decorators/subclass","../../chunks/pe","../../geometry/Point","../../geometry/projection","../../geometry/support/spatialReferenceUtils","./PaddedViewState","./viewpointUtils","../../geometry/Extent"],(function(e,t,i,r,s,o,n,a,c,p,h,l,d,g,w,u,v,y,_,f,m,S){"use strict";function x(e){return"esri.Viewpoint"===e?.declaredClass}e.ViewStateManager=class extends s{constructor(e){super(e),this.constraints=null,this.ready=!1,this.resizeAlign="center",this.addHandles([c.watch((()=>this.constraints?.version),(e=>{this.constraints&&e&&this.ready&&(this.state.viewpoint=this.constraints.fit(this.state.paddedViewState.viewpoint))}),c.sync)])}get center(){if(!this.ready)return this._get("center");const{center:e,spatialReference:t}=this.state.paddedViewState;return this.state.commitProperty("id"),new v({x:e[0],y:e[1],spatialReference:t})}set center(e){if(null==e)return;if(!this.ready)return void this._set("center",e);let t;try{t=this._project(e,this.state.spatialReference)}catch(r){return void a.getLogger(this).error(new o("mapview:invalid-center","could not project the value in the view's spatial reference",{input:e,error:r}))}const i=this.viewpoint;m.centerAt(i,i,t),this.viewpoint=i}get extent(){return this.ready?(this.state.commitProperty("id"),this.state.paddedViewState.extent.clone()):this._get("extent")}set extent(e){if(null==e)return;if(!e.width||!e.height)return void a.getLogger(this).error(new o("mapview:invalid-extent","invalid extent size"));if(!this.ready)return this._set("extent",e),this._set("center",void 0),this._set("viewpoint",void 0),this._set("scale",void 0),void this._set("zoom",void 0);let t;try{t=this._project(e,this.state.spatialReference)}catch(r){return void a.getLogger(this).error(new o("mapview:invalid-extent","could not project the value in the view's spatial reference",{error:r}))}const i=this.viewpoint;m.setExtent(i,i,t,this.state.size,{constraints:this.constraints}),this.viewpoint=i}get padding(){return this.ready?this.state.padding:this._get("padding")}set padding(e){this.ready?(this.state.padding=e,this._set("padding",this.state.padding)):this._set("padding",e)}get resolution(){return this.ready?(this.state.commitProperty("id"),this.state.resolution):0}get rotation(){return this.ready?(this.state.commitProperty("id"),this.state.rotation):this._get("rotation")}set rotation(e){if(isNaN(e))return;if(!this.ready)return void this._set("rotation",e);const t=this.viewpoint;m.rotateTo(t,t,e),this.viewpoint=t}get scale(){return this.ready?(this.state.commitProperty("id"),this.state.scale):this._get("scale")}set scale(e){if(!e||isNaN(e))return;if(!this.ready){this._set("scale",e),this._set("zoom",void 0);const t=this._get("extent");return void(t&&(this._set("extent",void 0),this._set("center",t.center)))}const t=this.viewpoint;m.scaleTo(t,t,e),this.viewpoint=t}get viewpoint(){if(!this.ready)return this._get("viewpoint");return this.state.paddedViewState.viewpoint.clone()}set viewpoint(e){if(null==e)return;if(!this.ready)return this._set("viewpoint",e),this._set("extent",void 0),this._set("center",void 0),this._set("zoom",void 0),void this._set("scale",void 0);let t,i;try{t=this._project(e,this.state.spatialReference),!e.scale||isNaN(e.scale)?i=new o("mapview:invalid-viewpoint",`invalid scale value of ${e.scale}`):null==e.targetGeometry&&(i=new o("mapview:invalid-viewpoint","geometry not defined"))}catch(n){i=new o("mapview:invalid-viewpoint","could not project the value in the view's spatial reference",{error:n})}if(i)return void a.getLogger(this).error(i);this._scaleBeforeChangingSpatialReference=null;const s=new r({targetGeometry:new v,scale:0,rotation:0});m.copy(s,t),this.constraints?.constrain(s,this.state.paddedViewState.viewpoint),this.state.viewpoint=s,this._set("viewpoint",s)}get zoom(){return this.ready?this.constraints?.scaleToZoom(this.scale)??-1:this._get("zoom")}set zoom(e){if(!(e>=0))return;if(!this.ready){this._set("zoom",e),this._set("scale",void 0);const t=this._get("extent");return void(t&&(this._set("extent",void 0),this._set("center",t.center)))}const t=this.constraints?.zoomToScale(e)??0;if(!t)return void this._set("zoom",-1);const i=this.viewpoint;m.scaleTo(i,i,t),this.viewpoint=i,this._set("zoom",this.constraints?.scaleToZoom(this.scale)??-1)}getUserStartupOptions(e){if(!e[0]&&!e[1])return{center:void 0,rotation:void 0,scale:void 0};const{padding:t,constraints:i}=this,r=this._get("center"),s=this._get("extent"),o=this._get("scale"),n=this._get("rotation"),a=this._get("viewpoint"),c=this._get("zoom"),p=null!=c&&null!=i&&i.zoomToScale(c)||void 0;let h,l,d;const g=a?.rotation,w=a?.targetGeometry;"extent"===w?.type?h=w:"point"===w?.type&&(l=w,d=a?.scale);const u=s??h;return{center:r??l??u?.center,rotation:n??g,scale:(o??p??d??(u&&m.extentToScale(u,[e[0]-t.left-t.right,e[1]-t.top-t.bottom])))||void 0}}startup(e,t,i,r){const s=e.targetGeometry;try{this._project(e,i)}catch(o){a.getLogger(this).warn(new h("mapview:startup-projection-error","projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.",{center:s.toJSON(),spatialReference:i,error:o})),e.targetGeometry=r||new v({x:0,y:0,spatialReference:i})}this.constraints?.fit(e),this._set("state",new f({padding:this.padding,size:t,viewpoint:e})),this._set("ready",!0)}teardown(){this._set("ready",!1);const{center:[e,t],spatialReference:i,rotation:r,scale:s}=this.state.paddedViewState,o=new v({x:e,y:t,spatialReference:i});this._set("viewpoint",null),this._set("extent",null),this._set("center",o),this._set("zoom",-1),this._set("rotation",r),this._set("scale",s),this._set("state",null)}changeSpatialReference(e){const t=this.state.paddedViewState.clone();if(null==this._scaleBeforeChangingSpatialReference)this._scaleBeforeChangingSpatialReference=t.scale;else{const e=t.viewpoint.clone();e.scale=this._scaleBeforeChangingSpatialReference,t.viewpoint=e}const i=t.clone(),[s,o]=t.center;let c=null;try{c=this._project(new v({x:s,y:o,spatialReference:t.spatialReference}),e)}catch(l){u.isLoaded()||a.getLogger(this).warn(new h("mapview:spatial-reference-change","could not project the view's center to the new spatial reference",{center:c?.toJSON(),spatialReference:e,error:l}))}c||(c=new v({x:0,y:0,spatialReference:e}));const p=m.centerAt(new r({targetGeometry:new v,scale:0,rotation:0}),t.viewpoint,c);i.viewpoint=p;try{const r=20,s=[t.size[0]/2,t.size[1]/2],o=[s[0]+r,s[1]],a=t.toMap([0,0],o),{x:c,y:h}=this._project(new v({x:a[0],y:a[1],spatialReference:t.spatialReference}),e);a[0]=c,a[1]=h,i.toScreen(a,a);const l=m.angleBetween(s,a,o),d=Math.hypot(a[0]-s[0],a[1]-s[1])/r;!Number.isFinite(d)||Math.abs(d)>4?(p.rotation=0,p.targetGeometry=new v({x:0,y:0,spatialReference:e})):(p.scale*=d,p.scale>n("mapview-srswitch-adjust-rotation-scale-threshold")?p.rotation=0:p.rotation+=Number.isFinite(l)?l:0)}catch{}this._get("constraints")?.constrain(p,void 0),this._get("state").viewpoint=p}resize(e,t){if(!this.ready)return;const i=this.state;let r=this.state.paddedViewState.viewpoint;const s=this.state.paddedViewState.size.concat();i.size=[e,t],m.resize(r,r,s,this.state.paddedViewState.size,this.resizeAlign),r=this.constraints?.constrain(r,void 0)??r,this.state.viewpoint=r}toMap(e){if(!this.ready)return null;const t=[0,0],[i,r]=this.state.toMap(t,[e.x,e.y]),s=this.state.spatialReference;return new v({x:i,y:r,spatialReference:s})}toScreen(e,t){if(!this.ready)return null;const i=this._project(e,this.state.spatialReference),r=[i.x,i.y];return!1===t?.pickClosestTarget?this.state.toScreen(r,r):this.state.toScreenClosest(r,r),p.createScreenPoint(r[0],r[1])}_project(e,t){const i=e?.targetGeometry||e;if(!t)return e;if(!i)return null;if(t.imageCoordinateSystem||i.spatialReference?.imageCoordinateSystem)return e;if(_.equals(t,i.spatialReference))return e;const r=y.project(i,t);if(!r)throw new o("mapview:projection-not-possible","projecting input geometry to target spatial reference returned a null value",{geometry:i,spatialReference:t});return x(e)?(e.targetGeometry=r,e):r}},t.__decorate([l.property({type:v})],e.ViewStateManager.prototype,"center",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"constraints",void 0),t.__decorate([l.property({type:S})],e.ViewStateManager.prototype,"extent",null),t.__decorate([l.property({value:{top:0,right:0,bottom:0,left:0},cast:e=>({top:0,right:0,bottom:0,left:0,...e})})],e.ViewStateManager.prototype,"padding",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"ready",void 0),t.__decorate([l.property()],e.ViewStateManager.prototype,"resizeAlign",void 0),t.__decorate([l.property({readOnly:!0})],e.ViewStateManager.prototype,"resolution",null),t.__decorate([l.property({type:Number})],e.ViewStateManager.prototype,"rotation",null),t.__decorate([l.property({type:Number})],e.ViewStateManager.prototype,"scale",null),t.__decorate([l.property({readOnly:!0})],e.ViewStateManager.prototype,"state",void 0),t.__decorate([l.property({type:r})],e.ViewStateManager.prototype,"viewpoint",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"zoom",null),e.ViewStateManager=t.__decorate([w.subclass("esri.views.2d.ViewStateManager")],e.ViewStateManager),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
