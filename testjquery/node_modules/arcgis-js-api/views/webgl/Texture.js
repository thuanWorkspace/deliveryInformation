/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../core/Error","../../core/has","../../core/mathUtils","./checkWebGLError","./contextUtils","./enums","./GLObjectType","./TextureDescriptor","./ValidatedTextureDescriptor"],(function(e,t,r,i,o,s,a,n,l,p){"use strict";const d=4;let h=class{constructor(e,r=null,i=null){if(this.type=n.GLObjectType.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,i=r;else{const i=p.ValidatedTextureDescriptor.validate(e,r);if(!i)throw new t("Texture descriptor invalid");this._descriptor=i}if(this._descriptor.context.type!==s.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),f(this._descriptor.target)))throw new t("3D and array textures are not supported in WebGL1");this._descriptor.target===a.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(i):this.setData(i)}get glName(){return this._glName}get descriptor(){return this._descriptor}get gpuMemoryUsage(){return I.delete(this),l.estimateMemory(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(a.ResourceType.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const i=this._descriptor;if(i.width!==e||i.height!==r){if(this._wasImmutablyAllocated)throw new t("Immutable textures can't be resized!");i.width=e,i.height=r,this._descriptor.target===a.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let t=a.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;t<=a.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(e,r){if(!this._descriptor.context?.gl)return;const i=this._descriptor.context.gl;o.checkWebGLError(i),this._glName||(this._glName=i.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(a.ResourceType.Texture,this)),void 0===e&&(e=null);const s=this._descriptor,n=r??s.target,l=f(n);null===e&&(s.width=s.width||d,s.height=s.height||d,l&&(s.depth=s.depth??1));const p=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),c(this._descriptor.context,s),this._configurePixelStorage(),o.checkWebGLError(i);const T=this._deriveInternalFormat();if(M(e)){let t="width"in e?e.width:e.codedWidth,r="height"in e?e.height:e.codedHeight;const a=1;e instanceof HTMLVideoElement&&(t=e.videoWidth,r=e.videoHeight),s.width&&s.height,l&&s.depth,s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,T,s.hasMipmap,t,r,a),this._texImage(n,0,T,t,r,a,e),o.checkWebGLError(i),s.hasMipmap&&this.generateMipmap(),s.width||(s.width=t),s.height||(s.height=r),l&&!s.depth&&(s.depth=a)}else{const{width:r,height:a,depth:p}=s;if(null==r||null==a)throw new t("Width and height must be specified!");if(l&&null==p)throw new t("Depth must be specified!");if(s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,T,s.hasMipmap,r,a,p),g(e)){const o=e.levels,l=w(n,r,a,p),d=Math.min(l-1,o.length-1);null!=this._descriptor.context.gl2?i.texParameteri(s.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,d):s.hasMipmap=s.hasMipmap&&l===o.length;const h=T;if(!x(h))throw new t("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((e,t,r,i)=>{const s=o[Math.min(e,o.length-1)];this._compressedTexImage(n,e,h,t,r,i,s)}),d)}else this._texImage(n,0,T,r,a,p,e),o.checkWebGLError(i),s.hasMipmap&&this.generateMipmap()}u(i,this._descriptor),_(i,this._descriptor),m(this._descriptor.context,this._descriptor),o.checkWebGLError(i),this._descriptor.context.bindTexture(p,h.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,r,i,o,s,a,n=0){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor.context.gl,p=this._descriptor.context.gl2,d=this._descriptor,c=this._deriveInternalFormat(),{pixelFormat:u,dataType:_,target:m,isImmutable:T}=d;if(T&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");const x=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES,!0);if((r<0||i<0||o>d.width||s>d.height||r+o>d.width||i+s>d.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),n){if(!p)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(p.UNPACK_SKIP_ROWS,n)}if(M(a)?p?p.texSubImage2D(m,e,r,i,o,s,u,_,a):l.texSubImage2D(m,e,r,i,u,_,a):g(a)?l.compressedTexSubImage2D(m,e,r,i,o,s,c,a.levels[e]):l.texSubImage2D(m,e,r,i,o,s,u,_,a),n){if(!p)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(p.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(x,h.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,i,o,s,a,n,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const p=this._descriptor.context.gl2;if(null==p)throw new t("3D textures are not supported in WebGL1");const d=this._descriptor,c=this._deriveInternalFormat(),{pixelFormat:u,dataType:_,isImmutable:m,target:T}=d;if(m&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");f(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const x=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);if(this._descriptor.context.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),(r<0||i<0||o<0||s>d.width||a>d.height||n>d.depth||r+s>d.width||i+a>d.height||o+n>d.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),g(l))l=l.levels[e],p.compressedTexSubImage3D(T,e,r,i,o,s,a,n,c,l);else{const t=l;p.texSubImage3D(T,e,r,i,o,s,a,n,u,_,t)}this._descriptor.context.bindTexture(x,h.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new t("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,c(this._descriptor.context,e)}e.samplingMode===a.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=a.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):e.samplingMode===a.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=a.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,h.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,c(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor.context.gl,t=this._descriptor;this._samplingModeDirty&&(u(e,t),this._samplingModeDirty=!1),this._wrapModeDirty&&(_(e,t),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.context.type===s.ContextType.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===a.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=a.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case a.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case a.PixelFormat.RGBA:return this._descriptor.internalFormat=a.SizedPixelFormat.RGBA32F;case a.PixelFormat.RGB:return this._descriptor.internalFormat=a.SizedPixelFormat.RGB32F;default:throw new t("Unable to derive format")}case a.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case a.PixelFormat.RGBA:return this._descriptor.internalFormat=a.SizedPixelFormat.RGBA8;case a.PixelFormat.RGB:return this._descriptor.internalFormat=a.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===a.PixelFormat.DEPTH_STENCIL?a.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,r,i,o,s,a){const n=this._descriptor.context.gl2;if(null==n)throw new t("Immutable textures are not supported in WebGL1");if(!T(r))throw new t("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=i?w(e,o,s,a):1;if(f(e)){if(null==a)throw new t("Missing depth dimension for 3D texture upload");n.texStorage3D(e,l,r,o,s,a)}else n.texStorage2D(e,l,r,o,s);this._wasImmutablyAllocated=!0}_texImage(e,r,i,o,a,n,l){const p=this._descriptor.context.gl,d=f(e),{isImmutable:h,pixelFormat:c,dataType:u}=this._descriptor,_=this._descriptor.context.type===s.ContextType.WEBGL2,m=_?p:null;if(_||!M(l))if(h){if(null!=l){const i=l;if(d){if(null==n)throw new t("Missing depth dimension for 3D texture upload");m.texSubImage3D(e,r,0,0,0,o,a,n,c,u,i)}else p.texSubImage2D(e,r,0,0,o,a,c,u,i)}}else{const s=l;if(d){if(null==n)throw new t("Missing depth dimension for 3D texture upload");m.texImage3D(e,r,i,o,a,n,0,c,u,s)}else p.texImage2D(e,r,i,o,a,0,c,u,s)}else p.texImage2D(e,0,i,c,u,l)}_compressedTexImage(e,r,i,o,a,n,l){const p=this._descriptor.context.gl;let d=null;const h=f(e),c=this._descriptor.isImmutable;if(h){if(this._descriptor.context.type!==s.ContextType.WEBGL2)throw new t("3D textures are not supported in WebGL1");d=p}if(c){if(null!=l)if(h){if(null==n)throw new t("Missing depth dimension for 3D texture upload");d.compressedTexSubImage3D(e,r,0,0,0,o,a,n,i,l)}else p.compressedTexSubImage2D(e,r,0,0,o,a,i,l)}else if(h){if(null==n)throw new t("Missing depth dimension for 3D texture upload");d.compressedTexImage3D(e,r,i,o,a,n,0,l)}else p.compressedTexImage2D(e,r,i,o,a,0,l)}_forEachMipmapLevel(e,r=1/0){let{width:i,height:o,depth:s,hasMipmap:n,target:l}=this._descriptor;const p=l===a.TextureType.TEXTURE_3D;if(null==i||null==o||p&&null==s)throw new t("Missing texture dimensions for mipmap calculation");for(let t=0;e(t,i,o,s),n&&(1!==i||1!==o||p&&1!==s)&&!(t>=r);++t)i=Math.max(1,i>>1),o=Math.max(1,o>>1),p&&(s=Math.max(1,s>>1))}};function c(e,t){(null!=t.width&&t.width<0||null!=t.height&&t.height<0||null!=t.depth&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=e.type===s.ContextType.WEBGL2;if(r||!t.isImmutable&&!f(t.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),r)return;null!=t.width&&i.isPowerOfTwo(t.width)&&null!=t.height&&i.isPowerOfTwo(t.height)||("number"==typeof t.wrapMode?t.wrapMode!==a.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):t.wrapMode.s===a.TextureWrapMode.CLAMP_TO_EDGE&&t.wrapMode.t===a.TextureWrapMode.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),t.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function u(e,t){let r=t.samplingMode,i=t.samplingMode;r===a.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||r===a.TextureSamplingMode.LINEAR_MIPMAP_LINEAR?(r=a.TextureSamplingMode.LINEAR,t.hasMipmap||(i=a.TextureSamplingMode.LINEAR)):r!==a.TextureSamplingMode.NEAREST_MIPMAP_NEAREST&&r!==a.TextureSamplingMode.NEAREST_MIPMAP_LINEAR||(r=a.TextureSamplingMode.NEAREST,t.hasMipmap||(i=a.TextureSamplingMode.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}function _(e,t){"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function m(e,t){const r=e.capabilities.textureFilterAnisotropic;if(!r)return;e.gl.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}function T(e){return e in a.SizedPixelFormat}function x(e){return e in a.CompressedTextureFormat}function g(e){return null!=e&&"type"in e&&"compressed"===e.type}function E(e){return null!=e&&"byteLength"in e}function M(e){return null!=e&&!g(e)&&!E(e)}function f(e){return e===a.TextureType.TEXTURE_3D||e===a.TextureType.TEXTURE_2D_ARRAY}function w(e,t,r,i=1){let o=Math.max(t,r);return e===a.TextureType.TEXTURE_3D&&(o=Math.max(o,i)),Math.round(Math.log(o)/Math.LN2)+1}function A(){if(0===I.size)return;const e=new Array;return I.forEach(((t,r)=>e.push([r.gpuMemoryUsage,t]))),I.clear(),e.sort(((e,t)=>t[0]-e[0])),e.reduce(((e,t)=>`${e}\n\n${Math.round(t[0]/1024)}KB: ${t[1]}`),`Total unestimated texture memory: ${Math.round(e.reduce(((e,t)=>e+t[0]),0)/1024)}KB`)}h.TEXTURE_UNIT_FOR_UPDATES=0;const I=new Map;e.Texture=h,e.clearUnestimatedTextures=A,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
