/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/mathUtils","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/vector","../../../support/geometry2dUtils"],(function(t,e,i,s,n,r,a,o,c){"use strict";class h{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(t,e,i,s=0,n=p.IMMEDIATE){this._helper=t,this._planeType=e,this._edge=i,this.distance=s,this._plane=a.create(),this._offsetPlane=a.create(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===p.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this._edge.leftVertex.pos),e=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),i=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=n.direction(r.create(),t,i),this._left=this._computeNeighbor(t,e,this._edgeDirection),this._right=this._computeNeighbor(i,s,this._edgeDirection)}_toXYZ(t){return null!=t?this._helper.toXYZ(t):null}_pointToXYZ(t){return this._toXYZ(this._helper.pointToVector(t))}_computeNeighbor(t,e,i){if(null==e)return{start:t,end:e,direction:r.fromValues(-i[1],i[0],0),isOriginalDirection:!0};const s=n.direction(r.create(),t,e),a=!this._passesBisectingAngleThreshold(s,i);return{start:t,end:e,direction:a?this._bisectVectorsPerpendicular(i,s):s,isOriginalDirection:!a}}_passesBisectingAngleThreshold(t,e){const i=Math.abs(o.angle(e,t));return i>=l&&i<=Math.PI-l}_bisectVectorsPerpendicular(t,e){const i=n.dot(t,e)<0?t:n.negate(r.create(),t),s=Math.abs(n.dot(i,e));if(!(s<_||s>1-_))return this._bisectDirection(i,e);const a=n.cross(r.create(),i,[0,0,1]);return n.normalize(a,a)}_bisectDirection(t,e){const i=n.add(r.create(),t,e);return n.normalize(i,i)}_initializePlane(){const t=this._computeNormalDirection(this._left),e=this._computeNormalDirection(this._right);n.dot(t,e)<0&&n.negate(e,e),a.fromPositionAndNormal(this._left.start,this._bisectDirection(t,e),this._plane)}_computeNormalDirection(e){const i=n.cross(r.create(),e.direction,this._edgeDirection);n.normalize(i,i);const s=n.cross(r.create(),this._edgeDirection,i);return this._planeType===t.PlaneType.XY&&(s[2]=0),n.normalize(s,s)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(a.signedDistance(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(a.signedDistance(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const e=a.normal(t),o=this._edgeDirection,h=n.add(r.create(),this._left.start,this._left.direction),l=n.add(r.create(),this._right.start,this._right.direction),_=this._pointInBasis2D(s.create(),e,o,this._left.start),d=this._pointInBasis2D(s.create(),e,o,h),p=this._pointInBasis2D(s.create(),e,o,this._right.start),g=this._pointInBasis2D(s.create(),e,o,l),[u]=c.intersectLineAndRay({start:d,end:_,type:c.LineType.LINE},{start:g,end:p,type:c.LineType.LINE});if(!u)return;const D=i.subtract(s.create(),_,d);i.normalize(D,D);const f=i.subtract(s.create(),u,d),m=i.dot(D,f),y=n.add(r.create(),h,n.scale(r.create(),this._left.direction,-m)),E=a.signedDistance(t,y);this._updateDistanceConstraint(E)}_pointInBasis2D(t,e,i,s){return t[0]=o.projectPointSignedLength(e,s),t[1]=o.projectPointSignedLength(i,s),t}_offset(t,e){Number.isFinite(this._minDistance)&&(e=Math.max(this._minDistance,e)),Number.isFinite(this._maxDistance)&&(e=Math.min(this._maxDistance,e)),a.copy(this._offsetPlane,this._plane),this._offsetPlane[3]-=e;const i=(t,e,i)=>null!=e&&a.intersectLine(this._offsetPlane,t,n.add(r.create(),t,e),i),s=r.create();(t===this._edge.leftVertex?i(this._left.start,this._left.direction,s):i(this._right.start,this._right.direction,s))&&this._helper.copy(this._helper.fromXYZ(s,void 0,this._helper.getM(t.pos)),t.pos)}selectArrowFromStartPoint(t){this._selectedArrow=a.isPointInside(this.plane,this._pointToXYZ(t))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(t){return a.signedDistance(this.plane,this._pointToXYZ(t))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof h&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&n.equals(a.normal(this._plane),a.normal(t._plane))}accumulate(t,e){const i=this._plane[3]-e._plane[3]+e.distance;this._offset(t,i)}accumulateParams(t){const e=t.distance-t._plane[3];this.distance=e+this._plane[3]}clone(){const t=new h(this._helper,this._planeType,this._edge,this.distance,p.DEFERRED);return a.copy(t._plane,this._plane),a.copy(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=n.copy(r.create(),this._edgeDirection),t}_maybeEqualsVec3(t,e){return null==t&&null==e||null!=t&&null!=e&&n.equals(t,e)}_cloneNeighbor({start:t,end:e,direction:i,isOriginalDirection:s}){return{start:n.copy(r.create(),t),end:null!=e?n.copy(r.create(),e):null,direction:n.copy(r.create(),i),isOriginalDirection:s}}}const l=e.deg2rad(15),_=.001;var d,p;t.PlaneType=void 0,(d=t.PlaneType||(t.PlaneType={}))[d.XYZ=0]="XYZ",d[d.XY=1]="XY",function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(p||(p={})),t.OffsetEdgeVertex=h,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
