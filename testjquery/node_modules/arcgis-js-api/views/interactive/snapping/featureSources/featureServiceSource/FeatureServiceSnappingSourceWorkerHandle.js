/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/Accessor","../../../../../core/arrayUtils","../../../../../core/maybe","../../../../../core/promiseUtils","../../../../../core/accessorSupport/decorators/property","../../../../../core/accessorSupport/ensureType","../../../../../core/has","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/support/UpdatingHandles","../../../../../core/workers/WorkerHandle","../../../../../geometry/support/typeUtils","../../../../../layers/graphics/dehydratedPoint"],(function(e,t,r,o,i,a,n,s,d,l,p,u,c,h){"use strict";e.FeatureServiceSnappingSourceWorkerHandle=class extends r{get updating(){return this._updatingHandles.updating||this._workerHandleUpdating}constructor(e){super(e),this._updatingHandles=new p.UpdatingHandles,this._suspendController=null,this.schedule=null,this.hasZ=!1,this.elevationAlignPointsInFeatures=async e=>{const t=[];for(const{points:r}of e.pointsInFeatures)for(const{z:e}of r)t.push(e);return{elevations:t,drapedObjectIds:new Set,failedObjectIds:new Set}},this.queryForSymbologySnapping=async()=>({candidates:[],sourceCandidateIndices:[]}),this.availability=0,this._workerHandleUpdating=!0,this._editId=0,this.updateOutFields=a.debounce((async(e,t)=>{await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields",[...e],t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}))}destroy(){this._suspendController=i.abortMaybe(this._suspendController),this._workerHandle.destroy(),this._updatingHandles.destroy()}initialize(){this._workerHandle=new y(this.schedule,{alignElevation:async(e,{signal:t})=>({result:await this.elevationAlignPointsInFeatures(e.query,t)}),getSymbologyCandidates:async(e,{signal:t})=>({result:await this.queryForSymbologySnapping(e,t)})}),this.addHandles([this._workerHandle.on("notify-updating",(({updating:e})=>this._workerHandleUpdating=e)),this._workerHandle.on("notify-availability",(({availability:e})=>this._set("availability",e)))])}async setup(e,t){const r=this._serviceInfoFromLayer(e.layer);if(null==r)return;const o={configuration:this._convertConfiguration(e.configuration),serviceInfo:r,spatialReference:e.spatialReference.toJSON(),hasZ:this.hasZ,elevationInfo:e.layer.elevationInfo?.toJSON()};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup",o,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const r=this._convertConfiguration(e);await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure",r,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh",{},e)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const{point:r,filter:o,coordinateHelper:i}=e,a={...e,point:h.makeDehydratedPoint(r[0],r[1],r[2],i.spatialReference.toJSON()),filter:o?.toJSON()};return this._workerHandle.invoke(a,t)}async updateTiles(e,t){const r={tiles:e.tiles,tileInfo:null!=e.tileInfo?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles",r,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,t){const r=this._editId++,i={id:r};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits",i,t));const n=await this._updatingHandles.addPromise(a.whenOrAbort(e.result,t)),s={id:r,edits:{addedFeatures:n.addedFeatures?.map((({objectId:e})=>e)).filter(o.isSome)??[],deletedFeatures:n.deletedFeatures?.map((({objectId:e,globalId:t})=>({objectId:e,globalId:t})))??[],updatedFeatures:n.updatedFeatures?.map((({objectId:e})=>e)).filter(o.isSome)??[]}};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits",s,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}getDebugInfo(e){return this._workerHandle.invokeMethod("getDebugInfo",{},e)}async notifyElevationSourceChange(){await this._workerHandle.invokeMethod("notifyElevationSourceChange",{})}async notifySymbologyChange(){await this._workerHandle.invokeMethod("notifySymbologyChange",{})}async setSymbologySnappingSupported(e){await this._workerHandle.invokeMethod("setSymbologySnappingSupported",e)}async setSuspended(e){this._suspendController?.abort(),this._suspendController=new AbortController,await this._workerHandle.invokeMethod("setSuspended",e,this._suspendController.signal)}_convertConfiguration(e){return{filter:null!=e.filter?e.filter.toJSON():null,customParameters:e.customParameters,viewType:e.viewType}}_serviceInfoFromLayer(e){return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl?.path??"",fieldsIndex:e.fieldsIndex.toJSON(),geometryType:c.featureGeometryTypeKebabDictionary.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:e.timeInfo?.toJSON()}}},t.__decorate([n.property({constructOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"schedule",void 0),t.__decorate([n.property({constructOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"hasZ",void 0),t.__decorate([n.property({constructOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"elevationAlignPointsInFeatures",void 0),t.__decorate([n.property({constructOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"queryForSymbologySnapping",void 0),t.__decorate([n.property({readOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"updating",null),t.__decorate([n.property({readOnly:!0})],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"availability",void 0),t.__decorate([n.property()],e.FeatureServiceSnappingSourceWorkerHandle.prototype,"_workerHandleUpdating",void 0),e.FeatureServiceSnappingSourceWorkerHandle=t.__decorate([l.subclass("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],e.FeatureServiceSnappingSourceWorkerHandle);class y extends u.WorkerHandle{constructor(e,t){super("FeatureServiceSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:t})}}Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
