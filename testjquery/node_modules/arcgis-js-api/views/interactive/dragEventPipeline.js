/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../geometry","../../core/arrayUtils","../../core/has","../../core/lang","../../core/mathUtils","../../core/screenUtils","../../chunks/vec3f64","../../geometry/projection","../../layers/graphics/hydratedFeatures","../../layers/graphics/sources/interfaces","../../support/elevationInfoUtils","../ViewingMode","../draw/support/drawUtils","../../geometry/Point"],(function(e,n,t,r,a,o,l,c,i,s,u,p,f,d,m){"use strict";function y(e,n){let t=null,r=null;return a=>{if("cancel"===a.action)return void(null!=r&&(r.execute({action:"cancel"}),t=null,r=null));const o={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&null==t&&(t=new U,r=new U,n(e,t,r,a.pointerType,o)),null!=t&&t.execute(o),"end"===a.action&&null!=t&&(t=null,r=null)}}function g(e,n){return e.events.on("drag",y(e,n))}function x(e,n){const t=[e.x,e.y,e.z??0],r=n,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const l=e=>{const n=(e.x-t[0])*a[0]+(e.y-t[1])*a[1];e.x=t[0]+n*a[0],e.y=t[1]+n*a[1]};return e=>(l(e.mapStart),l(e.mapEnd),{...e,axis:a})}function S(e,n){let t=null;return r=>{if("start"===r.action&&(t=E(e,r.mapStart.spatialReference,n)),null==t)return null;const a=r.mapEnd.x-r.mapStart.x,o=r.mapEnd.y-r.mapStart.y,l=r.mapEnd.z-r.mapStart.z;return t.move(a,o,l,r.action),{...r,translationX:a,translationY:o,translationZ:l}}}function h(e,n){return null==e?null:e.spatialReference.equals(n)?e.clone():i.project(e,n)}function E(e,n,t){const r=e.geometry,a=s.hydratedSpatialReference(n);if(null==r)return null;if("mesh"===r.type)return v(e,r,a,t);const o=h(r,a),l=r.spatialReference;return null==o?null:{move:(n,t,r)=>{const a=d.move(o.clone(),n,t,r);a.spatialReference.equals(l)?e.geometry=a:e.geometry=i.project(a,l)}}}function v(e,n,t,r){if(n.vertexSpace.isRelative)return M(e,n,n.vertexSpace,t);if(!n.spatialReference.equals(t))return null;let a=0,o=0,l=0;return{move:(t,c,i)=>{const s=t-a,u=c-o,p=i-l;if(s||u||p){const d=new m(n.origin.x+s,n.origin.y+u,(n.origin.z??0)+p,n.origin.spatialReference);n.centerAt(d,{geographic:n.vertexSpace.isRelative?void 0:r===f.ViewingMode.Global}),e.notifyGeometryChanged(),a=t,o=c,l=i}}}}function M(e,n,t,r){const a=h(t.getOriginPoint(n.spatialReference),r),o=n.spatialReference;return null==a?null:{move:(n,r,l,c)=>{const s=d.move(a.clone(),n,r,l);if(s.spatialReference.equals(o))t.setOriginFromPoint(s);else{const e=i.project(s,o);null!=e&&t.setOriginFromPoint(e)}if(t.isGeoreferenced)e.notifyGeometryChanged();else{const n="end"===c;e.notifyMeshTransformChanged(n?{action:u.MeshTransformUpdateAction.UpdateFastLocalOrigin}:{})}}}}function P(e,n=null,t){let r=null;const a=null==n||e.spatialReference?.equals(n)?e=>e:e=>null!=e?i.project(e,n):e,o={exclude:[],...t};return n=>{if("start"===n.action&&(r=a(e.toMap(n.screenStart,o))),null==r)return null;const t=a(e.toMap(n.screenEnd,o));return null!=t?{...n,mapStart:r,mapEnd:t}:null}}function R(e,n){const r=e.map((e=>S(e,n))).filter(t.isSome);return e=>{const n=e.mapEnd.x-e.mapStart.x,t=e.mapEnd.y-e.mapStart.y,a=e.mapEnd.z-e.mapStart.z;return r.forEach((n=>n(e))),{...e,translationX:n,translationY:t,translationZ:a}}}function z(e,n){const t=new Map;for(const r of n)t.set(r,a.clone(e[r]));return n=>(t.forEach(((n,t)=>{e[t]=n})),n)}function w(e){return null!=e.geometry&&"mesh"===e.geometry.type?D(e,e.geometry):z(e,["geometry"])}function D(e,n){const{vertexSpace:t}=n;if(t.isGeoreferenced){const t=n.vertexAttributes.clonePositional();return r=>(n.vertexAttributes=t,e.notifyGeometryChanged(),r)}const r=c.clone(t.origin),a=n.transform?.clone();return t=>(n.transform=a,n.vertexSpace.origin=r,e.notifyMeshTransformChanged(),t)}function G(e){const n=e.map((e=>w(e))).filter((e=>null!=e));return e=>(n.forEach((n=>n(e))),e)}function A(){let e=0,n=0,t=0;return r=>{"start"===r.action&&(e=r.mapStart.x,n=r.mapStart.y,t=r.mapStart.z);const a=r.mapEnd.x-e,o=r.mapEnd.y-n,l=r.mapEnd.z-t;return e=r.mapEnd.x,n=r.mapEnd.y,t=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:l,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function j(){let e=0,n=0;return t=>{"start"===t.action&&(e=t.screenStart.x,n=t.screenStart.y);const r=t.screenEnd.x-e,a=t.screenEnd.y-n;return e=t.screenEnd.x,n=t.screenEnd.y,{...t,screenDeltaX:r,screenDeltaY:a}}}function F(e,n){let t=null,r=0,a=0;return c=>{if("start"===c.action&&(t=e.toScreen?.(n),null!=t&&(t.x<0||t.x>e.width||t.y<0||t.y>e.height?t=null:(r=c.screenStart.x-t.x,a=c.screenStart.y-t.y))),null==t)return null;const i=o.clamp(c.screenEnd.x-r,0,e.width),s=o.clamp(c.screenEnd.y-a,0,e.height),u=l.createScreenPoint(i,s);return c.screenStart=t,c.screenEnd=u,c}}const T=()=>{};class U{constructor(){this.execute=T}next(e,n=new U){return null!=e&&(this.execute=t=>{const r=e(t);null!=r&&n.execute(r)}),n}}function Z(e,n,t=[]){if("2d"===e.type)return e=>e;let r=null;return a=>{"start"===a.action&&(r=e.toMap(a.screenStart,{exclude:t}),null!=r&&(r.z=p.getZForElevationMode(r,e,n)));const o=e.toMap(a.screenEnd,{exclude:t});null!=o&&(o.z=p.getZForElevationMode(o,e,n));const l=null!=r&&null!=o?{sceneStart:r,sceneEnd:o}:null;return{...a,scenePoints:l}}}function b(e,n,t){const r=n.elevationProvider.getElevation(e.x,e.y,e.z??0,e.spatialReference,"scene")??0,a=s.clonePoint(e);return a.z=r,a.hasZ=!0,a.z=p.getZForElevationMode(a,n,t),a}function q(e,n){if("2d"===e.type)return e=>e;let t=null;return r=>{"start"===r.action&&(t=b(r.mapStart,e,n));const a=b(r.mapEnd,e,n),o=null!=t&&null!=a?{sceneStart:t,sceneEnd:a}:null;return{...r,scenePoints:o}}}e.EventPipeline=U,e.addMapDelta=A,e.addScreenDelta=j,e.constrainToMapAxis=x,e.createDragEventPipelineCallback=y,e.createManipulatorDragEventPipeline=g,e.dragAtLocation=F,e.dragGraphic=S,e.dragGraphicMany=R,e.resetGraphic=w,e.resetGraphicMany=G,e.resetProperties=z,e.sceneSnappingAtLocation=Z,e.sceneSnappingAtProjectedLocation=q,e.screenToMap=P,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
