/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/projection","../../../../../geometry/spatialReferenceEllipsoidUtils","../../../../../geometry/projection/projectVectorToVector","../../../../../geometry/support/vectorStacks","../../../support/mathUtils"],(function(e,t,r,s,c,n,o,i){"use strict";class a{constructor(e=r.create(),t=r.create()){this.startRenderSpace=e,this.endRenderSpace=t,this.type="euclidean"}eval(e,r,s){return t.lerp(r,this.startRenderSpace,this.endRenderSpace,e),s&&(t.subtract(s,this.endRenderSpace,this.startRenderSpace),t.normalize(s,s)),r}createRenderGeometry(e,r){const s=[],c=[],n=(r,n)=>{const o=d;t.subtract(o,r,e),s.push([o[0],o[1],o[2]]),c.push([n[0],n[1],n[2]])},i=r.worldUpAtPosition(this.eval(.5,h),o.sv3d.get());return n(this.startRenderSpace,i),n(this.endRenderSpace,i),{points:s,normals:c}}static fromPositionAndVector(e,s,c=1){return t.scale(h,s,c),t.add(h,e,h),new a(r.clone(e),r.clone(h))}}class p{_projectIn(e,r){this._project?n.projectVectorToVector(e,this.renderSpatialReference,r,this._pcpf):t.copy(r,e)}constructor(e,t,n){this.startRenderSpace=e,this.endRenderSpace=t,this.renderSpatialReference=n,this.type="geodesic",this._start=r.create(),this._end=r.create(),this._pcpf=c.getSphericalPCPF(n),this._project=s.canProjectWithoutEngine(n,this._pcpf),this._projectIn(e,this._start),this._projectIn(t,this._end)}eval(e,r,s){if(this._project)if(s){const c=d;i.slerpTangent(this._start,this._end,e,r,c),t.add(l,r,c),n.projectVectorToVector(r,this._pcpf,r,this.renderSpatialReference),n.projectVectorToVector(l,this._pcpf,l,this.renderSpatialReference),t.subtract(s,l,r),t.normalize(s,s)}else i.slerp(this._start,this._end,e,r),n.projectVectorToVector(r,this._pcpf,r,this.renderSpatialReference);else t.lerp(r,this._start,this._end,e),s&&(t.subtract(s,this._end,this._start),t.normalize(s,s));return r}createRenderGeometry(e,r){const s=[],c=[],n=(r,n)=>{const o=l;t.subtract(o,r,e),s.push([o[0],o[1],o[2]]),c.push([n[0],n[1],n[2]])},o=128+1&-2;for(let t=0;t<o;++t){const e=t/(o-1),s=h,c=d;this.eval(e,s),r.worldUpAtPosition(s,c),n(s,c)}return{points:s,normals:c}}}const h=r.create(),d=r.create(),l=r.create();e.EuclideanSegment=a,e.GeodesicSegment=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
