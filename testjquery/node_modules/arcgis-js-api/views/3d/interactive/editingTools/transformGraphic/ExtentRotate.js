/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../chunks/mat4","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/boundedPlane","../../../../../geometry/support/plane","../../../../../geometry/support/vectorStacks","../../../analysis/images/Factory","../../../analysis/Slice/RotateManipulator","../../../analysis/Slice/sliceToolUtils","../../manipulatorUtils","../dragEventPipeline3D","../ManipulatorType","../../../support/geometryUtils/ray","../../../../interactive/dragEventPipeline","../../../../interactive/editGeometry/interfaces","../../../../interactive/editGeometry/operations/UpdateVertices","../../../../interactive/editGeometry/support/editPlaneUtils","../../../../interactive/tooltip/ExtentTooltipInfos"],(function(t,e,a,o,r,n,i,s,l,p,c,u,d,h,g,m,_,y,v,T){"use strict";class A{constructor(t,e,a){this._tool=t,this._editGeometryOperations=e,this._bounds=a,this._rotateTooltipInfo=null,this._startAngle=0,this._endAngle=0;const o=this._tool,r=o.view,n=!r._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;this.rotateManipulator=new p.RotateManipulator(r,((t,e)=>l.getRotateHeadingTexture(r.textures,{accentColor:t,contrastColor:e,preMultiplyAlpha:n}))),o.addHandles([this.rotateManipulator.events.on("grab-changed",(t=>this._onRotateGrab(t))),this._createRotateDragPipeline(this.rotateManipulator)]),o.manipulators.add(this.rotateManipulator),o.addHandles([o.on("graphic-rotate-start",(t=>{this._startAngle=t.angle})),o.on("graphic-rotate",(t=>{this._endAngle=t.angle})),o.on("graphic-rotate-stop",(()=>{this._startAngle=0,this._endAngle=0}))])}destroy(){this._tool.manipulators.remove(this.rotateManipulator),this.rotateManipulator.destroy()}forEachManipulator(t){t(this.rotateManipulator,h.ManipulatorType.ROTATE)}updateManipulators(t,e){const r=this._bounds.mapBounds.plane[2]<0?Math.PI:0,n=a.rotateX(s.sm4d.get(),t,r);n[12]=0,n[13]=0,n[14]=0,this.rotateManipulator.modelTransform=n,this.rotateManipulator.renderLocation=o.add(s.sv3d.get(),e.origin,e.basis1)}getUpdatedTooltipInfo(){return this.rotateManipulator.focused?this._computeRotateTooltipInfo():null}_computeRotateTooltipInfo(){const t=this._tool.tooltipOptions,e=this._rotateTooltipInfo??(this._rotateTooltipInfo=new T.ExtentRotateTooltipInfo({tooltipOptions:t}));return e.angle=this._startAngle-this._endAngle,e}_onRotateGrab({action:t,screenPoint:e}){const a=this._tool,o=this._bounds;if("start"!==t||!e)return;const r=c.createRotatePlane(o.displayBounds,a.view.renderCoordsHelper,c.RotationAxis.HEADING,i.create()),n=g.fromScreenNormalized(a.view.state.camera,e);i.intersectRay(r,n,s.sv3d.get())&&(o.backupMapBounds(),a.inputState={type:"rotate",rotatePlane:r})}_createRotateDragPipeline(t){const a=this._tool,o=a.graphic;return m.createManipulatorDragEventPipeline(t,((t,r,n)=>{const i=a.inputState;null!=i&&(r.next((t=>("start"===t.action&&a.emit("graphic-rotate-start",{graphic:o,angle:0}),t))).next(d.screenToRenderPlane(a.view,i.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(i)).next(this._rotateDragUpdateGeometry()).next((t=>{const r={graphic:o,angle:e.rad2deg(t.rotateAngle)};switch(t.action){case"start":case"update":a.emit("graphic-rotate",r);break;case"end":a.inputState=null,a.emit("graphic-rotate-stop",r)}return t})),n.next((()=>{null!=a.inputState&&a.emit("graphic-rotate-stop",{graphic:o,angle:0}),a.cancel()})))}))}_rotateDragRenderPlaneToRotate(t){return e=>{const a=i.normal(t.rotatePlane),o=u.calculateInputRotationTransform(e.renderStart,e.renderEnd,this._bounds.displayBounds.origin,a);return{...e,rotateAxis:a,rotateAngle:o}}}_rotateDragUpdateGeometry(){const t=this._tool,e=this._bounds;return a=>{const i=o.copy(r.create(),e.mapBoundsStart.origin),s=[];for(const t of this._editGeometryOperations.data.components)s.push(...t.vertices);const l="start"===a.action?_.AccumulationBehaviour.NEW_STEP:_.AccumulationBehaviour.ACCUMULATE_STEPS,p=this._editGeometryOperations.rotateVertices(s,i,a.rotateAngle,l,y.AccumulationType.REPLACE);return n.copy(e.mapBoundsStart,e.mapBounds),v.apply(p,e.mapBounds),t.graphic.geometry=this._editGeometryOperations.data.geometry,a}}}t.ExtentRotate=A,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
