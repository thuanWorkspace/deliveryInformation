/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./ITile","./LayerClass","./PatchGeometry","./terrainUtils","./TextureFader","./Tile","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject","../../webgl/enums"],(function(e,t,r,i,s,n,a,o,l,h,d,g,c,u,m,y,p,f,_,x,A,b,v){"use strict";class C{constructor(){this.geometry=new u.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._textureRef=new y.TextureFader((()=>this.tile.surface.textureFadeDuration)),this.overlay=new f,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}get tile(){return this._tile}init(e){this.clear(),this._tile=e;const t=this.geometry;t.indices=null,t.vertexAttributes=null,a.empty(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new d.GeometryState,this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),m.enableTerrainInternalChecks&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)m.internalAssert(this.geometry.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,n=m.neighborEdgeIndices[e];if(!t)return m.internalAssert(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(n)),i;if(t.isLoaded){const r=t,n=r.renderData.geometryState,a=s-r.level;if(m.internalAssert(a>=0),0===a){const e=n.numVerticesPerSide-1;return Math.max(e,i)}const o=2**a,l=n.neighborData.edgeResolutions[(e+2)%4]/o;return Math.max(1,l)}m.internalAssert(!t.isLeaf);let a=i;return t.forAllSubtreeOnSide(m.oppositeEdge(n),(e=>e===r||(e.isLoaded?(a=Math.max(a,2**(e.level-s)),!0):(m.internalAssert(!e.isLeaf),!1)))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState.neighborData,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let o=0;o<4;++o){const a=e.findNeighborTile(m.neighborEdgeIndices[o],i),l=R(e,a),h=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[o],g=l!==R(e,d),c=n[o]!==h;s[o]=a,(g||c)&&(n[o]=h,this._markEdgeDirty(o));const u=t.edgeResolutions[o],y=this._calculateEdgeResolution(o,a);m.internalAssert(r.isPowerOfTwo(y)),m.internalAssert(y>=1),t.edgeResolutions[o]=y,u!==y&&this._markEdgeResolutionDirty(o)}const a=t.cornerPeerNeighbors;for(let r=0;r<4;++r){const n=e.findNeighborTile(m.neighborCornerIndices[r],i);a[r]=n;const o=R(e,s[r]),l=R(e,s[(r+1)%4]),h=R(e,n);P[r]=h,P[(r+1)%4]=l,P[(r+2)%4]=e,P[(r+3)%4]=o,m.internalAssert(P.some((t=>t?.isLoaded||t===e)));const d=P.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);P.forEach(((e,t)=>{e&&e?.level>d&&(P[t]=null)})),m.internalAssert(P.some((t=>t?.isLoaded||t===e)));const g=t.cornerNeighborData[r].cornerTiles,c=t.cornerNeighborData[r].cornerTileSamplerVersions;for(let e=0;e<4;++e){const t=P[e],i=t?.renderData.geometryState.samplerDataVersion??-1,s=g[e]!==t,n=!s&&c[e]!==i;(s||n)&&(g[e]=t,c[e]=i,this._markCornerDirty(r))}m.internalAssert(g.some((t=>t?.isLoaded||t===e)))}m.enableTerrainInternalChecks&&m.internalAssert(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let r=0;r<4;++r)P[r]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;m.enableTerrainInternalChecks&&m.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometry.vertexAttributes,s=!r||!i||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,n=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),a=!n&&0!==this._dirtyCorners;s?(this.releaseGeometry(),this._createGeometry(e)):n||a?t.updateEdgeElevations():a?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=i.disposeMaybe(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r){const i=t?v.PixelFormat.RGBA:v.PixelFormat.RGB;return null==this._texture||this._texture.descriptor.width===e&&this._texture.descriptor.pixelFormat===i||this.releaseTexture(),null==this._texture&&(this._texture=r(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_markCornerDirty(e){const t=1<<e;this._dirtyCorners|=t}_markEdgeDirty(e){const t=1<<e;this._dirtyEdges|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15}updateGeometryState(){const e=this._getElevationInfo(),r=this.tile,i=e.samplerData?r.getElevationVerticesPerSide(e.maxTileLevel):r.getDefaultVerticesPerSide(),s=Math.max(i,5);let n=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(n=null);const a=this.geometryState;let o=!1;a.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,a.numVerticesPerSide=s,a.samplerDataVersion++,o=!0),e.changed&&(this._samplerDataChanged=!0,a.samplerData=e.samplerData,a.samplerDataVersion++,o=!0),t.equals(a.clippingArea,n)||(this._clippingAreaChanged=!0,a.clippingArea=n,o=!0);const l=r.surface.wireframe;return a.wireframe!==l&&(this._wireframeChanged=!0,a.wireframe=l,o=!0),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=o),o&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new x.VertexArrayObject(e,A.terrainVertexAttributeLocations,{geometry:h.glLayout(t.layout)},{geometry:b.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)},b.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=y.ActivationTime.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[c.LayerClass.ELEVATION],r=t.length,i=new Array(r);let s=0,n=0,a=!1;for(let h=0;h<r;h++){const r=t[h];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,o=t.layerInfo[c.LayerClass.ELEVATION][h].data,l=o&&o.samplerData;e&&e[s]===l||(a=!0),i[s++]=l,n=Math.max(n,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(h,c.LayerClass.ELEVATION);if(_.fallsWithinLayer(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,n=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const o=s>0,l=o?i:null;return o&&(i.length=s),{changed:a,samplerData:l,maxTileLevel:n}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!m.enableTerrainInternalChecks)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void m.internalAssert(e?.isLoaded);const t=e.surface.extent;if(null!=t&&!e.intersectsExtent(t))return;const i=m.neighborEdgeIndices.map(((r,i)=>null!=t&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0)),a=e.level;m.internalAssert(0===this._dirtyCorners),m.internalAssert(0===this._dirtyEdges),m.internalAssert(0===this._dirtyEdgeResolutions),m.internalAssert(!this._numVerticesPerSideChanged),m.internalAssert(!this._samplerDataChanged),m.internalAssert(!this._clippingAreaChanged),m.internalAssert(!this._wireframeChanged);const h=m.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),d=this.geometryState.neighborData;for(let r=0;r<4;++r){const t=d.cornerPeerNeighbors[r],i=h[r];m.internalAssert(i===t,`Tile[${e.lij}].corner[${r}] out of date: cur=[${t?.lij}] exp=[${i?.lij}]`)}m.neighborEdgeIndices.forEach(((t,h)=>{if(i[h])return;const d=e.findNeighborTile(t,(e=>(e.level===a||e?.isLoaded)&&e?.intersectsClippingArea));if(!d){const r=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void m.internalAssert(!r)}m.internalAssert(d.isLoaded||d.level===e.level),m.internalAssert(d===this.geometryState.neighborData.edgePeerNeighbors[h]);const c=a-d.level;if(!d.isLoaded)return m.internalAssert(!d.isLeaf),void m.internalAssert(0===c);const u=d.renderData;m.internalAssert(p.isEdgeNeighbor(e,d,t)),m.internalAssert(c>=0);const y=2**c;if(c<0)return void m.internalAssert(!1);const f=e.renderData,_=f.geometry,x=_.outerEdges[h],A=_.numVerticesPerSide-1,b=u.geometry;if(!b)return void m.internalAssert(!1);const v=this.geometryState.neighborData.edgePeerNeighbors[h];if(v?.isLoaded){const e=v.renderData;m.internalAssert(v==v),m.internalAssert(f.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===e.geometryState.samplerDataVersion),m.internalAssert(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===e.geometryState.samplerDataVersion)}const C=(h+2)%4,P=b.outerEdges[C],R=x.count-1,w=P.count-1;m.internalAssert(R*y===w,`Tile[${e.lij}]:e${h},res=${R} edgeRes mismatch with Neighbor[${d.lij}]:e${C},res=${w} (expected:${R*y})`);const N=e.extent,I=t===g.NeighborIndex.NORTH||t===g.NeighborIndex.SOUTH,G=P.count-1,O=G/2**c,j=x.count-1;if(O<1)return void m.internalAssert(1===j);m.internalAssert(O===j),m.internalAssert(r.isPowerOfTwo(O));const M=b.numVerticesPerSide-1;m.internalAssert(c>0||O===Math.max(M,A));const k=e.getNeighborEdgeStartVertexIndex(h,d);m.internalAssert(0<=k&&k<y);const U=k*O;m.internalAssert(0<=U&&U<=G-O);let F=0,B=U;x.getVertexPos(D,0),x.getVertexPos(S,x.count-1);const X=s.distance(D,S),W=Math.max(L,1e-4*X);for(let r=0;r<=O;++r){x.getVertexPos(D,F),P.getVertexPos(S,B);const i=r/O,a=I?N[0]+i*(N[2]-N[0]):t===g.NeighborIndex.WEST?N[0]:N[2],c=I?t===g.NeighborIndex.SOUTH?N[1]:N[3]:N[1]+i*(N[3]-N[1]),y=e.surface.extent;if(null==y||o.containsXY(y,a,c)){const t=s.dist(D,S),r=s.len(D)-l.earth.radius,i=s.len(S)-l.earth.radius,o=t<W;if(!o){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${h}[${F}/${x.count}] and [${d.lij}].edge${C}[${B}/${P.count}]`),null!=y&&console.warn("  surface extent= ",y," x,y=",a,",",c);const l=n.create();s.subtract(l,f.localOrigin,u.localOrigin),s.len(l)>0&&console.warn(`   localOrigins: ${f.localOrigin} vs ${u.localOrigin} d=${s.len(l)} [${l}]`);(()=>{const t=n.clone(D),r=n.clone(S);e.updateEdgeElevations(),d.updateEdgeElevations(),x.getVertexPos(D,F),P.getVertexPos(S,B);const i=n.create();s.sub(i,D,t),s.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${D} d=${s.len(i)} [${i}]`),s.sub(i,S,r),s.len(i)>0&&console.warn(`  XXX Neighbor[${d.lij}] edge out of date: ${r} vs ${S} d=${s.len(i)} [${i}]`)})(),m.internalAssert(o,`Mismatch in tile [${e.lij}].edge[${h}][${F}/${x.count}] vs neighbor [${d.lij}].edge[${C}][${B}/${P.count}] ${m.v32s(D)} vs ${m.v32s(S)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}x.getNormal(E,F),P.getNormal($,B),s.normalize(T,E),s.normalize(V,$);const g=s.dot(T,V),p=1-g<.01||!1||e===d;if(!p){const t=n.create();s.sub(t,E,$);const r=()=>`Mismatch in tile edge normal ${m.lij2s(e.lij)} (${F}/${x.count-1}) edge ${h} vs neighbor ${m.lij2s(d.lij)}  (${B}/${P.count-1}) nedge ${C} :${m.v32s(E)} vs ${m.v32s($)}  dot = ${g} : ${m.v32s(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),d.updateEdgeElevations();const t=n.create(),r=n.create();x.getNormal(t,F),P.getNormal(r,B),s.equals(E,t)||console.warn("Missing update in tile normal: ",m.v32s(E)," => ",m.v32s(t)),s.equals($,r)||console.warn("Missing update in neighbor normal: ",m.v32s($)," => ",m.v32s(r))}m.internalAssert(p,r())}}F+=1,B+=1}}))}}const D=n.create(),S=n.create(),E=n.create(),$=n.create(),T=n.create(),V=n.create(),L=1,P=[null,null,null,null];function R(e,t){return t?.isLoaded||t===e?t:null}Object.defineProperty(e,"ActivationTime",{enumerable:!0,get:()=>y.ActivationTime}),e.PatchRenderData=C,e.neighborTileIfLoadedOrSelf=R,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
