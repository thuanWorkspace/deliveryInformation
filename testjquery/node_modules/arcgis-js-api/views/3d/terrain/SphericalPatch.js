/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection/lonLatToSphericalPCPF","../../../geometry/support/DoubleArray","../../../geometry/support/frustum","../../../chunks/sphere","./interfaces","./ITile","./PatchGeometryFactory","./terrainUtils","./Tile","./tileUtils"],(function(e,t,i,s,n,o,r,a,l,c,h,u,d,p){"use strict";class f extends d.Tile{constructor(e,t,i,s,n){super(),this._convexHull=new Array(24),this._boundingSphere=a.create(),this._baseUsedMemory=1816,this.init(e,t,i,s,n)}init(e,s,o,r,a){super.init(e,s,o,r,a);const l=this.ellipsoid.radius,c=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],d=this.extentInRadians[3],p=t.lerp(h,d,.5),f=t.lerp(c,u,.5),m=0===e?0:Math.min(Math.abs(h),Math.abs(d));this._edgeLen=(u-c)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),n.lonLatToSphericalPCPF(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),i.normalize(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])i.set(e[d.CenterPosition.MIDDLE],0,0,0),i.set(e[d.CenterPosition.TOP],0,0,0),i.set(e[d.CenterPosition.BOTTOM],0,0,0),e[d.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=e[d.CenterPosition.MIDDLE],i=this.convexHull;let s=0;for(let e=0;e<8;++e)s=Math.max(s,g(t,i,3*e));e[d.CenterPosition.MIDDLE][3]=Math.sqrt(s)}}_calculateFrustumVisibilityStatus(e){if(!r.intersectsSphere(e,this._boundingSphere))return c.TileFrustumVisibility.OUTSIDE;if(this.lij[0]<10)return c.TileFrustumVisibility.INTERSECTS;const t=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let n=0;n<r.NumPlanes;n++){const o=n===r.PlaneIndex.NEAR,a=e[n],l=a[0],h=a[1],u=a[2],d=a[3]-(o?i:0);let p=!1;for(let e=0;e<8;++e){const i=3*e;if(l*t[i]+h*t[i+1]+u*t[i+2]+d<0){if(p=!0,!s)break}else s=!1}if(!p)return c.TileFrustumVisibility.OUTSIDE}return s?c.TileFrustumVisibility.INSIDE:c.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){h.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),u.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const e=this._boundingSphere,t=e,s=this.elevationBounds,n=this.ellipsoid.radius,o=s[1];if(0===this.level)i.set(t,0,0,0),e[3]=n+o;else{const o=this.extentInRadians,r=.5*(o[0]+o[2]),a=o[1],l=o[3];$(_,r,a,n),$(v,r,l,n),i.add(t,_,v);const c=n+.5*(s[0]+s[1]);i.scale(t,t,c/i.len(t));const h=this.convexHull;let u=0;const d=(e,t)=>{const i=e[0]-h[3*t],s=e[1]-h[3*t+1],n=e[2]-h[3*t+2];return Math.sqrt(i*i+s*s+n*n)};for(let e=0;e<8;++e){const i=d(t,e);u=Math.max(u,i)}const p=u;e[3]=p+2}}_updateConvexHull(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const n=this.elevationBounds,o=this._getPatchType(),r=this.surface.isWebMercator,a=r&&o===l.PatchType.HAS_NORTH_POLE,c=r&&o===l.PatchType.HAS_SOUTH_POLE,h=c||a,d=Math.PI/2,p=e[0],f=e[2],m=c?-d:e[1],g=a?d:e[3],b=.5*(p+f),_=n[0],v=t+(h?Math.min(0,_-1):_),x=(e,t,i)=>$(e,t,i,v),S=s.create(),M=s.create(),P=s.create(),y=s.create();x(S,p,m),x(M,p,g),x(P,f,g),x(y,f,m);const E=(e,t)=>{for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]};E(S,0),E(M,1),E(P,2),E(y,3);const A=n[1],C=t+(h?Math.max(0,A+1):A),I=s.create(),L=s.create(),D=s.create();$(L,b,g,v),$(D,b,m,v),i.add(I,L,D),i.normalize(I,I);const H=s.create(),j=s.create(),R=(e,t)=>{i.sub(j,e,t),i.normalize(j,j);const s=-i.dot(e,H)/i.dot(j,H);u.internalAssert(s>=0),i.scale(j,j,s),i.add(e,e,j)};if(2**this.lij[0]>2*this.lij[1]){const e=D,t=s.create();i.cross(t,T,e),i.normalize(t,t),i.cross(H,e,t),i.normalize(H,H),u.internalAssert(u.almostEquals(i.dot(H,e)/i.len(e),0)),R(S,M),R(y,P),E(S,0),E(y,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=L,t=s.create();i.cross(t,T,e),i.normalize(t,t),i.cross(H,t,e),i.normalize(H,H),R(M,S),R(P,y),E(M,1),E(P,2)}const B=(e,t)=>{const s=C/i.dot(t,I);for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]*s};B(4,S),B(5,M),B(6,P),B(7,y)}_getPatchType(){const e=this.lij[1],t=0===e,i=e===(1<<this.level)-1;return t?i?l.PatchType.HAS_BOTH_POLES:l.PatchType.HAS_NORTH_POLE:i?l.PatchType.HAS_SOUTH_POLE:l.PatchType.REGULAR}intersectsRay(e,t,i,s){const n=this._boundingSphere,o=n[3]+i,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],a=n[0]-e[0],l=n[1]-e[1],c=n[2]-e[2],h=(a*t[0]+l*t[1]+c*t[2])/r,u=t[0]*h-a,d=t[1]*h-l,p=t[2]*h-c;return u*u+d*d+p*p<o*o}getDefaultVerticesPerSide(){return this.level<m.length?m[this.level]+1:2}updateCornerElevations(){h.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){h.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!u.enableTerrainInternalChecks)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],n=e,r=s.create(),a=this.ellipsoid.radius,l=this.elevationBounds;l[1],l[0];const c=a+l[0],h=1,f=0,m=this._center[d.CenterPosition.MIDDLE][3],g=this.convexHull,T=(e,t)=>{for(let i=0;i<3;++i)e[i]=g[3*t+i]};{const e=s.create(),t=s.create(),n=s.create(),o=s.create(),r=s.create(),a=(s,a,l,c)=>{T(t,s),T(n,a),T(o,l),i.sub(t,t,n),i.sub(o,o,n),i.cross(e,t,o),i.normalize(e,e);const h=i.dot(e,n);T(r,c);const d=i.dot(e,r),p=Math.abs(d-h);u.internalAssert(u.almostEquals(p,0),`Non coplanar ${s},${a},${l},${c} diff = ${p}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const _=o.newDoubleArray(24),v=(e,t,i)=>{const s=4*e;for(let n=0;n<3;++n)_[s+n]=t[n];_[s+3]=i},x=s.create(),S=s.create(),M=s.create(),P=s.create(),y=(e,t,s,n)=>{T(x,t),T(S,s),T(M,n),i.sub(x,x,S),i.normalize(x,x),i.sub(M,M,S),i.normalize(M,M),i.cross(P,x,M),i.normalize(P,P);const o=i.dot(P,S);v(e,P,o)};y(0,0,1,2),y(1,1,0,4),y(2,1,5,2),y(3,3,2,6),y(4,4,0,3),y(5,4,6,5);const E=1,A=(e,t,i,s)=>{const n=4*e;return _[n]*t+_[n+1]*i+_[n+2]*s-_[n+3]},C=(e,t,i,s)=>A(e,t,i,s)>=-E,I=(e,t)=>C(e,t[0],t[1],t[2]),L=2**this.lij[0]>2*this.lij[1],D=(e,i,s)=>Math.sqrt(b(e,i,s,n[0],n[1],n[2]))<t,H=e=>D(e[0],e[1],e[2]),j=(e,t)=>D(e[t],e[t+1],e[t+2]),R=this.extentInRadians,B=.5*(R[0]+R[2]),O=R[1],V=R[3],F=s.create(),z=s.create();$(F,B,V,c),$(z,B,O,c);const k=L?"Upper":"Lower";let N=!0;for(let i=0;i<6;++i){for(let e=0;e<8;++e){const t=3*e,s=C(i,g[t],g[t+1],g[t+2]);N&&(N=s),u.internalAssert(s,`Tile[${this.lij}] Convex hull point ${e} outside of plane ${i}`)}u.internalAssert(I(i,z),`Tile[${this.lij}] (${k}) bottom mid outside of plane ${i}`),u.internalAssert(I(i,F),`Tile[${this.lij}] (${k}) top mid outside of plane ${i}`)}u.internalAssert(N,"Not all convex hull points are inside  convex hull polyhedron"),u.internalAssert(H(z),`Tile[${this.lij}] (${k}) bottom mid outside of bounding sphere`),u.internalAssert(H(F),`Tile[${this.lij}] (${k}) top mid outside of bounding sphere`);for(let i=0;i<8;++i){const e=j(g,3*i);u.internalAssert(e,`Tile[${this.lij}] Convex hull point ${i} outside of bounding sphere`)}for(let i=0;i<6;++i)for(let e=0;e<8;++e){const t=3*e;C(i,g[t],g[t+1],g[t+2])||console.error(`Tile[${this.lij}] Convex hull point ${e} outside of plane ${i}`)}const U=this.extentInRadians,q=Math.max(U[2]-U[0],U[3]-U[1]),w=Math.round(q*a),G=this.renderData;if(!G)return;const{geometry:W,localOrigin:J}=G,K=W.vertexAttributes?.position;if(!K)return;const Q=K.count,X=s.create(),Y=W.numVerticesPerSide-2,Z=Y*Y,ee=G.geometryState.neighborData,te=ee.edgeResolutions.reduce(((e,t)=>e+t+1),0);for(let s=0;s<Q;++s){const e=s<Z,o=!e&&s<Z+te;let c=!1,u=-1;if(o){let e=Z;for(let t=0;t<4;++t){const i=ee.edgeResolutions[t];if(s===e||s===e+i-1){c=!0;break}if(e+=i,s<e){u=t;break}}}const d=o?ee.edgePeerNeighbors[u]:null,g=o&&d&&p.compareTilesByLij(this,d)>0;K.getVec(s,r),i.add(X,r,J);const b=i.len(X)-a;let $=0,T=!1;const _=l[0]-b,v=b-l[1],x=_>h,S=v>h,M=x||S,P=()=>{const t=e?"internal":o&&!c?"edge":c?"corner":"pole";return`Tile[${this.lij}].vertex[${s}]:${t}`+(x?"(below)":S?"(above)":"")+(g?"(Neighbor)":"")},y=i.dist(X,n);if(y>=t+f){const e=y-t;M||(console.error(`${P()} is out of the bounding sphere by ${e.toFixed(0)} / ${t.toFixed(0)}[tol=${f}] h=${b.toFixed(0)} / [${l[0].toFixed(0)}..${l[1].toFixed(0)}] (${(e/t).toFixed(0)})`),T=!0)}for(let i=0;i<6;++i)if(!C(i,X[0],X[1],X[2])){const e=A(i,X[0],X[1],X[2]),n=s%Y,o=(s-n)/Y;0===i&&_||5===i&&v||(console.error(`${P()} (${n},${o})|${Y}] is out of the bounding trapezoid plane ${i} h=${Math.round(b)} / [${Math.round(l[0])}..${Math.round(l[1])}] dist=${Math.round(e)} radii = ${Math.round(t)}/${Math.round(m)}} : maxL = ${w}`),++$)}if(T||$>0)break}}get convexHull(){return this._convexHull}}const m=[128,64,64,32,16,8,8,4];function g(e,t,i){return b(e[0],e[1],e[2],t[i],t[i+1],t[i+2])}function b(e,t,i,s,n,o){const r=s-e,a=n-t,l=o-i;return r*r+a*a+l*l}const $=(e,t,i,s)=>{const n=Math.cos(t),o=Math.sin(t),r=Math.cos(i),a=Math.sin(i);e[0]=s*r*n,e[1]=s*r*o,e[2]=s*a},T=[0,0,1],_=s.create(),v=s.create();e.SphericalPatch=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
