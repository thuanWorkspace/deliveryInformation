/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../chunks/vec4","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./interfaces","./ITile","./PatchGeometry","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/Normals"],(function(e,t,n,o,s,r,a,i,l,c,u,d,f,m,p){"use strict";const g=65536;function h(e,t){const n=e.tile,{extent:s,extentInRadians:r,surface:i}=n,c=e.localOrigin,u=e.geometryState,f=i.isWebMercator,m=u.numVerticesPerSide,g=m-1,h=(m-2)**2,M=f&&(t===a.PatchType.HAS_SOUTH_POLE||t===a.PatchType.HAS_BOTH_POLES),y=f&&(t===a.PatchType.HAS_NORTH_POLE||t===a.PatchType.HAS_BOTH_POLES),B=6,b=((M?1:0)+(y?1:0))*B*(g+1),S=u.neighborData,E=S.edgeResolutions.reduce(((e,t)=>e+t+1),0),L=h+b+E,P=i.renderer.tileGeometryCache.acquire(L),I=e.geometry;I.numVerticesPerSide=u.numVerticesPerSide,I.vertexAttributes=P;const R=I.boundingBox;o.empty(R);const O=T(e);G.update(g,r,O),x(e),k(e,h),v(e);const V=[];if((()=>{let e=h+E;const t=c[0],o=c[1],r=c[2],a=n.ellipsoid.radius,i=s[1],u=s[3],d=(n,s)=>{const c=s*m,d=-t,f=-o,h=n*a-r;l.minMaxBoundingBox(d,f,h,R),V.push({connectedRowOffset:c,connectedOuterEdgeOffset:1===n?0:2,rowOffset:e,latitudeResolution:B});const x=A(-1===n?i:u,a),M=n*Math.PI/2-x,y=.99*(1===n?1:-1),v=a+0,{position:b,uv0:S}=P,{typedBuffer:E,typedBufferStride:T}=P.normalCompressed;for(let a=1;a<=B;++a){const n=x+M*(a/B),s=Math.cos(n),i=Math.sin(n);for(let a=0;a<=g;a++){const n=a/g,c=G.sinLonLUT[a],u=G.cosLonLUT[a]*s,d=c*s,f=i,m=u*v-t,h=d*v-o,x=f*v-r;l.minMaxBoundingBox(m,h,x,R),b.setValues(e,m,h,x),l.encodeUVInBuffer(S,e,n,y),p.compressNormal(E,e,u,d,f,T),++e}}};M&&d(-1,0),y&&d(1,g)})(),N(I,u.numVerticesPerSide,V,[0,m-1],[0,m-1],u.wireframe),e.intersectionData=null,d.enableTerrainInternalChecks)for(let o=0;o<4;++o)d.internalAssert(I.outerEdges[o].count===S.edgeResolutions[o]+1)}function x(e){const t=e.tile;if(!t.intersectsClippingArea)return;const n=e.geometryState,o=n.numVerticesPerSide,s=o-2,a=o-1,i=e.geometry,c=i.vertexAttributes,u=c.position,d=c.uv0,{typedBuffer:f,typedBufferStride:m}=c.normalCompressed,g=t.extent,h=g[0],x=g[2],M=g[1],y=g[3],v=t.ellipsoid.radius,B=n.samplerData,b=e.localOrigin,A=b[0],S=b[1],E=b[2],T=u.typedBuffer,L=u.typedBufferStride,P=1/a,I=i.boundingBox;let R=0;if(1<=s){const e=P,t=M*(1-e)+y*e,n=G.sinLatLUT[1],o=G.cosLatLUT[1];for(let a=1;a<=s;a++){const s=a*P,i=h*(1-s)+x*s,c=G.sinLonLUT[a],u=G.cosLonLUT[a],f=v+r.sampleElevation(i,t,B),m=f*u*o-A,p=f*c*o-S,g=f*n-E;l.minMaxBoundingBox(m,p,g,I);const M=(a-1)*L;T[M]=m,T[M+1]=p,T[M+2]=g,l.encodeUVInBuffer(d,a-1,s,e)}}for(let O=1;O<=s;O++){const e=O*P,t=M*(1-e)+y*e,n=G.sinLatLUT[O],o=G.cosLatLUT[O],i=O+1,c=i*P,u=M*(1-c)+y*c,g=G.sinLatLUT[i],b=G.cosLatLUT[i],V=G.sinLonLUT[0],C=G.cosLonLUT[0],U=v+r.sampleElevation(h,t,B);let D=C*o*U-A,w=V*o*U-S,N=n*U-E;const k=R*L;let q=T[k],H=T[k+1],j=T[k+2];for(let y=1;y<=s;y++){const e=y*P,i=h*(1-e)+x*e,V=G.sinLonLUT[y],C=G.cosLonLUT[y];let U=0,k=0,_=0;if(y<s){const e=(R+1)*L;U=T[e],k=T[e+1],_=T[e+2]}else{const e=G.sinLonLUT[a],s=G.cosLonLUT[a],i=v+r.sampleElevation(x,t,B);U=s*o*i-A,k=e*o*i-S,_=n*i-E}const W=D,F=w,z=N;D=q,w=H,N=j,q=U,H=k,j=_;const J=U-W,K=k-F,Q=_-z;let X=0,Y=0,Z=0;if(O>1){const e=(R-s)*L;X=T[e],Y=T[e+1],Z=T[e+2]}else{const e=G.sinLatLUT[0],t=G.cosLatLUT[0],n=v+r.sampleElevation(i,M,B);X=C*t*n-A,Y=V*t*n-S,Z=e*n-E}const $=v+r.sampleElevation(i,u,B),ee=C*b*$-A,te=V*b*$-S,ne=g*$-E;if(O<s){const t=R+s,n=t*L;T[n]=ee,T[n+1]=te,T[n+2]=ne,l.minMaxBoundingBox(ee,te,ne,I),l.encodeUVInBuffer(d,t,e,c)}const oe=X-ee,se=Y-te,re=Z-ne;let ae=C*o,ie=V*o,le=n;le*le<.999&&(ae=Q*se-K*re,ie=J*re-Q*oe,le=K*oe-J*se);const ce=1/Math.sqrt(ae*ae+ie*ie+le*le);p.compressNormal(f,R,ae*ce,ie*ce,le*ce,m),++R}}}function M(e){e.tile.intersectsClippingArea&&(v(e),_(e))}function y(e){e.tile.intersectsClippingArea&&(b(e),B(e,!0),_(e))}function v(e){e.tile.intersectsClippingArea&&(b(e),B(e))}function B(e,n=!1){const o=e.geometryState,s=e.geometry,a=o.neighborData,i=e.tile,c=i.level,f=i.extent,p=i.ellipsoid.radius,g=i.extentInRadians,h=g[0],x=g[2],M=g[1],y=g[3],v=o.samplerData,B=f[0],b=f[2],A=f[1],S=f[3],E=T(e),L=s.boundingBox,P=e.localOrigin,I=P[0],R=P[1],O=P[2],V=s.vertexAttributes,C=V.position,U=C.typedBuffer,D=C.typedBufferStride,w=V.uv0;for(let T=0;T<4;++T){const o=1===T||3===T,g=a.edgeResolutions[T];d.internalAssert(t.isPowerOfTwo(g));const P=g+1,V=u.neighborTileIfLoadedOrSelf(i,a.edgePeerNeighbors[T]);if(J(i,V,T)){q(e,T,V);continue}const C=null!=V;d.internalAssert(!C||V.level===i.level),d.internalAssert(!C||m.compareTilesByLij(i,V)<=0);const N=V?.renderData,k=N?.geometryState;if(d.enableTerrainInternalChecks){const e=i.surface;if(!V&&e&&!e.updatingRootTiles){const t=d.neighborEdgeIndices[T],n=i.findNeighborTile(t,(e=>e.isLoaded||e.isLeaf||e.level===i.level));n?n.intersectsClippingArea&&(d.internalAssert(!n.isLoaded),d.internalAssert(!n.isLeaf),d.internalAssert(n.level===c)):d.internalAssert(null==e?.rootTiles||!i.shouldHaveNeighbor(t))}}const H=1===T?f[2]:f[0],j=V?.extent,_=j&&o?1===T?j[0]:j[2]:H,W=0===T?f[3]:f[1],G=1===T?1:0,F=0===T?1:0,z=1===T?x:h,K=0===T?y:M,Q=Math.sin(z),X=Math.cos(z),Y=Math.sin(K),Z=Math.cos(K),$=k?.samplerData,ee=C?(e,t,n)=>.5*(r.sampleElevation(e,t,v)+r.sampleElevation(n,t,$)):(e,t,n)=>r.sampleElevation(e,t,v),te=s.outerEdges[T],ne=n&&P>3?P-3:1,oe=null!=v&&v.some((e=>null!=e)),se=null!=$&&$.some((e=>null!=e)),re=oe||se,ae=1/g,ie=te.index0;d.internalAssert(!j||d.almostEquals(j[2]-j[0],f[2]-f[0]));(()=>{const e=1===T?-1:3===T?1:0,t=0===T?-1:2===T?1:0,n=(f[2]-f[0])*ae,s=e*n,a=t*n,i=o?e*((x-h)*ae):0,c=o?0:t*ae,u=F,d=o?z+i:z,m=o?Math.sin(d):Q,g=o?Math.cos(d):X,M=o?z-i:z,y=o?Math.sin(M):Q,V=o?Math.cos(M):X,N=o?K:E(u+c),k=o?Y:Math.sin(N),q=o?Z:Math.cos(N),j=o?K:E(u-c),J=o?Y:Math.sin(j),oe=o?Z:Math.cos(j);let se=0,le=0,ce=0;{const e=0*ae,t=o?H:B*(1-e)+b*e,n=o?_:t,s=o?A*(1-e)+S*e:W,r=o?z:h*(1-e)+x*e,a=o?Q:Math.sin(r),i=o?X:Math.cos(r),l=o?E(e):K,c=o?Math.sin(l):Y,u=o?Math.cos(l):Z,d=p+ee(t,s,n);se=i*u*d,le=a*u*d,ce=c*d}let ue=0,de=0,fe=0;{const e=1*ae,t=o?H:B*(1-e)+b*e,n=o?_:t,s=o?A*(1-e)+S*e:W,r=o?z:h*(1-e)+x*e,a=o?Q:Math.sin(r),i=o?X:Math.cos(r),l=o?E(e):K,c=o?Math.sin(l):Y,u=o?Math.cos(l):Z,d=p+ee(t,s,n);ue=i*u*d,de=a*u*d,fe=c*d}for(let f=1;f<P-1;f+=ne){let e=0,t=0,n=0;{const s=(f+1)*ae,r=o?H:B*(1-s)+b*s,a=o?_:r,i=o?A*(1-s)+S*s:W,l=o?z:h*(1-s)+x*s,c=o?Q:Math.sin(l),u=o?X:Math.cos(l),d=o?E(s):K,m=o?Math.sin(d):Y,g=o?Math.cos(d):Z,M=p+ee(r,i,a);e=u*g*M,t=c*g*M,n=m*M}const i=e,c=t,u=n,d=ue,M=de,P=fe;ue=i,de=c,fe=u;{const e=ie+f,t=e*D,n=d-I,s=M-R,r=P-O;U[t]=n,U[t+1]=s,U[t+2]=r,l.minMaxBoundingBox(n,s,r,L);const a=f*ae,i=o?G:a,c=o?a:F;l.encodeUVInBuffer(w,e,i,c)}const N=se,j=le,ne=ce;se=d,le=M,ce=P;const me=d,pe=M,ge=P,he=1/Math.sqrt(me*me+pe*pe+ge*ge),xe=ge*he;let Me=0,ye=0,ve=0;if(re&&xe*xe<.999){let e=0,t=0,n=0;{const o=0===T?-1:1;e=o*(i-N),t=o*(c-j),n=o*(u-ne)}{const i=f*ae,l=o?H:B*(1-i)+b*i,c=o?_:l,u=o?A*(1-i)+S*i:W,d=o?z:h*(1-i)+x*i,M=o?Q:Math.sin(d),L=o?X:Math.cos(d),P=o?E(i):K,I=o?Math.sin(P):Y,R=o?Math.cos(P):Z;let O=me,U=pe,D=ge;if(C){const e=c-s,t=u-a,n=p+r.sampleElevation(e,t,$),i=o?R:oe;O=(o?V:L)*i*n,U=(o?y:M)*i*n,D=(o?I:J)*n}{const i=l+s,c=u+a,d=p+r.sampleElevation(i,c,v),f=o?R:q,h=(o?g:L)*f*d,x=(o?m:M)*f*d,y=(o?I:k)*d;C||(O=2*me-h,U=2*pe-x,D=2*ge-y);const B=3===T?-1:1,b=B*(O-h),A=B*(U-x),S=B*(D-y);Me=n*A-t*S,ye=e*S-n*b,ve=t*b-e*A;const E=1/Math.sqrt(Me*Me+ye*ye+ve*ve);Me*=E,ye*=E,ve*=E}}}else Me=me*he,ye=pe*he,ve=ge*he;te.setNormalFromValues(f,Me,ye,ve)}})()}}function b(e){H(e)}function A(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function S(e,t,n,o){return A(e*(1-o)+t*o,n)}function E(e,t,n){return e*(1-n)+t*n}function T(e){const t=e.tile;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>S(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>E(n[1],n[3],e)}function L(e,t){const s=e.tile,{extent:r,surface:a}=s,i=e.geometryState,l=r[0],c=r[1],u=r[2]-l,d=r[3]-c,f=i.clippingArea,m=null!=f?Math.max(0,(f[0]-l)/u):0,p=null!=f?Math.max(0,(f[1]-c)/d):0,g=null!=f?Math.min(1,(f[2]-l)/u):1,h=null!=f?Math.min(1,(f[3]-c)/d):1,x=i.numVerticesPerSide,M=(x-2)**2,y=M+i.neighborData.edgeResolutions.reduce(((e,t)=>e+t+1),0),v=a.renderer.tileGeometryCache.acquire(y),B=e.geometry,b=B.boundingBox;o.empty(b),B.numVerticesPerSide=i.numVerticesPerSide,B.vertexAttributes=v,n.set(B.uvRange,m,p,g,h),P(e),k(e,M),O(e),N(B,i.numVerticesPerSide,[],[0,x-1],[0,x-1],i.wireframe),e.intersectionData=null}function P(e){const n=e.tile;if(!n.intersectsClippingArea)return;const o=n.surface,s=e.geometryState,a=s.samplerData,i=e.localOrigin,c=o.isWebMercatorOnPlateeCarree,u=s.clippingArea,d=null!=u?u:F,f=n.extent,m=f[0],g=f[1],h=f[2],x=f[3],M=Math.max(m,d[0]),y=Math.min(h,d[2]),v=Math.max(g,d[1]),B=Math.min(x,d[3]),b=n.ellipsoid.radius,A=n.horizontalScale,S=s.numVerticesPerSide,E=S-1,T=S-2,L=e.geometry,P=L.vertexAttributes,I=P.position,R=P.uv0,{typedBuffer:O,typedBufferStride:V}=P.normalCompressed,C=L.uvRange,U=C[0],D=C[1],w=C[2],N=C[3],k=L.boundingBox,q=i[0],H=i[1],j=i[2],_=I.typedBuffer,W=I.typedBufferStride;let G=0;const z=t.clamp(g,v,B),J=c?(Math.PI/2-2*Math.atan(Math.exp(-z/b)))*b:z*A,K=1/E,Q=t.clamp(g*(1-K)+x*K,v,B);let X=J,Y=c?(Math.PI/2-2*Math.atan(Math.exp(-Q/b)))*b:Q*A;for(let F=1;F<=T;F++){const e=F/E,n=t.clamp(g*(1-e)+x*e,v,B),o=t.clamp(e,D,N),s=Y,i=(F-1)/E,u=t.clamp(g*(1-i)+x*i,v,B),d=X,f=(F+1)/E,S=t.clamp(g*(1-f)+x*f,v,B),L=c?(Math.PI/2-2*Math.atan(Math.exp(-S/b)))*b:S*A,P=t.clamp(f,D,N);X=Y,Y=L;const I=t.clamp(m,M,y);let C=I*A,z=r.sampleElevation(I,n,a);const J=1/E,K=t.clamp(J,U,w),Q=t.clamp(m*(1-K)+h*K,M,y);let Z=K,$=Q,ee=Q*A,te=r.sampleElevation(Q,n,a);if(1===F){const e=ee-q,n=X-H,s=te-j,r=0*W;_[r]=e,_[r+1]=n,_[r+2]=s,l.minMaxBoundingBox(e,n,s,k);const a=t.clamp(J,U,w);l.encodeUVInBuffer(R,G,a,o)}for(let c=1;c<=T;c++){const e=ee,i=te,f=(c+1)/E,g=t.clamp(f,U,w),x=t.clamp(m*(1-f)+h*f,M,y),v=$;$=x;{const e=G+1,t=e*W;if(1===F||c===T){const i=x*A,u=r.sampleElevation(x,n,a);if(1===F&&c<T){const n=i-q,r=s-H,a=u-j;_[t]=n,_[t+1]=r,_[t+2]=a,l.minMaxBoundingBox(n,r,a,k),l.encodeUVInBuffer(R,e,g,o)}ee=i,te=u}else ee=_[t]+q,te=_[t+2]+j}const B=ee,b=te,I=C,D=z;C=e,z=i;const N=(G-T)*W,J=1===F?r.sampleElevation(v,u,a):_[N+2]+j,K=r.sampleElevation(v,S,a);if(F<T){const t=G+T,n=t*W,o=e-q,s=L-H,r=K-j;_[n]=o,_[n+1]=s,_[n+2]=r,l.minMaxBoundingBox(o,s,r,k);const a=Z;Z=g,l.encodeUVInBuffer(R,t,a,P)}{const e=B-I,t=d-L,n=t*(b-D),o=e*(J-K),s=-t*e,r=n*n+o*o+s*s;if(0===r)p.compressNormal(O,G,0,0,1,V);else{const e=1/Math.sqrt(r);p.compressNormal(O,G,n*e,o*e,s*e,V)}}++G}}}function I(e,t){e.tile.intersectsClippingArea&&(C(e),V(e,!0),_(e))}function R(e,t){e.tile.intersectsClippingArea&&(O(e),_(e))}function O(e,t){e.tile.intersectsClippingArea&&(C(e),V(e,!1))}function V(e,n){const o=e.geometryState,s=o.neighborData,a=e.tile,i=a.surface,c=a.extent,f=o.clippingArea,p=null!=f?f:F,g=c[0],h=c[2],x=c[1],M=c[3],y=[M>p[3],h>p[2],x<p[1],g<p[0]],v=e.geometry,B=a.horizontalScale,b=w(i.isWebMercatorOnPlateeCarree,a.ellipsoid.radius,B),A=v.boundingBox,S=v.uvRange[0],E=v.uvRange[1],T=v.uvRange[2],L=v.uvRange[3],P=Math.max(g,p[0]),I=Math.min(h,p[2]),R=Math.max(x,p[1]),O=Math.min(M,p[3]),V=e.localOrigin,C=V[0],U=V[1],D=V[2],N=o.samplerData;for(let w=0;w<4;++w){const o=1===w||3===w,c=s.edgeResolutions[w];d.internalAssert(t.isPowerOfTwo(c));const f=c+1,p=y[w],V=u.neighborTileIfLoadedOrSelf(a,s.edgePeerNeighbors[w]);if(!p&&J(a,V,w)){q(e,w,V);continue}const k=null!=V&&!p,H=V?.renderData,j=H?.geometryState;if(d.enableTerrainInternalChecks&&(d.internalAssert(!k||V.level===a.level),d.internalAssert(!k||m.compareTilesByLij(a,V)<=0),a&&!V&&!i.updatingRootTiles)){const e=d.neighborEdgeIndices[w],t=a.findNeighborTile(e,(e=>e.isLoaded||e.isLeaf||e.level===a.level));i.updatingRootTiles||(t?t.intersectsClippingArea&&(d.internalAssert(!t.isLoaded),d.internalAssert(!t.isLeaf),d.internalAssert(t.level===a.level)):d.internalAssert(null==i?.rootTiles||!a.shouldHaveNeighbor(e)))}const _=t.clamp(1===w?h:g,P,I),W=t.clamp(0===w?M:x,R,O),G=j?.samplerData,F=v.outerEdges[w],z=n&&f>3?f-3:1,K=t.clamp(1===w?1:0,S,T),Q=t.clamp(0===w?1:0,E,L),X=k?(e,t)=>.5*(r.sampleElevation(e,t,G)+r.sampleElevation(e,t,N)):(e,t)=>r.sampleElevation(e,t,N),Y=(h-g)/c,Z=o?1===w?Y:-Y:0,$=o?0:0===w?Y:-Y,ee=-Z,te=-$;let ne=0,oe=0,se=0;{const e=0/c,n=o?_:t.clamp(g*(1-e)+h*e,P,I),s=o?t.clamp(x*(1-e)+M*e,R,O):W,r=X(n,s);ne=n*B,oe=b(s),se=r}let re=0,ae=0,ie=0;{const e=1/c,n=o?_:t.clamp(g*(1-e)+h*e,P,I),s=o?t.clamp(x*(1-e)+M*e,R,O):W,r=X(n,s);re=n*B,ae=b(s),ie=r}for(let e=1;e<f-1;e+=z){const n=e/c,s=re,a=ae,i=ie;{const r=o?K:t.clamp(n,S,T),c=o?t.clamp(n,E,L):Q,u=s-C,d=a-U,f=i-D;l.minMaxBoundingBox(s,d,f,A),F.setVertexFromValuesRawPositionUV(e,u,d,f,r,c)}{const n=(e+1)/c,s=o?_:t.clamp(g*(1-n)+h*n,P,I),r=o?t.clamp(x*(1-n)+M*n,R,O):W,a=X(s,r);re=s*B,ae=b(r),ie=a}const u=re,d=ie,f=ne,m=oe,p=se;ne=s,oe=a,se=i;let y=0,v=0,V=0;if(o){const e=ae-a,o=d-i,l=m-a,c=p-i,u=t.clamp(x*(1-n)+M*n,R,O),f=_+ee,g=u,h=f*B-s,b=r.sampleElevation(f,g,N)-i,A=3===w?-1:1;if(y=A*(-l+e)*b,v=A*h*(-c+o),V=-A*h*(-l+e),k){const t=_+Z,n=u,a=t*B-s;y=(-l+e)*(b-(r.sampleElevation(t,n,G)-i)),v=(h-a)*(-c+o),V=-(h-a)*(-l+e)}}else{const e=u-s,o=d-i,l=f-s,c=p-i,m=t.clamp(g*(1-n)+h*n,P,I),x=m,M=W+te,B=r.sampleElevation(x,M,N)-i,A=b(M)-a,S=2===w?-1:1;if(y=S*A*(-c+o),v=S*(-l+e)*B,V=-S*A*(-l+e),k){const t=m,n=W+$,s=b(n)-a;y=(-A+s)*(-c+o),v=(-l+e)*(-B+(r.sampleElevation(t,n,G)-i)),V=-(-A+s)*(-l+e)}}const q=1/Math.sqrt(y*y+v*v+V*V);F.setNormalFromValues(e,y*q,v*q,V*q)}}}function C(e,t){H(e)}function U(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function D(e,t){return e*t}function w(e,t,n){return e?e=>U(e,t):e=>D(e,n)}function N(e,t,n,o,s,r){const a=t-1,i=e.vertexAttributes.count,l=2*(Math.min(t-2,o[1])-Math.max(1,o[0]))*(Math.min(t-2,s[1])-Math.max(1,s[0])),c=d.neighborEdgeIndices.map(((e,n)=>0===n&&s[1]<t-2||1===n&&o[1]<t-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=e.outerEdges.reduce(((e,t,n)=>e+(c[n]?0:a-2+t.count-1)),0),f=n.reduce(((e,t)=>e+a*(2*(t.latitudeResolution-1)+1)),0),m=r?2:1,p=3*(l+u+f)*m,h=i>=g?new Uint32Array(p):new Uint16Array(p);let x=0;const M=t-2,y=a-2;d.internalAssert(y>=0);const v=(e,t,n,o,s,r)=>{const a=e*s,i=r[a],l=r[a+1],c=r[a+2],u=t*s,d=r[u],f=r[u+1],m=r[u+2],p=n*s,g=r[p],h=r[p+1],x=r[p+2],M=o*s,y=r[M],v=r[M+1],B=r[M+2];return(d-y)*(d-y)+(f-v)*(f-v)+(m-B)*(m-B)>(i-g)*(i-g)+(l-h)*(l-h)+(c-x)*(c-x)};if(r){const r=(e,t,n)=>{h[x++]=e,h[x++]=t,h[x++]=t,h[x++]=n,h[x++]=n,h[x++]=e,d.enableTerrainInternalChecks&&(d.internalAssert(e<i),d.internalAssert(t<i),d.internalAssert(n<i),d.internalAssert(x<=p))};(()=>{for(let n=Math.max(s[0],1)-1;n<Math.min(s[1],t-2)-1;++n){const s=n*M;for(let a=Math.max(o[0],1)-1;a<Math.min(o[1],t-2)-1;++a){const t=n*M+a,o=t+1,i=o+M,l=i-1,c=s+a,u=c+1,d=u+M,f=d-1,m=e.vertexAttributes.position.typedBuffer,p=e.vertexAttributes.position.typedBufferStride;v(c,u,d,f,p,m)?(r(t,o,i),r(i,l,t)):(r(t,o,l),r(l,i,o))}}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){const n=x;if(c[t])continue;const o=e.outerEdges[t],s=e.innerEdges[t];let i=0,l=0;const u=o.count,f=s.count;d.internalAssert(f===a-1);let p=0;const g=1===t||2===t?(e,t,n)=>r(e,t,n):(e,t,n)=>r(e,n,t);for(;i<u-1||l<f-1;){const e=s.getVertexIndex(l),t=o.getVertexIndex(i),n=i<u-1,r=l<f-1;if(n&&(!r||(n?0+a*(i+.5)/(u-1):0)<=(r?1+y*(l+.5)/(f-1):0))){++i,d.enableTerrainInternalChecks&&d.internalAssert(i<u);g(e,t,o.getVertexIndex(i)),p++}else{++l,d.enableTerrainInternalChecks&&d.internalAssert(l<f);g(e,t,s.getVertexIndex(l)),p++}}d.enableTerrainInternalChecks&&(d.internalAssert(i===u-1),d.internalAssert(l===f-1),d.internalAssert(p===u+f-2),d.internalAssert(p===a-2+o.count-1),d.internalAssert(x===n+3*p*m))}})(),d.internalAssert(x===3*(l+u)*m);const f=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),i=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<a;t++)r(s,s+1,o+t),e<n.latitudeResolution-1&&r(s+1,o+t+1,o+t),s+=i;s=o,i=1}};(()=>n.forEach(f))()}else{(()=>{const n=Math.max(s[0],1)-1,r=Math.min(s[1],t-2)-1,a=Math.max(o[0],1)-1,i=Math.min(o[1],t-2)-1;for(let t=n;t<r;++t){const n=t*M;for(let t=a;t<i;++t){const o=n+t,s=o+1,r=s+M,a=r-1,i=e.vertexAttributes.position.typedBuffer,l=e.vertexAttributes.position.typedBufferStride;v(o,s,r,a,l,i)?(h[x]=o,h[x+1]=s,h[x+2]=r,h[x+3]=r,h[x+4]=a,h[x+5]=o):(h[x]=o,h[x+1]=s,h[x+2]=a,h[x+3]=a,h[x+4]=s,h[x+5]=r),x+=6}}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){if(c[t])continue;const n=e.outerEdges[t],o=e.innerEdges[t];let s=0,r=0;const i=n.count,l=o.count;d.internalAssert(l===a-1);const u=1===t||2===t,f=u?1:2,m=u?2:1,p=n.index0,g=n.stride,M=o.index0,v=o.stride;for(;s<i-1||r<l-1;){const e=M+r*v,t=p+s*g,n=s<i-1,o=r<l-1,c=n&&(!o||(n?0+a*(s+.5)/(i-1):0)<=(o?1+y*(r+.5)/(l-1):0));c?++s:++r;const u=c?t+g:e+v;h[x]=e,h[x+f]=t,h[x+m]=u,x+=3}}})(),d.internalAssert(x===3*(l+u)*m);const r=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),r=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<a;t++){const a=o+t;h[x]=s,h[x+1]=s+1,h[x+2]=a,e<n.latitudeResolution-1?(h[x+3]=s+1,h[x+4]=a+1,h[x+5]=a,x+=6):x+=3,s+=r}s=o,r=1}};(()=>n.forEach(r))()}d.internalAssert(x===p),e.indices=h,e.indexCount=p}function k(e,t){const n=e.localOrigin,o=e.geometry,s=e.geometryState.neighborData.edgeResolutions,r=o.numVerticesPerSide-2,a=o.vertexAttributes;let i=t;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?r-1:0)*r+(1===c?r-1:0),s=(e?0:1)*r+(e?1:0);o.innerEdges[c]=new l.EdgeDescriptor(a,n,t,s,r)}{const e=i,t=s[c]+1;o.outerEdges[c]=new l.EdgeDescriptor(a,n,e,1,t),i+=t}}}function q(e,n,o){const s=(n+2)%4,r=e.geometryState,a=e.tile,i=r.neighborData,c=a.level-o.level,u=1===n||3===n,f=i.edgeResolutions[n];d.internalAssert(t.isPowerOfTwo(f));const m=f+1,p=e.geometry,g=p.boundingBox,h=p.outerEdges[n],x=p.uvRange[0],M=p.uvRange[1],y=p.uvRange[2],v=p.uvRange[3],B=t.clamp(1===n?1:0,x,y),b=t.clamp(0===n?1:0,M,v),A=o.renderData,S=A.geometryState,E=A.geometry.outerEdges[s],T=a.getNeighborEdgeStartVertexIndex(n,o)*f,L=f*2**c;d.internalAssert(S.neighborData.edgeResolutions[s]===L),d.internalAssert(E.count-1===L);const P=A.localOrigin[0]-e.localOrigin[0],I=A.localOrigin[1]-e.localOrigin[1],R=A.localOrigin[2]-e.localOrigin[2],O=h.attributes,V=h.index0,C=h.stride,U=O.position.typedBuffer,D=O.position.typedBufferStride,w=O.normalCompressed.typedBuffer,N=O.normalCompressed.typedBufferStride,k=O.uv0,q=E.attributes,H=E.index0,j=E.stride,_=q.position.typedBuffer,W=q.position.typedBufferStride,G=q.normalCompressed.typedBuffer,F=q.normalCompressed.typedBufferStride;for(let d=1;d<m-1;++d){const e=V+C*d,n=H+j*(T+d),o=e*D,s=n*W,r=_[s]+P,a=_[s+1]+I,i=_[s+2]+R;U[o]=r,U[o+1]=a,U[o+2]=i,l.minMaxBoundingBox(r,a,i,g);const c=e*N,m=n*F;w[c]=G[m],w[c+1]=G[m+1];const p=d/f,h=u?B:t.clamp(p,x,y),A=u?t.clamp(p,M,v):b;l.encodeUVInBuffer(k,e,h,A)}}function H(e){const n=e.geometryState,o=n.neighborData,s=e.localOrigin,a=o.cornerNeighborData,i=e.geometry,c=i.outerEdges,u=i.boundingBox,f=e.tile,p="local"===e.tile.surface.view?.viewingMode,g=f.ellipsoid.radius,h=f.extentInRadians,x=f.horizontalScale;let M=0,y=0,v=0;const B=(e,t,n)=>{const o=h[0===t?1:3],s=h[0===e?0:2],r=Math.cos(o),a=Math.sin(o),i=Math.sin(s),l=Math.cos(s),c=g+n;M=l*r*c,y=i*r*c,v=a*c},b=p?(()=>{const n=e.geometryState.clippingArea,o=f.extent,s=null!=n&&(o[3]>n[3]||o[2]>n[2]||o[1]<n[1]||o[0]<n[0]),r=w(f.surface.isWebMercatorOnPlateeCarree,f.ellipsoid.radius,x);return(e,o,a)=>{const i=0===e?D[0]:D[2],l=0===o?D[1]:D[3],c=s?t.clamp(i,n[0],n[2]):i,u=s?t.clamp(l,n[1],n[3]):l,d=a;M=c*x,y=r(u),v=d}})():B;let A=0,S=0,E=0,L=0,P=0,I=0,R=0,O=0,V=0;const C=p&&e.tile.surface.isWebMercatorOnPlateeCarree,U=(e,t,n,o,s)=>{let r=0,a=0,i=0;if(p){const e=t*x,s=C?(Math.PI/2-2*Math.atan(Math.exp(-n/g)))*g:n*x;r=e-M,a=s-y,i=o-v}else{const s=T(e),l=e.tile,c=l.extent,u=l.extentInRadians,d=(t-c[0])/(c[2]-c[0]),f=(n-c[1])/(c[3]-c[1]),m=u[0]*(1-d)+u[2]*d,p=s(f),h=Math.cos(p),x=Math.sin(p),B=Math.sin(m),b=Math.cos(m),A=g+o;r=b*h*A-M,a=B*h*A-y,i=x*A-v}switch(s){case 0:R+=r,O+=a,V+=i;break;case 1:L-=r,P-=a,I-=i;break;case 2:R-=r,O-=a,V-=i;break;case 3:L+=r,P+=a,I+=i}},D=f.extent,N=n.clippingArea??F,k=D[0],q=D[2],H=D[1],_=D[3],G=[_>N[3],q>N[2],H<N[1],k<N[0]],J=Math.max(k,N[0]),K=Math.min(q,N[2]),Q=Math.max(H,N[1]),X=Math.min(_,N[3]),Y=e=>Math.max(N[0],Math.min(N[2],e)),Z=e=>Math.max(N[1],Math.min(N[3],e)),$=i.uvRange[0],ee=i.uvRange[1],te=i.uvRange[2],ne=i.uvRange[3],oe=e=>{const t=a[e].cornerTiles;A=0,S=0,E=1,L=0,P=0,I=0,R=0,O=0,V=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,t[r]?.level??1/0);for(let r=0;r<4;++r){const e=t[r];z[r]=e?.level===n?e:null}let o=1,s=0;for(let r=0;r<4;++r){const e=z[r];e&&(o=Math.max(o,e?.renderData.geometryState.numVerticesPerSide),s=e.extent[2]-e.extent[0])}const i=s,l=o;d.internalAssert(l>1);const c=i/l;for(let a=0;a<4;++a){const e=z[(a+3)%4],t=z[a%4];if(!e&&!t)continue;const n=0===a?1:1===a?2:2===a?3:0,o=0===a?2:1===a?3:2===a?0:1;if(e&&t){const s=W[a][0]*c,i=W[a][1]*c,l=e.extent,u=Y(l[0===n||1===n?2:0]+s),d=Z(l[0===n||3===n?3:1]+i),f=t.extent,m=Y(f[0===o||1===o?2:0]+s),p=Z(f[0===o||3===o?3:1]+i),g=e.renderData,h=t.renderData,x=r.sampleElevation(u,d,g.geometryState.samplerData),M=r.sampleElevation(m,p,h.geometryState.samplerData);U(g,u,d,.5*(x+M),a)}else{const s=e??t,i=e?n:o,l=s.extent,u=W[a],d=Y(l[0===i||1===i?2:0]+u[0]*c),f=Z(l[0===i||3===i?3:1]+u[1]*c),m=s.renderData,p=r.sampleElevation(d,f,m.geometryState.samplerData);U(m,d,f,p,a)}}if(!p){const e=Math.sqrt(M*M+y*y+v*v);A=M/e,S=y/e,E=v/e}if(p||E*E<.999){const e=Math.sqrt(L*L+P*P+I*I);L/=e,P/=e,I/=e;const t=Math.sqrt(R*R+O*O+V*V);R/=t,O/=t,V/=t,A=I*O-P*V,S=L*V-I*R,E=P*R-L*O;const n=1/Math.sqrt(A*A+S*S+E*E);A*=n,S*=n,E*=n}};for(let T=0;T<4;++T){const o=T,i=(T+1)%4,p=0===T||1===T?1:0,g=0===T||3===T?1:0,h=t.clamp(p,$,te),x=t.clamp(g,ee,ne),B=c[o],L=0===T||3===T?B.count-1:0,P=c[i],I=0===T||1===T?P.count-1:0,R=a[T].cornerTiles;let O=-1;for(let e=0;e<4;++e){const t=R[e];t&&(-1===O||m.compareTilesByLij(R[O],t)>0)&&(O=e)}const V=O,C=R[V];if(C!==f){const t=f.level-C.level,n=2**t,o=[C.lij[0]+t,C.lij[1]*n,C.lij[2]*n],s=[o[1]+n===f.lij[1],0===T&&(1===V||0===V&&C!==R[3])||1===T&&(0===V||1===V&&C!==R[2]),o[1]===f.lij[1]+1,2===T&&(3===V||2===V&&C!==R[1])||3===T&&(2===V||3===V&&C!==R[0])],r=s.reduce(((e,t)=>e+(t?1:0)),0);d.internalAssert(1===r||2===r);let a=-1,i=-1;const c=C.renderData;if(1===r){const t=s.findIndex((e=>e));d.internalAssert(0<=t&&t<=3),a=(t+2)%4;const n=e.geometryState.neighborData.edgeResolutions[t];i=f.getNeighborEdgeStartVertexIndex(t,C)*n+n*(0===t&&0===T||1===t&&0===T||2===t&&1===T||3===t&&3===T?1:0)}else{d.internalAssert(s[1]||s[3]),a=s[1]?3:1;const e=c.geometryState.neighborData.edgeResolutions[a];i=0===T||3===T?0:e}const m=c.geometry.outerEdges[a];{const t=B.index0+L*B.stride,n=P.index0+I*P.stride,o=m.index0+i*m.stride;{const s=m.attributes.position,r=s.typedBuffer,a=o*s.typedBufferStride,i=e.localOrigin,c=m.localOrigin,d=r[a]+c[0]-i[0],f=r[a+1]+c[1]-i[1],p=r[a+2]+c[2]-i[2];l.minMaxBoundingBox(d,f,p,u);{const e=B.attributes.position,n=e.typedBuffer,o=t*e.typedBufferStride;n[o]=d,n[o+1]=f,n[o+2]=p}{const e=P.attributes.position,t=e.typedBuffer,o=n*e.typedBufferStride;t[o]=d,t[o+1]=f,t[o+2]=p}}l.encodeUVInBuffer(B.attributes.uv0,t,h,x),l.encodeUVInBuffer(P.attributes.uv0,n,h,x);{const e=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=B.attributes.normalCompressed,o=n.typedBuffer,r=t*n.typedBufferStride;o[r]=e[s],o[r+1]=e[s+1]}{const t=P.attributes.normalCompressed,o=t.typedBuffer,r=n*t.typedBufferStride;o[r]=e[s],o[r+1]=e[s+1]}}}}else{const e=G[o],a=G[i];let c;if(e||a){const e=t.clamp(k*(1-p)+q*p,J,K),o=t.clamp(H*(1-g)+_*g,Q,X),s=n.samplerData;c=r.sampleElevation(e,o,s)}else c=j(R);b(p,g,c),oe(T);const d=M-s[0],f=y-s[1],m=v-s[2];l.minMaxBoundingBox(d,f,m,u),B.setVertexFromValuesRawPositionUVNormal(L,d,f,m,h,x,A,S,E),P.setVertexFromValuesRawPositionUVNormal(I,d,f,m,h,x,A,S,E)}}for(let t=0;t<4;++t)z[t]=null}function j(e){const t=e.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);d.enableTerrainInternalChecks&&(d.internalAssert(!e[0]||!e[2]||f.isCornerNeighbor(e[0],e[2],i.NeighborIndex.SOUTH_WEST)),d.internalAssert(!e[1]||!e[3]||f.isCornerNeighbor(e[1],e[3],i.NeighborIndex.NORTH_WEST)));let n=0,o=0;for(let a=0;a<4;++a){const s=e[a];if(s&&s.level===t){const e=0===a||1===a,t=0===a||3===a,i=s.extent,l=i[e?0:2],c=i[t?1:3],u=s.renderData?.geometryState?.samplerData;o+=r.sampleElevation(l,c,u),n++}}const s=n?o/n:0;return d.internalAssert(null!=s),s}function _(e){const t=e.vao,n=e.geometry.vertexAttributes.position.typedBuffer;t.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const W=[[0,1],[1,0],[0,-1],[-1,0]],G=new c.PatchGeometryLUT,F=s.fromValues(-1/0,-1/0,1/0,1/0),z=[null,null,null,null];function J(e,t,n){if(!t)return!1;const o=m.compareTilesByLij(e,t);return o>0||0===o&&n>=2}e.createPlanarGlobePatch=L,e.createSphericalGlobePatch=h,e.updateCornerSpherical=y,e.updateCornersPlanar=I,e.updateEdgesAndCornersPlanar=R,e.updateEdgesAndCornersSpherical=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
