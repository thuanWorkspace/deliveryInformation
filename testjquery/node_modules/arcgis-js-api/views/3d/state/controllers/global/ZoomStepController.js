/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/mathUtils","../../../../../core/time","../../../../../core/Logger","../../../../../core/accessorSupport/ensureType","../../../../../core/arrayUtils","../../../../../core/has","../../../../../core/Error","../../../../../core/accessorSupport/decorators/subclass","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/ellipsoidUtils","../../../../../chunks/sphere","../../../camera/constraintUtils","../../../camera/constraintUtils/ConstraintTypes","../../../camera/constraintUtils/InteractionType","../../../camera/constraintUtils/surfaceCollision","../../../camera/constraintUtils/TiltMode","../PointToPointAnimationController","../../utils/navigationUtils","../../../support/geometryUtils/ray","../../../support/geometryUtils/sphere","../../../webgl-engine/lib/Camera","../../../webgl-engine/lib/Intersector","../../../../animation/easing"],(function(t,e,i,r,s,a,n,o,c,h,m,p,l,_,d,y,u,g,C,w,D,M,v,S,b,f){"use strict";const R=.6,z=4,T=60;t.ZoomStepController=class extends w.PointToPointAnimationController{constructor(){super(...arguments),this._zoomLocation=p.create(),this._tmpCamera=new S.Camera,this._tmpViewDir=p.create(),this._tmpRayDir={origin:p.create(),direction:p.create()},this._targetOnSphere=p.create(),this._tmpCenter=p.create(),this._constraintOptions={selection:y.ConstraintTypes.ALL_EXCEPT_COLLISION,interactionType:u.InteractionType.ZOOM,interactionFactor:null,interactionStartCamera:new S.Camera,interactionDirection:null,tiltMode:C.TiltMode.TUMBLE},this._sphere=_.create()}initialize(){this._intersector=b.newIntersector(this.view.state.viewingMode)}zoomStep(t,e){if(!this.active)return;const i=this.view.state,{interactionStartCamera:r}=this._constraintOptions;r&&(this.animation.finished?r.copyFrom(i.camera):this.animation.cameraAt(1,r));let s=!1,a=!1;this.intersectionHelper.intersectScreen(e,this._zoomLocation,0===this.view.map.ground.opacity?D.contentIntersectorOptions:{})&&(s=t>0,a=!0),this._tmpCamera.copyFrom(i.camera),s?this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._tmpCenter)&&(this._tmpCamera.center=this._tmpCenter):this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._zoomLocation)?this._tmpCamera.center=this._zoomLocation:m.copy(this._zoomLocation,this._tmpCamera.center),this._updateCamera(this._tmpCamera,t,this._zoomLocation,e,a),this.begin(this._tmpCamera)}animationSettings(){return{duration:r.Milliseconds(600),easing:f.outExpo}}_updateCamera(t,e,r,s,a){const n=l.getReferenceEllipsoid(this.view.spatialReference),o=D.decideNavigationMode(t,s,n),c=Math.abs(this.view.camera.position.z);m.normalize(O,t.eye),m.scale(O,O,-1),M.fromScreenAtEye(t,s,this._tmpRayDir),m.normalize(this._tmpRayDir.direction,this._tmpRayDir.direction);const h=i.clamp(Math.min(D.zoomDistanceModifier,1/Math.abs(m.dot(O,this._tmpRayDir.direction)))*c,D.zoomMinDistanceModifier,D.zoomMaxDistanceModifier);if(o===D.NavigationMode.Horizontal){let i=R**e;this._sphere[3]=m.length(r),m.subtract(this._tmpViewDir,t.center,t.eye);const a=Math.min(m.length(this._tmpViewDir),h);let n=a*i;if(i<=1&&n<z&&(n=z,i=n/a),Math.abs(a-n)<1e-6)return;const o=m.length(t.center);if(this._sphere[3]!==o){const e=this._sphere[3]+i*(o-this._sphere[3]);t.center=m.scale(L,t.center,e/o)}m.scale(this._tmpViewDir,this._tmpViewDir,-i),t.eye=m.add(L,t.center,this._tmpViewDir),d.applyAll(this.view,t,this._constraintOptions),m.squaredDistance(r,t.center)>1e-12&&v.intersectScreen(this._sphere,t,s,this._targetOnSphere)&&D.panToPosition(this._sphere,t,r,this._targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let i=R**Math.abs(e);const n=e>0?1:-1;m.subtract(this._tmpViewDir,r,t.eye);const o=m.length(this._tmpViewDir),c=this.view._stage.renderView.getMinimalDepthForArea(null,s[0],s[1],this.view.state.camera,T);let p=null!=c?c:h;p=a&&e>0?Math.min(p,o):p,m.scale(this._tmpRayDir.direction,this._tmpRayDir.direction,p),m.add(r,this._tmpRayDir.origin,this._tmpRayDir.direction);let l=p*i;const _=Math.max(z,1.01*t.nearFar[0]);if(e>0&&l<_&&(l=_,i=l/p),Math.abs(p-l)<1e-6)return;m.scale(this._tmpRayDir.direction,this._tmpRayDir.direction,n*(1-i)),t.eye=m.add(L,t.eye,this._tmpRayDir.direction),t.center=m.add(L,t.center,this._tmpRayDir.direction)}g.applySurfaceCollisionConstraint(this.view,t)}},t.ZoomStepController=e.__decorate([h.subclass("esri.views.3d.state.controllers.global.ZoomStepController")],t.ZoomStepController);const L=p.create(),O=p.create();Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
