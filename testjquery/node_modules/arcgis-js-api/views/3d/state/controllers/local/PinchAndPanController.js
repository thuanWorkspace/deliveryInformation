/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/mathUtils","../../../../../core/screenUtils","../../../../../core/Logger","../../../../../core/accessorSupport/ensureType","../../../../../core/arrayUtils","../../../../../core/has","../../../../../core/Error","../../../../../core/accessorSupport/decorators/subclass","../../../../../chunks/vec2","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/support/axisAngle","../../../../../geometry/support/plane","../../../camera/constraintUtils","../../../camera/constraintUtils/ConstraintTypes","../../../camera/constraintUtils/InteractionType","../../../camera/constraintUtils/TiltMode","../../../input/util","../../../layers/VoxelWasm","../InteractiveController","../momentum/PanPlanarMomentumController","../momentum/RotationMomentumController","../momentum/ZoomPlanarMomentumController","../../utils/navigationUtils","../../../webgl-engine/lib/Camera","../../../../navigation/PanPlanarMomentumEstimator","../../../../navigation/RotationMomentumEstimator","../../../../navigation/ZoomMomentumEstimator"],(function(t,e,i,n,a,o,r,s,m,c,l,h,p,u,_,d,g,C,M,P,v,b,y,w,E,S,V,z,A,T){"use strict";const f=p.fromValues(0,0,1),H={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};t.PinchAndPanController=class extends b.InteractiveController{constructor(){super(...arguments),this._rotationValueSmooth=new P.ExponentialFalloff(.05),this._scalingValueSmooth=new P.ExponentialFalloff(.05),this._planeHorizontal=_.create(),this._planeVertical=_.create(),this._rotationMomentumEstimator=new A.RotationMomentumEstimator,this._panMomentumEstimator=new z.PanPlanarMomentumEstimator(300,12,.9),this._zoomMomentumEstimator=new T.ZoomMomentumEstimator,this._beginRadius=0,this._beginCenter=p.create(),this._beginAngle=0,this._tmpPoints=[],this._panMode=S.NavigationMode.Horizontal,this._beginCenterScreen=n.createScreenPointArray(),this._tmpCentroid3d=p.create(),this._tmpCentroid2d=n.createScreenPointArray(),this._tmp2d=n.createScreenPointArray(),this._pointerCount=0,this._constraintOptions={selection:g.ConstraintTypes.ALL,interactionType:C.InteractionType.NONE,interactionFactor:0,interactionStartCamera:new V.Camera,interactionDirection:null,tiltMode:M.TiltMode.TUMBLE}}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=e,this._rotationMomentumEstimator.enabled=e,this._panMomentumEstimator.enabled=e,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),n.screenPointObjectToArray(t.center,this._beginCenterScreen),_.fromNormalAndOffset(f,0,this._planeHorizontal);const a=p.create(),o=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,a,0===this.view.map.ground.opacity?S.contentIntersectorOptions:{}),r=p.create();h.negate(r,this.startCamera.viewForward);const s=p.create();h.copy(s,f);const m=h.dot(r,s),c=m<0,l=i.asinClamped(c?-m:m);this._panMode=l>=H.ANGLE_THRESHOLD?S.NavigationMode.Horizontal:S.NavigationMode.Vertical;const u=Math.min(S.panDistanceModifier,1/Math.abs(h.dot(s,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),S.minHeightLimit);_.setOffsetFromPoint(this._planeHorizontal,this._planeHorizontal,a),this.startCamera.aboveGround||_.negate(this._planeHorizontal,this._planeHorizontal);const d=p.create(),g=p.create(),C=p.create();h.subtract(d,a,this.currentCamera.eye);const M=h.length(d);if(h.normalize(d,d),this._panMode===S.NavigationMode.Vertical){h.scale(s,s,m),h.subtract(this._planeVertical,r,s),h.normalize(this._planeVertical,this._planeVertical),_.setOffsetFromPoint(this._planeVertical,this._planeVertical,a);const e=this.view._stage.renderView.getMinimalDepthForArea(v.getVoxelWasm(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,S.screenPixelArea);let i=null!=e?e:u;i=o?Math.min(i,M):i,h.copy(C,h.add(g,this.currentCamera.eye,h.scale(g,d,i))),this._planeVertical[3]=-h.dot(this._planeVertical,C),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),S.centroid(this._tmpPoints,this._beginCenter)}else{const e=o?M:u;h.copy(C,h.add(g,this.currentCamera.eye,h.scale(g,d,e))),this._planeHorizontal[3]=-h.dot(_.normal(this._planeHorizontal),C),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),S.centroid(this._tmpPoints,this._beginCenter)}this._constraintOptions.interactionStartCamera?.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const e=t.pointers.size>1,i=this._panMode===S.NavigationMode.Horizontal?this._planeHorizontal:this._planeVertical,a=this._beginCenter;if(e){const e=this._beginRadius/t.radius,i=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=i,this._scalingValueSmooth.update(e),S.applyZoomToPoint(this.currentCamera,a,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=C.InteractionType.ZOOM,this._constraintOptions.interactionFactor=d.pixelDistanceToInteractionFactor(Math.abs(t.radius-this._beginRadius)),d.applyAll(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,i,this.currentCamera,this._tmpPoints),S.centroid(this._tmpPoints,this._tmpCentroid3d),n.screenPointObjectToArray(t.center,this._tmpCentroid2d),S.applyPanPlanar(this.currentCamera,a,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=C.InteractionType.PAN,this._constraintOptions.interactionFactor=d.pixelDistanceToInteractionFactor(l.distance(this._beginCenterScreen,this._tmpCentroid2d)),d.applyAll(this.view,this.currentCamera,this._constraintOptions),e){const e=this._planeHorizontal,i=a,n=this._rotationValueSmooth.value,o=n+S.normalizeRotationDelta(t.angle-n),r=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=r,this._rotationValueSmooth.update(o);const s=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(s,.001*t.timestamp),S.applyRotation(this.currentCamera,i,u.wrapAxisAngle(e,s)),this._constraintOptions.interactionType=C.InteractionType.TUMBLE,this._constraintOptions.interactionFactor=d.pixelDistanceToInteractionFactor(Math.abs(t.radius*s)),d.applyAll(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const e=this._zoomMomentumEstimator.evaluateMomentum();if(e)return new E.ZoomPlanarMomentumController({view:this.view,momentum:e,zoomCenter:this._beginCenter});const i=this._rotationMomentumEstimator.evaluateMomentum();if(i)return new w.RotationMomentumController({view:this.view,momentum:i,center:this._beginCenter,axis:_.normal(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new y.PanPlanarMomentumController({view:this.view,momentum:n}):null}_computePlanePoints(t,e,i,n){n.length=t.size;const a=this._tmp2d;let o=0;return t.forEach((t=>{a[0]=t.x,a[1]=t.y,void 0===n[o]&&(n[o]=p.create()),S.intersectPlaneFromScreenPointAtEye(e,i,a,n[o]),o+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}},t.PinchAndPanController=e.__decorate([c.subclass("esri.views.3d.state.controllers.local.PinchAndPanController")],t.PinchAndPanController),Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
