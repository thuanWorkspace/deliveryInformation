/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../Camera","../../../geometry","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/promiseUtils","../../../chunks/mat3","../../../chunks/mat3f64","../../../chunks/mat4f64","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/projection/computeTranslationToOriginAndRotation","../../../geometry/projection/projectPointToVectorWithEngine","../../../geometry/projection/projectVectorToPoint","../../../geometry/projection/projectVectorToVector","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","../../../geometry/Point","../../../geometry/Extent","../../../geometry/SpatialReference","../../../geometry/Geometry","../../../geometry/Multipoint"],(function(e,t,n,a,o,r,i,c,s,l,u,m,g,f,p,h,y,d,w,x,v,T,S,R,b,j,z,A,M,C,E,G){"use strict";const O=.66;function V(e){return 360-c.cyclicalDegrees.normalize(e)}function D(e){return c.cyclicalDegrees.normalize(360-e)}function P(e,t,n){const a=t.camera;if(null!=a)return B(a,j.getViewSR(e));const{targetGeometry:o}=t;if(null==o)return null;const{camera:r,mode:i}=F(e,t.rotation,n);if("point"===o.type)return k(e,t,o,r,i);const c=o.extent;return null==c?null:j.fromExtentSync(e,c,r.heading,r.tilt,i)}async function Z(e,t,n,a){const o=t.camera;if(null!=o)return W(o,j.getViewSR(e),a);const{targetGeometry:r}=t;if(null==r)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:c}=F(e,t.rotation,n);if("point"===r.type)return U(e,t,r,i,c,a);const s=r.extent;if(null==s)throw new Error("Target geometry has no extent!");return j.fromExtentAsync(e,s,i.heading,i.tilt,c,a)}function B(e,t){const n=e.position;let a;try{a=h.project(n,t)}catch(r){return null}const o=e.clone();return o.position=a.clone(),o}async function W(e,t,n){const a=e.position,o=await h.projectWithZConversion(a,t,{signal:n});l.throwIfAborted(n);const r=e.clone();return r.position=o.clone(),r}function F(e,t,n){const a=j.internalToExternal(e,e.state.camera);let o=j.OrientationMode.ADJUST;return null!=t&&(a.heading=V(t),o=j.OrientationMode.LOCKED),null!=n&&(a.tilt=n),{camera:a,mode:o}}function k(e,t,n,a,o){const r=e.spatialReference;let i;try{i=h.project(n.clone(),r)}catch(s){return null}const c=null!=t.scale?j.scaleToDistance(e,t.scale,i.latitude):e.state.camera.distance;return j.fromCenterDistanceSync(e,i,c,a,o)}async function U(e,t,n,a,o,r){const i=e.spatialReference,c=await h.projectWithZConversion(n.clone(),i,{signal:r});l.throwIfAborted(r);const s=null!=t.scale?j.scaleToDistance(e,t.scale,c.latitude):e.state.camera.distance;return j.fromCenterDistanceAsync(e,c,s,a,o,r)}function I(e,t,n=null){return null==n&&(n=new o),H(e,null,t.clone(),n)}async function J(e,n,a){const r=ie(e,n);if(!r)throw new s("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new t({fov:e.camera.fov}),c=new o({camera:i});if(r.target instanceof o){return ce(await _(e,r.target,r,a,c))}if(r.target instanceof t)return ce(await Q(e,r.target,a,c));const l=null!=r.scale||null!=r.zoom;if(r.target instanceof M){const t=r.target.xmin===r.target.xmax||r.target.ymin===r.target.ymax;return ce(l||t?await ee(e,r,r.target.center,i,a,c):await ae(e,r,r.target,i,a,c))}const u={boundingBox:v.empty(),hasZ:!1,screenSpaceObjects:[]},m=l?L(e,r):void 0;if(await X(e,r.target,m,u,a),isFinite(u.boundingBox[0])){let t;if(v.center(u.boundingBox,le),we.x=le[0],we.y=le[1],we.z=le[2],we.spatialReference=e.spatialReference,isFinite(we.z)&&u.hasZ?t=v.isPoint(u.boundingBox):(we.z=void 0,t=T.isPoint(v.toRect(u.boundingBox,fe))),l||t)return ce(await ee(e,r,we,i,a,c));const n=se(e,u.screenSpaceObjects);return ce(await re(e,r,we,u.boundingBox,n,i,a,c))}return r.position?ce(await te(e,r,i,c,a)):ce(await ne(e,r,i,a,c))}function K(e,t){return null==t.scale&&null!=t.zoom?j.zoomToScale(e,t.zoom):t.scale}function L(e,t){const n=K(e,t);return n?R.getResolutionInMetersForScale(n):void 0}function N(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=V(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function H(e,t,n,a){const o=e.spatialReference||C.WGS84;return null==(t=null!=t?t:j.externalToInternal(e,n))||(a.targetGeometry=w.projectVectorToPoint(t.center,e.renderSpatialReference,o),a.scale=j.computeScale(e,t),a.rotation=D(n.heading),a.camera=n),a}async function Y(e,t,n,a){const o=()=>new s("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw o();"mesh"===t.type&&(t=t.extent);const r=t.spatialReference,i=e.spatialReference,c=e.basemapTerrain.spatialReference;if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}null!=n&&null!=c&&null!=e.elevationProvider?(n=await h.projectWithZConversion(n,c,{signal:a}),le[2]=z.getElevationAtPoint(e.elevationProvider,n)??0):le[2]=0}const l=xe[t.type],u=new Array;if(l(t,t.hasZ?e=>{u.push([e[0],e[1],e[2]])}:e=>{u.push([e[0],e[1]])},le),0===u.length)throw o();const m=await h.projectWithZConversion(new G({spatialReference:r,hasZ:t.hasZ,hasM:!1,points:u}),i,{signal:a});if(t.hasZ&&(n.hasZ=!0),t.hasZ)for(const[s,g,f]of m.points)le[0]=s,le[1]=g,le[2]=f,v.expandWithVec3(n.boundingBox,le);else for(const[s,g]of m.points)le[0]=s,le[1]=g,v.expandWithVec3(n.boundingBox,le)}async function q(e,t,n,a,o){const i=await r.result(e.whenViewForGraphic(t));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await Y(e,t.geometry,a,o);const c=i.value,s=await r.result(c.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok||!s.value)return void await Y(e,t.geometry,a,o);const{screenSpaceObjects:l,boundingBox:u}=s.value;v.expandWithAABB(a.boundingBox,u),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(u[2])&&(a.hasZ=!0)}async function X(e,t,n,o,r){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return we.x=n,we.y=a,we.z=void 0,we.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:C.WGS84,void await Y(e,we,o,r)}t&&"map"in t&&"function"==typeof t.map?await Promise.allSettled(t.map((t=>X(e,t,n,o,r)))):t instanceof E?await Y(e,t,o,r):t instanceof a&&await q(e,t,n,o,r)}async function _(e,t,n,a,o){if(null!=t.camera)return Q(e,t.camera,a,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=D(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const r=K(e,n);return null!=r&&(o.scale=r),o.camera=await Z(e,o,n.tilt,a),o}async function Q(e,t,n,a){const o=e.spatialReference,r=await h.projectWithZConversion(t.position,o,{signal:n});return(t=t.clone()).fov=e.camera.fov,t.position=r,H(e,null,t,a)}async function $(e,t,n,a,o,r,i){const c=e.renderSpatialReference;return await d.projectPointToVectorWithEngine(t,ye,c,0,{signal:i}),await d.projectPointToVectorWithEngine(n,he,c,0,{signal:i}),r.targetGeometry=new A(t),o.position=new A(n),f.subtract(pe,ye,he),j.directionToHeadingTilt(e,he,pe,a.up,o),r.scale=j.distanceToScale(e,f.distance(he,ye),r.targetGeometry.latitude),r.rotation=D(o.heading),r.camera=o,r}async function ee(e,t,n,a,o,r){if(null==n)throw new s("createfromcenter","invalid point");r.targetGeometry=n.clone();const i=b.cameraOnContentAlongViewDirection(e);if(t.position)return $(e,r.targetGeometry,t.position,i,a,r,o);if(t.zoomFactor){const a=i.distance/t.zoomFactor,o=f.scale(le,i.viewForward,-a);i.eye=f.add(le,i.center,o),r.scale=j.distanceToScale(e,a,n.latitude)}j.internalToExternal(e,i,a);const c=N(a,t)?j.OrientationMode.LOCKED:j.OrientationMode.ADJUST;if(!t.zoomFactor){const s=K(e,t);if(null==s){const{renderSpatialReference:t}=e;await d.projectPointToVectorWithEngine(n,le,t,0,{signal:o}),S.intersectsPoint(i.frustum,le)?r.scale=j.distanceToScale(e,f.distance(i.eye,le),n.latitude):r.scale=j.computeScale(e,i)}else r.scale=s;r.camera=await j.fromCenterScale(e,r.targetGeometry,r.scale,a,c,o)}return r}async function te(e,t,n,a,o){const r=b.cameraOnContentAlongViewDirection(e);f.copy(pe,r.viewForward),j.directionToHeadingTilt(e,r.eye,pe,r.up,de);const i=e.spatialReference,{position:c}=t;if(c){const e=await h.projectWithZConversion(c,i,{signal:o});n.position=e}else n.position=new A;return n.heading=null!=t.heading?t.heading:de.heading,n.tilt=null!=t.tilt?t.tilt:de.tilt,H(e,null,n,a)}async function ne(e,t,n,a,o){const r=b.cameraOnContentAlongViewDirection(e),{spatialReference:i,renderSpatialReference:c}=e;return ee(e,t,w.projectVectorToPoint(r.center,c,i),n,a,o)}async function ae(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=b.cameraOnContentAlongViewDirection(e);j.internalToExternal(e,i,a);const c=N(a,t)?j.OrientationMode.LOCKED:j.OrientationMode.ADJUST;return r.camera=await j.fromExtentAsync(e,n,a.heading,a.tilt,c,o),r}function oe(e,t,n,a,o){let r=0;null!=n.z?r=n.z:e.basemapTerrain&&e.elevationProvider&&(r=z.getElevationAtPoint(e.elevationProvider,n)),f.set(le,n.x,n.y,r),y.computeTranslationToOriginAndRotation(e.spatialReference,le,ue,e.renderSpatialReference),u.fromMat4(me,ue),u.transpose(me,me),v.empty(ge);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let u=0;u<i.length;u++){const t=i[u];let n=a[t[2]];isFinite(n)||(n=r),f.set(le,a[t[0]],a[t[1]],n),x.projectVectorToVector(le,e.spatialReference,le,e.renderSpatialReference),v.expandWithVec3(ge,f.transformMat3(le,le,me))}const c=v.width(ge),s=v.height(ge),l=v.depth(ge),m=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(c*c+l*l)*Math.max(g,m)+.5*s,h=.5*s*g+.5*Math.max(c,l);return Math.max(p,h)/o}async function re(e,t,n,a,o,r,i,c){c.targetGeometry=n.clone();const s=b.cameraOnContentAlongViewDirection(e),l=oe(e,s,n,a,o);j.internalToExternal(e,s,r);const u=N(r,t)?j.OrientationMode.LOCKED:j.OrientationMode.ADJUST;return c.scale=j.distanceToScale(e,l,c.targetGeometry.latitude),c.camera=await j.fromCenterScale(e,c.targetGeometry,c.scale,r,u,i),c}function ie(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),t.center&&!n.target&&(n.target=t.center)),n}function ce(e){return null!=e?.camera&&(e.rotation=D(e.camera.heading)),e}function se(e,t){const n=O;if(!t.length)return n;let a=Number.NEGATIVE_INFINITY;for(let o=0;o<t.length;o++){const e=t[o].screenSpaceBoundingRect;a=Math.max(a,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-a/Math.min(e.width,e.height)*2}const le=p.create(),ue=g.create(),me=m.create(),ge=v.create(),fe=T.create(),pe=p.create(),he=p.create(),ye=p.create(),de={heading:0,tilt:0},we=new A,xe={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let o=0;o<e.rings.length;o++){const r=e.rings[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let o=0;o<e.paths.length;o++){const r=e.paths[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,o=e.hasZ;for(let r=0;r<a.length;r++)n[0]=a[r][0],n[1]=a[r][1],o&&(n[2]=a[r][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(f.set(n,e.xmin,e.ymin,e.zmin)),t(f.set(n,e.xmax,e.ymin,e.zmin)),t(f.set(n,e.xmin,e.ymax,e.zmin)),t(f.set(n,e.xmax,e.ymax,e.zmin)),t(f.set(n,e.xmin,e.ymin,e.zmax)),t(f.set(n,e.xmax,e.ymin,e.zmax)),t(f.set(n,e.xmin,e.ymax,e.zmax)),t(f.set(n,e.xmax,e.ymax,e.zmax))):(t(f.set(n,e.xmin,e.ymin,n[2])),t(f.set(n,e.xmax,e.ymin,n[2])),t(f.set(n,e.xmin,e.ymax,n[2])),t(f.set(n,e.xmax,e.ymax,n[2])))}};e.create=J,e.fromCamera=I,e.toCameraAsync=Z,e.toCameraSync=P,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
