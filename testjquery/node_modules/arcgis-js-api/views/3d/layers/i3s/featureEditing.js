/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/asyncUtils","../../../../core/lang","../../../../layers/support/featureQueryAll"],(function(e,t,n,o){"use strict";const r={setAttribute(){},rollback(){},commit(){}};var i;function s(e,t){const o=t.attributes[e.objectIdField];if(null==o)return r;const s=e.sessions.get(o);if(s)return s;const l=n.clone(t.attributes),u=new Set,a=e.i3sOverrides.createInteractiveEditSession(o),d=new Map,f=(e,t)=>{const n=d.get(e);if(null==n){const n=t.indexOf(o);return d.set(e,n),n}return n};let c=i.EDITING;const g={setAttribute(n,o){if(c!==i.EDITING)return;const r=e.fieldsIndex.get(n);if(!r)return;const s=e.attributeStorageInfo.findIndex((e=>e.name===r.name));if(s<0)return;if(!(n in l))throw new Error(`Attribute "${n}" is not an attribute of the edited feature.`);a.setAttribute(s,o);const d=e.attributeStorageInfo[s];let g=!1;u.add(n),e.forEachNode(((n,r)=>{const i=f(n,r);if(-1===i)return;const s=e.getAttributeData(n.index);if(s){const r=s[d.name];r&&(r[i]=o,e.setAttributeData(n.index,s,t),g=!0)}})),g&&e.clearMemCache()},rollback(){if(c===i.EDITING){for(const e of u)this.setAttribute(e,l[e]);a.remove(),c=i.ROLLED_BACK,e.sessions.delete(o)}},commit(){c===i.EDITING&&(a.remove(),c=i.COMMITTED,e.sessions.delete(o))}};return e.sessions.set(o,g),g}function l(e,t,n){const{gidToFeatureInfo:o,oidToFeatureInfo:r,fieldsIndex:i,objectIdField:s,globalIdField:l,featureOrIdentifierList:u}=n;if(!n.featuresResolved&&null!=u){for(const e of u){const t={feature:null,oid:-1,gid:null};if("attributes"in e){t.feature=e;const n=e.attributes;if(null!=n)for(const e in n){if(-1!==t.oid&&null!=t.gid)break;const o=i.normalizeFieldName(e);o===s&&(t.oid=n[e]??-1),o===l&&(t.gid=n[e])}}else t.oid=e.objectId??-1,t.gid=e.globalId;null!=t.gid&&o.set(t.gid,t),-1!==t.oid&&r.set(t.oid,t)}n.featuresResolved=!0}return(-1!==e?r.get(e):null)??(null!=t?o.get(t):null)}function u(e,t,n,o,r=null,i=!0){const s=[],u={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:null==n,fieldsIndex:e.fieldsIndex,objectIdField:e.objectIdField,globalIdField:e.globalIdField,featureOrIdentifierList:n};for(const a of t){if(null!=a.error)continue;const e=a.objectId??-1,t=a.globalId,n=(-1===e||i?l(e,t,u):null)??{feature:null,oid:e,gid:t},d={oid:-1===e?n.oid:e,gid:t??n.gid,feature:n.feature,result:a};if(s.push(d),-1===d.oid&&null!=d.gid&&null!=r&&(d.oid=r.get(d.gid)??-1),-1===d.oid&&null!=d.gid){let e=o.get(d.gid);null==e&&(e=[],o.set(d.gid,e)),e.push(d)}}return s}async function a(e,t){const n=new Map,o=u(e,t.addedFeatures,t.edits?.addFeatures,n),r=u(e,t.updatedFeatures,t.edits?.updateFeatures,n),i=u(e,t.deletedFeatures,t.edits?.deleteFeatures,n,t.globalIdToObjectId,!1);return n.size>0&&await d(e,n),{adds:o.filter((e=>-1!==e.oid)),updates:r.filter((e=>-1!==e.oid)),deletes:i.filter((e=>-1!==e.oid))}}async function d(e,n){const r=e.i3sOverrides.layer.associatedLayer;if(null==r?.globalIdField)return;const i=r.createQuery(),{objectIdField:s,globalIdField:l}=r;i.where=Array.from(n.keys()).map((e=>`${l}='${e}'`)).join(" OR "),i.returnGeometry=!1,i.outFields=[s,l],i.cacheHint=!1;const u=await t.resultOrAbort(o.queryAllJSON(r,i));if(!u.ok)return;const a=u.value.features;for(const t of a){const e=t.attributes[l],o=t.attributes[s];if(null==e||null==o||-1===o)continue;const r=n.get(e);if(null!=r)for(const t of r)t.oid=o}}function f(e,t){const n=new Map,o=t.adds,r=t.updates,i=t.deletes;if(o.length>0)for(const s of o){const e=s.oid,t=s.feature;"mesh"===t?.geometry?.type&&n.set(e,t.geometry)}if(r.length>0)for(const s of r){const e=s.oid,t=s.feature;"mesh"===t?.geometry?.type&&n.set(e,t.geometry)}if(i.length>0)for(const s of i)n.set(s.oid,null);for(const[s,l]of n)e.i3sOverrides.updateGeometry(s,l)}function c(e,t){const n=I(e,t),o=g(e,t);if(0===n.size&&0===o.size)return;const r=new Map;for(let c=0;c<e.attributeStorageInfo.length;c++)r.set(e.attributeStorageInfo[c].name,c);let i=!1;n.forEach(((t,n)=>{const o=e.getAttributeData(n);let s=!1;t.forEach(((t,n)=>{const l=null!=o?o[n]:null,u=r.get(n);for(const{featureIndex:o,value:r,featureId:a}of t)l&&(l[o]=r,s=!0,i=!0),e.i3sOverrides.updateAttributeValue(a,u,r)})),s&&e.setAttributeData(n,o,null)})),i&&e.clearMemCache();const{fieldsIndex:s,i3sOverrides:l,objectIdField:u,globalIdField:a}=e,d=l.layer.associatedLayer?.infoFor3D,f=new Set(d?[...Object.values(d.assetMapFieldRoles),...Object.values(d.transformFieldRoles)]:[]);for(const[c,g]of o){l.featureAdded(c);const{attributes:e}=g;for(const t in e){if(t!==u&&t!==a&&f.has(t))continue;const n=s.normalizeFieldName(t),o=null!=n?r.get(n):null;if(null==o)continue;const i=e[t];l.updateAttributeValue(c,o,i)}}}function g(e,t){const n=new Map,o=t.adds;if(!o||0===o.length||null==e.globalIdField)return n;for(const r of o){const e=r.oid,t=r.feature;"mesh"===t?.geometry?.type&&n.set(e,t)}return n}function I(e,t){const n=t.updates;if(!n||0===n.length)return new F;const o=new F,r=new Map;for(let i=0;i<e.attributeStorageInfo.length;i++)r.set(e.attributeStorageInfo[i].name,i);return e.forEachNode(((t,r)=>{for(const i of n){if(null==i.feature)continue;const n=i.feature,s=i.oid,l=r.indexOf(s);for(const r in n.attributes){const i=e.fieldsIndex.normalizeFieldName(r),u=b(o,t.index,i),a=n.attributes[r];u.push({featureIndex:l,featureId:s,value:a})}}})),o}function b(e,t,n){const o=m(e,t),r=null!=n&&o.get(n);if(r)return r;const i=new Array;return o.set(n,i),i}function m(e,t){const n=e.get(t);if(n)return n;const o=new p;return e.set(t,o),o}!function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"}(i||(i={}));const p=Map,F=Map;e.createInteractiveEditSession=s,e.normalizeEditResultsEvent=a,e.processAttributeEdits=c,e.processGeometryEdits=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
