/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../core/asyncUtils","../../../../core/has","../../../../core/lang","../../../../core/promiseUtils","../../../../core/urlUtils","./enums","./I3SBinaryReader","./I3SMaterialUtil"],(function(e,t,r,i,n,s,o,a){"use strict";class u{constructor(e,t,r,i,n,s){if(this._streamDataController=t,this._logger=r,this._defaultGeometrySchema=i,this._requiredAttributes=n,this._options=s,this._logLayer=e,this._layerUrl=e.parsedUrl.path,this._geometryDefinitions=e.geometryDefinitions,e.materialDefinitions){const t=e.textureSetDefinitions;this._materialAndTextures=e.materialDefinitions.map((e=>a.getMaterialAndTextures(t,e)))}}_load(e,t,r){return this._streamDataController.request(e,t,r)}_loadAttribute(e,t,r){const i=`${this._layerUrl}/nodes/${e.resources.attributes}/attributes/${t.key}/0`;return this._load(i,"binary",r).then((e=>o.readBinaryAttribute(t,e)))}async loadAttributes(e,t,r){const n=await Promise.allSettled(t.map((t=>this._loadAttribute(e,t.attributeStorageInfo,r)))),s={};for(let o=0;o<t.length;++o){const r=n[o],a=t[o];if("fulfilled"===r.status){const e=r.value;s[a.name]=e}else{const t=r.reason;i.throwIfAbortError(t),this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${a.name}' on node '${e.id}'`,t)}}return s}async loadNodeData(t,r){const i=null!=this._requiredAttributes&&t.resources.attributes?e.result(this.loadAttributes(t,this._requiredAttributes,r)):null,{bufferDefinition:n,bufferIndex:s}=h(this._geometryDefinitions,t),u=!!t.resources.geometry,g=u?e.result(this._loadGeometry(t.resources.geometry,s,r)):null,m=t.resources.hasSharedResource?await this._loadShared(t,r):null,_=t.resources.materialDefinition,b=this._materialAndTextures&&null!=_&&_>=0?this._materialAndTextures[_]:null!=m?a.getMaterialAndTexturesFromShared(m):null,y=b?.material,D=b?.textures??[],x=`${t.id}`,A=!u&&this._options.loadFeatureData,p=A?await this._loadFeatureData(x,r):null,T=A?d(p):l(y),w=null==T?f(p):null,$=D.length>0?e.result(this.loadTextures(t,D,r)):null;let I=null,S=null;if(g){I=e.assertResult(await g);const t=c(this._defaultGeometrySchema,m);S=o.createGeometryDescriptor(n,t)}const U=$?e.assertResult(await $):null,E=i?e.assertResult(await i):{},k=E?{attributeData:E,loadedAttributes:this._requiredAttributes}:null;if(null!=T)return{geometryData:T,attributeDataInfo:k,geometryBuffer:I,geometryDescriptor:S,requiredTextures:D,textureData:U};if(null!=w)return{pointData:w,attributeDataInfo:k,geometryBuffer:I,geometryDescriptor:S,requiredTextures:D,textureData:U};throw new Error}static _addAbsoluteHrefTexture(e,t){const r=e.textureDefinitions;if(null!=r)for(const i of Object.keys(r))for(const e of r[i].images)Array.isArray(e.href)?e.hrefConcat=e.href.map((e=>n.makeAbsolute(e,t))):e.hrefConcat=n.makeAbsolute(e.href,t)}static _fixTextureEncodings(e){const t=e.textureDefinitions;if(null!=t)for(const r in t){const e=t[r];if(Array.isArray(e.encoding))for(let t=0;t<e.encoding.length;t++){const r=e.encoding[t];"data:"===r.substring(0,5)&&(e.encoding[t]=r.substring(5))}else{const t=e.encoding;"data:"===t.substring(0,5)&&(e.encoding=t.substring(5))}}}_loadShared(e,t){const r=`${this._layerUrl}/nodes/${e.resources.geometry}/shared`;return this._load(r,"json",t).then((e=>(u._fixTextureEncodings(e),u._addAbsoluteHrefTexture(e,r),e)))}_loadTexture(e,t,r,i,n,o){let a=!1;return n===s.TextureEncoding.DDS_S3TC||n===s.TextureEncoding.KTX2||n===s.TextureEncoding.Basis?this._load(e,"binary",o).then((e=>({id:t,usage:r,data:e,encoding:n,downsampled:a}))):this._load(e,"image",o).then((e=>{let s=e;const o=4096,u=2;if(i&&e.width*e.height>=o){const t=Math.ceil(e.width/u),r=Math.ceil(e.height/u),i=document.createElement("canvas");i.width=t,i.height=r;i.getContext("2d").drawImage(e,0,0,t,r),s=i,a=!0}return{id:t,usage:r,data:s,encoding:n,downsampled:a}}))}loadTextures(e,t,r){const i=!!this._options.uncompressedTextureDownsamplingEnabled,n=this._options.textureUsageMask;return Promise.all(t.map((t=>{if(0==(t.usage&n))return null;const s=a.selectEncoding(t.encodings,this._options.textureEncodings);if(null==s)return this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${e.id}`),Promise.reject();const o=e.resources.texture||e.id,u=`${this._layerUrl}/nodes/${o}/textures/${s.name}`;return this._loadTexture(u,t.id,t.usage,i,s.encoding,r)})))}_loadFeatureData(e,t){const r=`${this._layerUrl}/nodes/${e}/features/0`;return this._load(r,"json",t)}_loadGeometry(e,t,r){const i=`${this._layerUrl}/nodes/${e}/geometries/${t}`;return this._load(i,"binary",r)}}function l(e){return{featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:e}}],featureDataPosition:[0,0,0]}}function d(e){if(!e)return null;for(const t of e.featureData){const e=t.geometries;if(null!=e)for(const r of e)return{featureIds:[t.id],featureDataPosition:t.position,geometries:[r]}}return null}function f(e){if(!e)return null;const t=new Array;for(const r of e.featureData)null!=r.position&&t.push({featureIds:[r.id],featureDataPosition:r.position,geometries:[]});return t}function c(e,t){if(!e||!t?.materialDefinitions)return e;const i=Object.keys(t.materialDefinitions)[0];return!t.materialDefinitions[i].params.vertexRegions&&e.vertexAttributes.region&&delete(e=r.clone(e)).vertexAttributes.region,e}function h(e,r){const i={bufferDefinition:null,bufferIndex:0},n=r.resources.geometryDefinition;if(null==e||null==n||n<0)return i;const s=n>=0?e[n].geometryBuffers:null;if(null==s)return i;for(let o=0;o<s.length;o++){const e=s[o];if(null==e.compressedAttributes)i.bufferIndex=o,i.bufferDefinition=s[o];else if("draco"===e.compressedAttributes.encoding&&!t("disable-feature:i3s-draco"))return i.bufferIndex=o,i.bufferDefinition=e,i}return i}return u}));
