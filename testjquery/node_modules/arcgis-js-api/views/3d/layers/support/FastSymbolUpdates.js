/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/mathUtils","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../renderers/support/lengthUtils","../../support/debugFlags","../../webgl-engine/core/shaderModules/interfaces"],(function(e,t,o,i,n,s,r,a,l,u,f,c){"use strict";var p,d;e.FastSizeType=void 0,(p=e.FastSizeType||(e.FastSizeType={}))[p.Undefined=0]="Undefined",p[p.DefinedSize=1]="DefinedSize",p[p.DefinedScale=2]="DefinedScale",e.FastRotationType=void 0,(d=e.FastRotationType||(e.FastRotationType={}))[d.Undefined=0]="Undefined",d[d.DefinedAngle=1]="DefinedAngle";class z{constructor(e){this.field=e}}class v extends z{constructor(t){super(t),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[e.FastSizeType.Undefined,e.FastSizeType.Undefined,e.FastSizeType.Undefined]}}class S extends z{constructor(e){super(e),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0]}}class y extends z{constructor(e){super(e),this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class m extends z{constructor(e){super(e),this.offset=[0,0,0],this.factor=[1,1,1],this.type=[0,0,0]}}class h{}function x(e){return null!=e}function F(e){return"number"==typeof e}function b(e){return"string"==typeof e}function g(e){return null==e||b(e)}function T(e,t){e&&e.push(t)}function C(e,t,o,i=r.create()){const n=e||0,a=t||0,l=o||0;return 0!==n&&s.rotateZ(i,i,-n/180*Math.PI),0!==a&&s.rotateX(i,i,a/180*Math.PI),0!==l&&s.rotateY(i,i,l/180*Math.PI),i}function V(t,o,i,n,s){const r=t.minSize,a=t.maxSize;if(t.expression)return T(s,"Could not convert size info: expression not supported"),!1;if(t.useSymbolValue){const t=n.symbolSize[i];return o.minSize[i]=t,o.maxSize[i]=t,o.offset[i]=o.minSize[i],o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0}if(x(t.field))return x(t.stops)?2===t.stops.length&&F(t.stops[0].size)&&F(t.stops[1].size)?(D(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,o,i),o.type[i]=e.FastSizeType.DefinedSize,!0):(T(s,"Could not convert size info: stops only supported with 2 elements"),!1):F(r)&&F(a)&&x(t.minDataValue)&&x(t.maxDataValue)?(D(r,a,t.minDataValue,t.maxDataValue,o,i),o.type[i]=e.FastSizeType.DefinedSize,!0):"unknown"===t.valueUnit?(T(s,"Could not convert size info: proportional size not supported"),!1):null!=u.meterIn[t.valueUnit]?(o.minSize[i]=-1/0,o.maxSize[i]=1/0,o.offset[i]=0,o.factor[i]=1/u.meterIn[t.valueUnit],o.type[i]=e.FastSizeType.DefinedSize,!0):(T(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!x(t.field)){if(t.stops?.[0]&&F(t.stops[0].size))return o.minSize[i]=t.stops[0].size,o.maxSize[i]=t.stops[0].size,o.offset[i]=o.minSize[i],o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0;if(F(r))return o.minSize[i]=r,o.maxSize[i]=r,o.offset[i]=r,o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0}return T(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function D(e,t,o,i,n,s){const r=Math.abs(i-o)>0?(t-e)/(i-o):0;n.minSize[s]=r>0?e:t,n.maxSize[s]=r>0?t:e,n.offset[s]=e-o*r,n.factor[s]=r}function U(e,t,o,i){if(e.normalizationField||e.valueRepresentation)return T(i,"Could not convert size info: unsupported property"),null;if(!g(e.field))return T(i,"Could not convert size info: field is not a string"),null;if(t.size){if(e.field)if(t.size.field){if(e.field!==t.size.field)return T(i,"Could not convert size info: multiple fields in use"),null}else t.size.field=e.field}else t.size=new v(e.field);let n;switch(e.axis){case"width":return n=V(e,t.size,0,o,i),n?t:null;case"height":return n=V(e,t.size,2,o,i),n?t:null;case"depth":return n=V(e,t.size,1,o,i),n?t:null;case"width-and-depth":return n=V(e,t.size,0,o,i),n&&V(e,t.size,1,o,i),n?t:null;case null:case void 0:case"all":return n=V(e,t.size,0,o,i),n=n&&V(e,t.size,1,o,i),n=n&&V(e,t.size,2,o,i),n?t:null;default:return T(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}function M(t,o,i){for(let s=0;s<3;++s){let i=o.unitInMeters;t.type[s]===e.FastSizeType.DefinedSize&&(i*=o.modelSize[s],t.type[s]=e.FastSizeType.DefinedScale),t.minSize[s]=t.minSize[s]/i,t.maxSize[s]=t.maxSize[s]/i,t.offset[s]=t.offset[s]/i,t.factor[s]=t.factor[s]/i}let n;if(t.type[0]!==e.FastSizeType.Undefined)n=0;else if(t.type[1]!==e.FastSizeType.Undefined)n=1;else{if(t.type[2]===e.FastSizeType.Undefined)return T(i,"No size axis contains a valid size or scale"),!1;n=2}for(let s=0;s<3;++s)t.type[s]===e.FastSizeType.Undefined&&(t.minSize[s]=t.minSize[n],t.maxSize[s]=t.maxSize[n],t.offset[s]=t.offset[n],t.factor[s]=t.factor[n],t.type[s]=t.type[n]);return!0}function w(e,t,o){e[4*t]=o.r/255,e[4*t+1]=o.g/255,e[4*t+2]=o.b/255,e[4*t+3]=o.a}function I(e,t,o){if(e.normalizationField)return T(o,"Could not convert color info: unsupported property"),null;if(b(e.field)){if(!e.stops)return T(o,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return T(o,"Could not convert color info: too many color stops"),null;t.color=new S(e.field);const i=e.stops;for(let e=0;e<8;++e){const o=i[Math.min(e,i.length-1)];t.color.values[e]=o.value,w(t.color.colors,e,o.color)}}}else{if(!(e.stops&&e.stops.length>=0))return T(o,"Could not convert color info: no field and no colors/stops"),null;{const o=e.stops&&e.stops.length>=0&&e.stops[0].color;t.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.color.values[e]=1/0,w(t.color.colors,e,o)}}return t}function P(e,t,o){if(e.normalizationField)return T(o,"Could not convert opacity info: unsupported property"),null;if(b(e.field)){if(!e.stops)return T(o,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return T(o,"Could not convert opacity info: too many opacity stops"),null;t.opacity=new y(e.field);const i=e.stops;for(let e=0;e<8;++e){const o=i[Math.min(e,i.length-1)];t.opacity.values[e]=o.value,t.opacity.opacityValues[e]=o.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return T(o,"Could not convert opacity info: no field and no opacities/stops"),null;{const o=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;t.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.opacity.values[e]=1/0,t.opacity.opacityValues[e]=o}}return t}function k(e,t,o){const i=2===o&&"arithmetic"===e.rotationType;t.offset[o]=i?90:0,t.factor[o]=i?-1:1,t.type[o]=1}function R(e,t,o){if(!b(e.field))return T(o,"Could not convert rotation info: field is not a string"),null;if(t.rotation){if(e.field)if(t.rotation.field){if(e.field!==t.rotation.field)return T(o,"Could not convert rotation info: multiple fields in use"),null}else t.rotation.field=e.field}else t.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return k(e,t.rotation,0),t;case"roll":return k(e,t.rotation,1),t;case null:case void 0:case"heading":return k(e,t.rotation,2),t;default:return T(o,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}class A{constructor(e,t=[1,1,1],o=[1,1,1],i=1,n=[0,0,0],s=[1,1,1],r=[0,0,0]){this.supports=e,this.modelSize=t,this.symbolSize=o,this.unitInMeters=i,this.anchor=n,this.scale=s,this.rotation=r}}function E(e,t,o){if(!e)return null;const i=e.reduce(((e,i)=>{if(!e)return e;if(i.valueExpression)return T(o,"Could not convert visual variables: arcade expressions not supported"),null;switch(i.type){case"size":return t.supports.size?U(i,e,t,o):e;case"color":return t.supports.color?I(i,e,o):e;case"opacity":return t.supports.opacity?P(i,e,o):null;case"rotation":return t.supports.rotation?R(i,e,o):e;default:return null}}),new h);return!(e.length>0&&i)||i.size||i.color||i.opacity||i.rotation?i?.size&&!M(i.size,t,o)?null:i:null}class O{constructor(e,t,o){this.visualVariables=e,this.materialParameters=t,this.requiresShaderTransformation=o}}function _(e,t){if(!e)return null;if(f.debugFlags.TESTS_DISABLE_FAST_UPDATES)return null;const o=E(e.visualVariables,t);return o?new O(o,j(o,t),!!o.size):null}function q(e,t,o){if(!t||!e)return!1;const i=e.visualVariables,n=E(t.visualVariables,o);return!!n&&(!!(N(i.size,n.size,"size")&&N(i.color,n.color,"color")&&N(i.rotation,n.rotation,"rotation")&&N(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=j(n,o),e.requiresShaderTransformation=!!n.size,!0))}function N(e,t,o){if(!!e!=!!t)return!1;if(e&&e.field!==t?.field)return!1;if(e&&"rotation"===o){const o=e,i=t;for(let e=0;e<3;e++)if(o.type[e]!==i.type[e]||o.offset[e]!==i.offset[e]||o.factor[e]!==i.factor[e])return!1}return!0}class $ extends c.NoParameters{constructor(e){super(),this.vvSize=e?.size??null,this.vvColor=e?.color??null,this.vvOpacity=e?.opacity??null}}function j(e,t){const o=new $(e);return o.vvSize&&(o.vvSymbolAnchor=t.anchor,s.identity(G),C(t.rotation[2],t.rotation[0],t.rotation[1],G),o.vvSymbolRotationMatrix=o.vvSymbolRotationMatrix||n.create(),i.fromMat4(o.vvSymbolRotationMatrix,G)),o}function B(e,t,i){if(!e.vvSize)return i;s.copy(Y,i);const n=e.vvSymbolRotationMatrix;s.set(G,n[0],n[1],n[2],0,n[3],n[4],n[5],0,n[6],n[7],n[8],0,0,0,0,1),s.multiply(Y,Y,G);for(let s=0;s<3;++s){const i=e.vvSize.offset[s]+t[0]*e.vvSize.factor[s];Z[s]=o.clamp(i,e.vvSize.minSize[s],e.vvSize.maxSize[s])}return s.scale(Y,Y,Z),s.translate(Y,Y,e.vvSymbolAnchor),Y}function L(e,t,i){if(!t.vvSize)return a.set(e,1,1,1),e;for(let n=0;n<3;++n){const s=t.vvSize.offset[n]+i[0]*t.vvSize.factor[n];e[n]=o.clamp(s,t.vvSize.minSize[n],t.vvSize.maxSize[n])}return e}function X(e,t){const o=null==e?0:t.attributes[e];return"number"==typeof o&&isFinite(o)?o:0}const Y=r.create(),Z=l.create(),G=r.create();e.ConvertOptions=A,e.FastColorInfo=S,e.FastOpacityInfo=y,e.FastRotationInfo=m,e.FastSizeInfo=v,e.FastSymbolUpdatesState=O,e.FastVisualVariables=h,e.VisualVariablesParameters=$,e.convertVisualVariables=E,e.evaluateModelTransform=B,e.evaluateModelTransformScale=L,e.getAttributeValue=X,e.getMaterialParameters=j,e.initFastSymbolUpdatesState=_,e.updateFastSymbolUpdatesState=q,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
