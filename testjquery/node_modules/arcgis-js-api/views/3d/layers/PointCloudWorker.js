/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../core/arrayUtils","../../../core/typedArrayUtil","../../../chunks/quat","../../../chunks/quatf64","../../../chunks/vec3","../../../chunks/vec3f32","../../../geometry/SpatialReference","../../../geometry/projection/projectBuffer","./i3s/PointCloudWorkerUtil"],(function(t,e,r,a,n,o,u,f,i){"use strict";class s{transform(t){const r=this._transform(t),a=[r.points.buffer,r.rgb.buffer];null!=r.pointIdFilterMap&&a.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&e.isArrayBuffer(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&a.push(n.values.buffer);return Promise.resolve({result:r,transferList:a})}_transform(e){const r=i.readGeometry(e.schema,e.geometryBuffer);let a=r.length/3,n=null;const o=new Array,f=i.getAttributeValues(e.primaryAttributeData,r,a);null!=e.primaryAttributeData&&f&&o.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:f});const s=i.getAttributeValues(e.modulationAttributeData,r,a);null!=e.modulationAttributeData&&s&&o.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:s});let l=i.evaluateRenderer(e.rendererInfo,f,s,a);if(e.filterInfo&&e.filterInfo.length>0&&null!=e.filterAttributesData){const u=e.filterAttributesData.filter(t.isSome).map((t=>{const e=i.getAttributeValues(t,r,a),n={attributeInfo:t.attributeInfo,values:e};return o.push(n),n}));n=new Uint32Array(a),a=i.filterInPlace(r,l,n,e.filterInfo,u)}for(const t of e.userAttributesData){const e=i.getAttributeValues(t,r,a);o.push({attributeInfo:t.attributeInfo,values:e})}3*a<l.length&&(l=new Uint8Array(l.buffer.slice(0,3*a))),this._applyElevationOffsetInPlace(r,a,e.elevationOffset);const b=this._transformCoordinates(r,a,e.obb,u.fromJSON(e.inSR),u.fromJSON(e.outSR));return{obb:e.obb,points:b,rgb:l,attributes:o,pointIdFilterMap:n}}_transformCoordinates(t,e,a,u,i){if(!f.projectBuffer(t,u,0,t,i,0,e))throw new Error("Can't reproject");const s=o.fromValues(a.center[0],a.center[1],a.center[2]),b=o.create(),c=o.create();r.conjugate(l,a.quaternion);const h=new Float32Array(3*e);for(let r=0;r<e;r++)b[0]=t[3*r]-s[0],b[1]=t[3*r+1]-s[1],b[2]=t[3*r+2]-s[2],n.transformQuat(c,b,l),a.halfSize[0]=Math.max(a.halfSize[0],Math.abs(c[0])),a.halfSize[1]=Math.max(a.halfSize[1],Math.abs(c[1])),a.halfSize[2]=Math.max(a.halfSize[2],Math.abs(c[2])),h[3*r]=b[0],h[3*r+1]=b[1],h[3*r+2]=b[2];return h}_applyElevationOffsetInPlace(t,e,r){if(0!==r)for(let a=0;a<e;a++)t[3*a+2]+=r}}const l=a.create();function b(){return new s}return b}));
