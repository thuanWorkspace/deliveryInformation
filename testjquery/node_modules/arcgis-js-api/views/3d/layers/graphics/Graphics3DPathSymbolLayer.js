/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/Error","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection/projectBuffer","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/DoubleArray","./elevationAlignmentUtils","./Graphics3DObject3DGraphicLayer","./Graphics3DPathSymbolLayerConstants","./Graphics3DSymbolLayer","./graphicUtils","./interfaces","../support/FastSymbolUpdates","../../support/ElevationProvider","../../webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/Path","../../webgl-engine/lib/PathBuilder","../../webgl-engine/lib/PathCapBuilder","../../webgl-engine/lib/PathExtruder","../../webgl-engine/lib/PathGeometry","../../webgl-engine/lib/PathGeometryData","../../webgl-engine/lib/pathGeometryUtils","../../webgl-engine/lib/PathProfile","../../webgl-engine/lib/PathVertex","../../webgl-engine/lib/VertexAttribute","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/PathMaterial"],(function(e,t,i,r,a,s,n,o,l,h,c,p,d,u,m,f,y,b,g,_,v,x,w,P,S,D,C,A,V,R,U,E,L,B,G){"use strict";const k=["polyline"];class z extends f.Graphics3DSymbolLayer{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=n.fromValues(1,1),this._upVectorAlignment=A.UpVectorAlignment.Path,this._stencilWidth=.1,this.usedMemory=0,this.ensureDrapedStatus(!1)}async doLoad(){const e=null!=this.symbolLayer.width?this.symbolLayer.width:this.symbolLayer.height,t=null!=this.symbolLayer.height?this.symbolLayer.height:e;this._vvConvertOptions=new g.ConvertOptions({size:!0,color:!0,rotation:!1,opacity:!0},[1,1,1],[e,1,t],this._context.renderCoordsHelper.unitInMeters),this._fastUpdates=this._context.renderer?.visualVariables?.length>0?g.initFastSymbolUpdatesState(this._context.renderer,this._vvConvertOptions):null;const r=this.symbolLayer.anchor||"center";this._upVectorAlignment="heading"===this.symbolLayer.profileRotation?A.UpVectorAlignment.World:A.UpVectorAlignment.Path;const a=this.symbolLayer.profile||"circle";switch(a){default:case"circle":this._profile=U.circleProfiles[r];break;case"quad":this._profile=U.quadProfiles[r]}switch(this.symbolLayer.join){case"round":this._extruder=new C.MiterExtruder(0,m.pathNumRoundJoinSubdivisions);break;case"bevel":this._extruder=new C.MiterExtruder(0,1);break;case"miter":this._extruder=new C.MiterExtruder(.8*Math.PI,1);break;default:this._extruder=new C.SimpleExtruder}const o=this.symbolLayer.cap||"butt";switch(o){case"none":this._startCap=new D.NoCapBuilder,this._endCap=new D.NoCapBuilder;break;case"butt":default:this._startCap=new D.TriangulationCapBuilder(this._profile,0),this._endCap=new D.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new D.TriangulationCapBuilder(this._profile,-.5),this._endCap=new D.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===a;this._startCap=new D.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:m.pathNumRoundCapExtrusionSubdivisions}),this._endCap=new D.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:m.pathNumRoundCapExtrusionSubdivisions});break}}const h=this.symbolLayer?.material?.color,c=this._getCombinedOpacityAndColor(h),p=l.fromArray(c),d=c[3],u=d<1||this.needsDrivenTransparentPass,f={diffuse:p,ambient:p,opacity:d,transparent:u,hasVertexColors:!1,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:u||"none"===o?x.CullFaceOptions.None:x.CullFaceOptions.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(s.set(this._intrinsicSize,e,t),!y.isValidSize(this._intrinsicSize[0])||!y.isValidSize(this._intrinsicSize[1])))throw new i("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");if(this._fastUpdates?.visualVariables.size||s.scale(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates){const e={...f,...this._fastUpdates.materialParameters,size:n.fromArray(this._intrinsicSize)};this._materials[0]=new G.PathMaterial(e)}else f.hasVertexColors=this._drivenProperties.color||this._drivenProperties.opacity,f.normalType=v.NormalType.Compressed,this._materials[0]=new B.DefaultMaterial(f);this._materials[0].setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._materials[0])}destroy(){super.destroy(),this._context.stage.remove(this._materials[0]),this._materials[0]=null,this._materials.length=0}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,k,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t),r=e.renderingInfo;return this._createAs3DShape(t,r,i,t.uid)}layerOpacityChanged(){const e=this.symbolLayer?.material?.color,t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;this._materials[0]?.setParameters({opacity:t,transparent:i})}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,d.needsElevationUpdates3D)}slicePlaneEnabledChanged(){return this._materials[0]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._materials[0]?.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}applyRendererDiff(e,t){for(const i in e.diff){if("visualVariables"!==i)return b.ApplyRendererDiffResult.RecreateSymbol;if(!g.updateFastSymbolUpdatesState(this._fastUpdates,t,this._vvConvertOptions))return b.ApplyRendererDiffResult.RecreateSymbol;this._materials[0]?.setParameters(this._fastUpdates.materialParameters)}return b.ApplyRendererDiffResult.FastUpdate}_getVertexData(e){let t=0;const i=e.paths,r=[],a=e.spatialReference,s=this._context.elevationProvider.spatialReference,n=this._context.renderCoordsHelper.spatialReference;for(const h of i)t+=h.length;const o=p.newDoubleArray(3*t);let l,c=0;for(const h of i){r.push({offset:c,numVertices:h.length});for(const t of h)o[c++]=t[0],o[c++]=t[1],o[c++]=e.hasZ?t[2]:0}return null==s||a.equals(s)||h.projectBuffer(o,a,0,o,s,0,t)?(null==s||s.equals(n)?l=p.doubleArrayFrom(o):(l=p.newDoubleArray(3*t),h.projectBuffer(o,s,0,l,n,0,t)),{pathVertexDataInfos:r,vertexDataES:o,vertexDataRS:l}):null}_createAs3DShape(e,t,i,s){this.usedMemory=0;const n=e.geometry,l=this._getVertexData(n);if(null==l)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(0===l.pathVertexDataInfos.length)return 0!==n.paths.length&&n.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"),null;const h=new Array,p=n.spatialReference,m=c.create(),f=this._context.renderCoordsHelper,y=new _.SamplePosition(l.vertexDataES);for(const u of l.pathVertexDataInfos){const n=u.numVertices;if(n<2)continue;const b=u.offset;if(null!=this._context.clippingExtent&&(c.empty(m),c.expandWithBuffer(m,l.vertexDataES,b,n),!c.intersectsClippingArea(m,this._context.clippingExtent)))continue;const _=new Array,v=b+3*n;for(let e=b;e<v;e+=3){y.offset=e;const t=d.evaluateElevationAlignmentAtPoint(y,this._context.elevationProvider,i,f);o.set(j,l.vertexDataRS[e],l.vertexDataRS[e+1],l.vertexDataRS[e+2]),f.setAltitude(j,t),l.vertexDataRS[e]=j[0],l.vertexDataRS[e+1]=j[1],l.vertexDataRS[e+2]=j[2],_.push(E.newPathVertex(this._upVectorAlignment))}const x=new P.Path(_,l.vertexDataES,l.vertexDataRS,b);I(x,this._upVectorAlignment,this._context.renderCoordsHelper);const w=new S.PathBuilder(x,this._profile,this._extruder,this._startCap,this._endCap);let D=null;if(this._fastUpdates){const t=this._fastUpdates.visualVariables,i=g.getAttributeValue(t.size?.field,e)??0,r=g.getAttributeValue(t.color?.field,e)??0,a=g.getAttributeValue(t.opacity?.field,e)??0;D=new V.FastUpdatePathGeometry(w,i,r,a)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];if(this._drivenProperties.size){const i=t.size;e[0]*=O(i[0],"symbol-value"===i[2]?this.symbolLayer.height||0:i[2],this.symbolLayer.width||0),e[1]*=O(i[2],"symbol-value"===i[0]?this.symbolLayer.width||0:i[0],this.symbolLayer.height||0)}let i;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const r=new V.StaticPathGeometry(w);r.bake(e),i&&r.bakeVertexColors(i),D=r}const C=D.createGeometryData(),R=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:s,layerUid:this._context.layer.uid}),U=new A.PathGeometry(this._materials[0],C,D,p,this._stencilWidth,R);U.transformation=r.translate(a.create(),a.IDENTITY,w.path.origin),h.push(U),this.usedMemory+=w.usedMemory}if(0===h.length)return null;const b=new w.Object3D({geometries:h,layerUid:this._context.layer.uid,graphicUid:s}),v=new u.Graphics3DObject3DGraphicLayer(this,b,h,null,null,((e,t,i,r,a)=>T(e,t,r,a,this._upVectorAlignment)),i);return v.alignedSampledElevation=0,v.needsElevationUpdates=d.needsElevationUpdates3D(i.mode),v}}function I(e,t,i){const{origin:r,positions:a}=e;let s=e.offset;switch(t){default:case A.UpVectorAlignment.World:for(const t of e.vertices)j[0]=a[s++]+r[0],j[1]=a[s++]+r[1],j[2]=a[s++]+r[2],i.worldUpAtPosition(j,j),t.setFrameFromUpVector(j);break;case A.UpVectorAlignment.Path:j[0]=a[s]+r[0],j[1]=a[s+1]+r[1],j[2]=a[s+2]+r[2],i.worldUpAtPosition(j,j),R.computeMinimumRotationTangentFrame(e,j)}}function O(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function M(e,t,i,r){let a=0;const{origin:s,vertices:n,positions:l,positionsES:h}=e,c=e.offset+3*n.length;for(let p=e.offset;p<c;p+=3)o.set(j,h[p],h[p+1],h[p+2]),i(j,F),a+=F.sampledElevation,j[0]=l[p]+s[0],j[1]=l[p+1]+s[1],j[2]=l[p+2]+s[2],r.setAltitude(j,F.z),l[p]=j[0]-s[0],l[p+1]=j[1]-s[1],l[p+2]=j[2]-s[2];return e.updatePathVertexInformation(),a/n.length}function T(e,t,i,r,a){const s=e.stageObject,n=s.geometries;let o=0;for(const l of n){if(!A.isPathGeometry(l))continue;const e=l.path,n=e.builder.path;o+=M(n,t,i,r),a!==A.UpVectorAlignment.World&&I(n,a,r),e.onPathChanged(l),l.invalidateBoundingInfo(),s.geometryVertexAttributeUpdated(l,L.VertexAttribute.POSITION)}return o/n.length}const j=l.create(),F=new d.SampleElevationInfo;e.Graphics3DPathSymbolLayer=z,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
