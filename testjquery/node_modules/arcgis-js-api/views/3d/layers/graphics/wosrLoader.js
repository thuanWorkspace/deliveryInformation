/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../request","../../../../core/asyncUtils","../../../../core/byteSizeEstimations","../../../../core/Error","../../../../core/Logger","../../../../core/NestedMap","../../../../core/promiseUtils","../../../../core/Version","../../../../chunks/vec3f64","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/Indices","../../../../support/requestImageUtils","../../webgl-engine/lib/Attribute","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Texture","../../webgl-engine/lib/VertexAttribute","../../webgl-engine/materials/DefaultMaterial","../../../webgl/enums"],(function(e,t,r,n,a,s,o,i,u,l,c,p,d,f,m,g,y,b,x,h){"use strict";const w=s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");async function A(e,t){const r=await v(e,t),a=await O(r.textureDefinitions??{},t);let s=0;for(const n in a)if(a.hasOwnProperty(n)){const e=a[n];s+=e?.image?e.image.width*e.image.height*4:0}return{resource:r,textures:a,size:s+n.estimateNestedObjectSize(r)}}async function v(e,n){const a=n?.streamDataRequester;if(a)return M(e,a,n);const s=await r.result(t(e,n));if(!0===s.ok)return s.value.data;i.throwIfAbortError(s.error),I(s.error)}async function M(e,t,n){const a=await r.result(t.request(e,"json",n));if(!0===a.ok)return a.value;i.throwIfAbortError(a.error),I(a.error.details.url)}function I(e){throw new a("",`Request for object resource failed: ${e}`)}function T(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(w.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(w.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(w.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(w.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else w.warn("Indexed geometries must specify faces"),n=!1;break}default:w.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(w.warn("Geometry requires material"),n=!1);const a=e.params.vertexAttributes;for(const s in a){a[s].values||(w.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function P(e,t){const r=new Array,n=new Array,a=new Array,s=new o.NestedMap,i=e.resource,c=u.Version.parse(i.version||"1.0","wosr");D.validate(c);const d=i.model.name,h=i.model.geometries,w=i.materialDefinitions??{},A=e.textures;let v=0;const M=new Map;for(let o=0;o<h.length;o++){const e=h[o];if(!T(e))continue;const i=k(e),u=e.params.vertexAttributes,c=[],d=t=>{if("PerAttributeArray"===e.params.topology)return null;const r=e.params.faces;for(const e in r)if(e===t)return r[e].values;return null},I=u[b.VertexAttribute.POSITION],P=I.values.length/I.valuesPerElement;for(const t in u){const e=u[t],r=e.values,n=d(t)??p.getContinuousIndexArray(P);c.push([t,new f.Attribute(r,n,e.valuesPerElement,!0)])}const E=i.texture,O=A&&A[E];if(O&&!M.has(E)){const{image:e,parameters:t}=O,r=new y.Texture(e,t);n.push(r),M.set(E,r)}const D=M.get(E),q=D?D.id:void 0,R=i.material;let V=s.get(R,E);if(null==V){const e=w[R.substring(R.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=O&&O.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,a=O?U(O.alphaChannelUsage):void 0,o={ambient:l.fromArray(e.diffuse),diffuse:l.fromArray(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:a,textureAlphaCutoff:.33,textureId:q,initTextureTransparent:!0,doubleSided:!0,cullFace:m.CullFaceOptions.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:O?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(o,t.materialParameters),V=new x.DefaultMaterial(o),s.set(R,E,V)}a.push(V);const C=new g.Geometry(V,c);v+=c.find((e=>e[0]===b.VertexAttribute.POSITION))?.[1]?.indices.length??0,r.push(C)}return{engineResources:[{name:d,stageResources:{textures:n,materials:a,geometries:r},pivotOffset:i.model.pivotOffset,numberOfVertices:v,lodThreshold:null}],referenceBoundingBox:E(r)}}function E(e){const t=c.empty();return e.forEach((e=>{const r=e.boundingInfo;null!=r&&(c.expandWithVec3(t,r.bbMin),c.expandWithVec3(t,r.bbMax))})),t}async function O(e,t){const r=new Array;for(const s in e){const n=e[s],a=n.images[0].data;if(!a){w.warn("Externally referenced texture data is not yet supported");continue}const o=n.encoding+";base64,"+a,i="/textureDefinitions/"+s,u="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",l={noUnpackFlip:!0,wrap:{s:h.TextureWrapMode.REPEAT,t:h.TextureWrapMode.REPEAT},preMultiplyAlpha:U(u)!==m.AlphaDiscardMode.Opaque},c=null!=t&&t.disableTextures?Promise.resolve(null):d.requestImage(o,t);r.push(c.then((e=>({refId:i,image:e,parameters:l,alphaChannelUsage:u}))))}const n=await Promise.all(r),a={};for(const s of n)a[s.refId]=s;return a}function U(e){switch(e){case"mask":return m.AlphaDiscardMode.Mask;case"maskAndTransparency":return m.AlphaDiscardMode.MaskBlend;case"none":return m.AlphaDiscardMode.Opaque;default:return m.AlphaDiscardMode.Blend}}function k(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const D=new u.Version(1,2,"wosr");e.createTextureResources=O,e.load=A,e.processLoadResult=P,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
