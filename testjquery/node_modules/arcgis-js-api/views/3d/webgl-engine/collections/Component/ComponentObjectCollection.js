/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/has","../../../../../core/Logger","../../../../../core/PooledArray","../../../../../core/typedArrayUtil","../../../../../chunks/mat3","../../../../../chunks/mat3f32","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/support/Indices","../../../../../chunks/vec32","../../../../../chunks/vec33","../../../../ViewingMode","../../../layers/support/symbolColorUtils","../../../support/orientedBoundingBox","../../../support/buffer/glUtil","../../../support/buffer/InterleavedLayout","./ComponentData","./ComponentObject","./IntersectionGeometry","./Renderable","./RenderGeometry","./RenderSubmitSystem","./SourceGeometry","./UniformComponentParameters","./Material/ComponentMaterial","./Material/ComponentTechnique","./Material/shader/ComponentData.glsl","../../lib/ComponentUtils","../../lib/Util","../../lib/VertexAttribute","../../lib/verticalOffsetUtils","../../lib/edgeRendering/bufferLayouts","../../lib/edgeRendering/edgeProcessing","../../lib/TextureBackedBuffer/BufferManager","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,n,o,r,i,s,a,c,l,m,u,f,b,p,h,g,d,y,C,v,O,M,_,w,S,x,A,j,D,P,I,L,B,U,V,E,R){"use strict";const T=n.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class k{constructor(e,n){this._renderManager=e,this._viewingMode=n,this._objects=[new o,new o],this._renderSubmit=new M.RenderSubmitSystem(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=t("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new U.BufferManager(e.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){D.assert(0===this._objects[y.State.Hidden].length&&0===this._objects[y.State.Visible].length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy();const e=this._objects.flatMap((e=>e.toArray()));for(const t of e)t?.destroy()}createObject(e){const t=new y.ComponentObject;return t.toMapSpace=e.toMapSpace,t.transform=e.transform,t.obb=p.clone(e.obb),t.components=new d(this._componentBufferManager,l.compactIndices(e.geometry.componentOffsets)),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new C(e.geometry.positionData,t.components),this._objects[t.visible].push(t),t}destroyObject(e){const t=e;this._objects[t.visible].removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const n=e;t!==n.visible&&(this._objects[n.visible].removeUnordered(n),this._objects[t].push(n),n.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=a.squaredDistance(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const n=e.renderable.material;t(n),n.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const n=e;n.components.visibility.reset(t),n.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,n=t.components.visibility.componentCount();return{visible:n,invisible:t.components.count-n}}setComponentData(e,t){const n=e,o=n.renderable.material,r=n.components,i=r.materialDataBuffer,s=r.materialDataIndices,a=new w.UniformComponentParameters,c=i.textureBuffer,l=new Uint8Array(4),m=new Uint32Array(l.buffer);let u=0,f=0,h=0,g=r.verticalOffsets,d=1/0,y=-1/0,C=!1,v=!1,O=0;for(let p=0;p<r.count;p++){t(p,a),u+=+(a.externalColor[3]<1),f+=+(a.externalColorMixMode===b.ColorMixModeEnum.Replace&&1===a.externalColor[3]),h+=+a.castShadows,b.encodeSymbolColor(a.externalColor,a.externalColorMixMode,l),l[2]=254&l[2]|+a.castShadows,c.setData(s[p],0,l[0],l[1],l[2],l[3]),C||(C=p>0&&O!==m[0]),O=m[0],v||(v=0!==a.elevationOffset),v&&null==g&&(g=new Array(p).fill(0)),null!=g&&(g[p]=a.elevationOffset),d=Math.min(d,a.elevationOffset),y=Math.max(y,a.elevationOffset),A.encodeElevationOffset(a.elevationOffset,l),c.setData(s[p],1,l[0],l[1],l[2],l[3]);const e=a.objectAndLayerIdColor;null!=e&&c.setData(s[p],2,e[0],e[1],e[2],e[3]),a.pickable!==j.getVisibility(r.pickability,p)&&(r.pickability=j.updateVisibilityWithCount(r.pickability,r.count,p,a.pickable))}r.verticalOffsets=v?g:null,n.offsetObb=v?p.computeOffsetObb(n.obb,d,y,this._viewingMode,null!=n.offsetObb?n.offsetObb:p.clone(n.obb)):null,C||v||this._hasObjectAndLayerId?(o.componentParameters=new S.ComponentParametersVarying,o.componentParameters.castShadows=N(h,r.count),o.componentParameters.transparent=N(u,r.count),o.componentParameters.opaqueOverride=N(f,r.count),o.componentParameters.texture=c,c.updateTexture()):(o.componentParameters=new S.ComponentParametersUniform,o.componentParameters.castShadows=a.castShadows?S.ComponentParameterSummary.All:S.ComponentParameterSummary.None,o.componentParameters.externalColor=a.externalColor,o.componentParameters.externalColorMixMode=a.externalColorMixMode),this._notifyDirty()}getComponentAabb(e,t,n,o=!1){e.intersectionGeometry.getComponentAabb(t,n);const r=e,i=r.components.verticalOffsets;if(o||null==i)return n;const s=i[t];if(this._viewingMode===f.ViewingMode.Local||0===s)return n[2]+=s,n[5]+=s,n;const a=I.getVerticalOffsetI3S(s);return a.localOrigin=r.transform.position,a.applyToAabb(n)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,n){return e.intersectionGeometry.getComponentPositions(t,n)}intersect(e,t,n,o,r,s){const c=e;null!=r&&(r.localOrigin=c.transform.position);const l=i.invert(q,c.transform.rotationScale);a.sub(H,t,c.transform.position),a.sub(W,n,c.transform.position),a.transformMat3(H,H,l),a.transformMat3(W,W,l);const m=i.transpose(q,l);return c.intersectionGeometry.intersect(H,W,o,m,r,c.components.verticalOffsets,s)}addEdges(e,t,n,o){const r=e,{indices:i,positions:s}=r.intersectionGeometry,a=r.components.offsets;return t.addComponentObject(e,r.transform,{center:r.obb.center,radius:p.radius(r.obb)},s,i,a,n,o)}async extractEdgeInformation(e,t,n){const o=e,r=o.components.visibility;if(r.allInvisible())return{buffer:B.extractComponentsEdgeLocationsLayout.createBuffer(0),origin:[0,0,0]};const{indices:i,positions:s}=o.intersectionGeometry,a=o.components.offsets,l=L.EdgeInputBufferLayout.createBuffer(s.length/3);u.copy(l.position.typedBuffer,s,l.position.typedBufferStride,3),m.transformMat3View(l.position,l.position,o.transform.rotationScale),this._setComponentIndices(l.componentIndex,i,a);const f=l.count,b=this._computeVisibilityIndices(i,r,a,f);return{origin:c.clone(o.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:b,indicesLength:b.length,skipDeduplicate:!0,data:l,writerSettings:{reducedPrecision:!1,variants:0}},n)}}_setComponentIndices(e,t,n){let o=0;for(let r=0;r<n.length-1;r++){const i=n[r],s=n[r+1];for(let n=i;n<s;n++){const r=t?t[n]:n;e.set(r,o)}o++}}_computeVisibilityIndices(e,t,n,o){if(e&&t.allVisible())return e;let i=0;t.forEachComponentRange(((e,t)=>(i+=n[t]-n[e],!0)));const s=r.isArray(e)?new Array(i):2===e?.BYTES_PER_ELEMENT||o<=65536?new Uint16Array(i):new Uint32Array(i);let a=0;return t.forEachComponentRange(((t,o)=>{const r=n[t],i=n[o];for(let n=r;n<i;n++)s[a++]=e?e[n]:n;return!0})),s}addComponentHighlight(e,t){const n=e.components;null==n.highlightCounts&&(n.highlightCounts=new Uint32Array(n.count+1));0===n.highlightCounts[t]++&&(n.highlightsDirty(),this._notifyDirty()),n.highlightCounts[n.count]++}removeComponentHighlight(e,t){const n=e.components;if(null==n.highlightCounts)return void T.warn("Removing non-existing highlight.");const o=n.highlightCounts[t],r=n.highlightCounts[n.count];if(0!==o){if(o>1)return n.highlightCounts[t]=o-1,void(n.highlightCounts[n.count]=r-1);n.highlightCounts[t]=0,n.highlightsDirty(),this._notifyDirty(),1===r?n.highlightCounts=null:n.highlightCounts[n.count]=r-1}else T.warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[y.State.Visible]}_createRenderable(e,t){const n=this._renderManager.rctx,o=e.geometry,r=o.vertices.layoutParameters,i=V.BufferObject.createVertex(n,E.Usage.STATIC_DRAW,o.vertices.data),s=o.indices?V.BufferObject.createIndex(n,E.Usage.STATIC_DRAW,o.indices):null,a=h.glLayout(_.createVertexBufferLayout(r)),c=new Uint16Array(o.vertices.count);for(let p=0;p<t.count;p++){const e=t.offsets[p],n=t.offsets[p+1],r=t.materialDataIndices[p];if(null!=o.indices)for(let t=e;t<n;t++){c[o.indices[t]]=r}else for(let t=e;t<n;t++)c[t]=r}const l=V.BufferObject.createVertex(n,E.Usage.STATIC_DRAW,c.buffer),m=new S.ComponentMaterial(e.transform,e.toMapSpace),u=new R.VertexArrayObject(n,x.attributeLocations,{data:a,componentIndices:G},{data:i,componentIndices:l},s),f=new O.RenderGeometry(u,E.PrimitiveType.TRIANGLES,r,null!=s),b={cameraDepthSquared:.5,gpuMemoryEstimate:i.byteLength+l.byteLength+(null!=s?s.byteLength:0)};return new v.Renderable(m,f,b)}_notifyDirty(){this._renderManager.notifyDirty()}}const G=h.glLayout(g.newLayout().u16(P.VertexAttribute.COMPONENTINDEX));function N(e,t){return e===t?S.ComponentParameterSummary.All:0===e?S.ComponentParameterSummary.None:S.ComponentParameterSummary.Some}const q=s.create(),H=c.create(),W=c.create();e.ComponentObjectCollection=k,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
