/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/support/DoubleArray","../../../../geometry/support/FloatArray","../../../../geometry/support/Indices","../../../../geometry/support/plane","../../../../geometry/support/ray","./Attribute","./BufferVectorMath","./ContentObjectType","./Geometry","./Util","./VertexAttribute"],(function(t,e,r,n,o,s,a,u,l,c,i,h,A,f,b){"use strict";const p=i.Vec3Compact,y=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],m=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],w=[0,0,1,0,1,1,0,1],V=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],g=new Array(36);for(let at=0;at<6;at++)for(let t=0;t<6;t++)g[6*at+t]=at;const O=new Array(36);for(let at=0;at<6;at++)O[6*at]=0,O[6*at+1]=1,O[6*at+2]=2,O[6*at+3]=2,O[6*at+4]=3,O[6*at+5]=0;function d(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let n=0;n<8;n++)r[3*n]=y[n][0]*e[0],r[3*n+1]=y[n][1]*e[1],r[3*n+2]=y[n][2]*e[2];return new A.Geometry(t,[[b.VertexAttribute.POSITION,new c.Attribute(r,V,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(m,g,3)],[b.VertexAttribute.UV0,new c.Attribute(w,O,2)]])}const x=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],M=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],I=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],P=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function G(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let n=0;n<6;n++)r[3*n]=x[n][0]*e[0],r[3*n+1]=x[n][1]*e[1],r[3*n+2]=x[n][2]*e[2];return new A.Geometry(t,[[b.VertexAttribute.POSITION,new c.Attribute(r,I,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(M,P,3)]])}const N=r.fromValues(-.5,0,-.5),T=r.fromValues(.5,0,-.5),S=r.fromValues(0,0,.5),F=r.fromValues(0,.5,0),R=r.create(),L=r.create(),z=r.create(),C=r.create(),U=r.create();e.subtract(R,N,F),e.subtract(L,N,T),e.cross(z,R,L),e.normalize(z,z),e.subtract(R,T,F),e.subtract(L,T,S),e.cross(C,R,L),e.normalize(C,C),e.subtract(R,S,F),e.subtract(L,S,N),e.cross(U,R,L),e.normalize(U,U);const v=[N,T,S,F],E=[0,-1,0,z[0],z[1],z[2],C[0],C[1],C[2],U[0],U[1],U[2]],k=[0,1,2,3,1,0,3,2,1,3,0,2],D=[0,0,0,1,1,1,2,2,2,3,3,3];function j(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let n=0;n<4;n++)r[3*n]=v[n][0]*e[0],r[3*n+1]=v[n][1]*e[1],r[3*n+2]=v[n][2]*e[2];return new A.Geometry(t,[[b.VertexAttribute.POSITION,new c.Attribute(r,k,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(E,D,3)]])}function B(t,e,r,n,o={uv:!0}){const u=-Math.PI,l=2*Math.PI,i=-Math.PI/2,h=Math.PI,f=Math.max(3,Math.floor(r)),p=Math.max(2,Math.floor(n)),y=(f+1)*(p+1),m=s.newFloatArray(3*y),w=s.newFloatArray(3*y),V=s.newFloatArray(2*y),g=[];let O=0;for(let s=0;s<=p;s++){const t=[],r=s/p,n=i+r*h,o=Math.cos(n);for(let s=0;s<=f;s++){const a=s/f,c=u+a*l,i=Math.cos(c)*o,h=Math.sin(n),A=-Math.sin(c)*o;m[3*O]=i*e,m[3*O+1]=h*e,m[3*O+2]=A*e,w[3*O]=i,w[3*O+1]=h,w[3*O+2]=A,V[2*O]=a,V[2*O+1]=r,t.push(O),++O}g.push(t)}const d=new Array;for(let s=0;s<p;s++)for(let t=0;t<f;t++){const e=g[s][t],r=g[s][t+1],n=g[s+1][t+1],o=g[s+1][t];0===s?(d.push(e),d.push(n),d.push(o)):s===p-1?(d.push(e),d.push(r),d.push(n)):(d.push(e),d.push(r),d.push(n),d.push(n),d.push(o),d.push(e))}const x=[[b.VertexAttribute.POSITION,new c.Attribute(m,d,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(w,d,3,!0)]];return o.uv&&x.push([b.VertexAttribute.UV0,new c.Attribute(V,d,2,!0)]),o.offset&&(x[0][0]=b.VertexAttribute.OFFSET,x.push([b.VertexAttribute.POSITION,new c.Attribute(Float64Array.from(o.offset),a.getZeroIndexArray(d.length),3,!0)])),new A.Geometry(t,x)}function q(t,e,r,n){const o=Z(e,r,n);return new A.Geometry(t,o)}function Z(t,e,r){const n=t;let o,a;if(r)o=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const t=n*(1+Math.sqrt(5))/2;o=[-n,t,0,n,t,0,-n,-t,0,n,-t,0,0,-n,t,0,n,t,0,-n,-t,0,n,-t,t,0,-n,t,0,n,-t,0,-n,-t,0,n],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let s=0;s<o.length;s+=3)p.scale(o,s,t/p.length(o,s));let u={};function l(e,r){e>r&&([e,r]=[r,e]);const n=e.toString()+"."+r.toString();if(u[n])return u[n];let s=o.length;return o.length+=3,p.add(o,3*e,o,3*r,o,s),p.scale(o,s,t/p.length(o,s)),s/=3,u[n]=s,s}for(let s=0;s<e;s++){const t=a.length,e=new Array(4*t);for(let r=0;r<t;r+=3){const t=a[r],n=a[r+1],o=a[r+2],s=l(t,n),u=l(n,o),c=l(o,t),i=4*r;e[i]=t,e[i+1]=s,e[i+2]=c,e[i+3]=n,e[i+4]=u,e[i+5]=s,e[i+6]=o,e[i+7]=c,e[i+8]=u,e[i+9]=s,e[i+10]=u,e[i+11]=c}a=e,u={}}const i=s.floatArrayFrom(o);for(let s=0;s<i.length;s+=3)p.normalize(i,s);return[[b.VertexAttribute.POSITION,new c.Attribute(s.floatArrayFrom(o),a,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(i,a,3,!0)]]}function X(t,e,r,n,o,s,u,l,i=null){const f=r?[r[0],r[1],r[2]]:[0,0,0],p=e?[e[0],e[1],e[2]]:[0,0,1];u=u||[0,0];const y=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],m=null!=o&&2===o.length?o:[1,1],w=a.getZeroIndexArray(1),V=[[b.VertexAttribute.POSITION,new c.Attribute(f,w,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(p,w,3,!0)],[b.VertexAttribute.UV0,new c.Attribute(u,w,u.length)],[b.VertexAttribute.COLOR,new c.Attribute(y,w,4,!0)],[b.VertexAttribute.SIZE,new c.Attribute(m,w,2)]];if(null!=s){const t=[s[0],s[1],s[2],s[3]];V.push([b.VertexAttribute.AUXPOS1,new c.Attribute(t,w,4)])}if(null!=l){const t=[l[0],l[1],l[2],l[3]];V.push([b.VertexAttribute.FEATUREATTRIBUTE,new c.Attribute(t,w,4)])}return new A.Geometry(t,V,null,h.ContentObjectType.Point,i)}const H=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function J(t,e=H){const r=new Array(12);for(let c=0;c<4;c++)for(let t=0;t<3;t++)r[3*c+t]=e[c][t];const n=[0,1,2,2,3,0],o=[0,0,1],s=[0,0,0,0,0,0],a=[0,0,1,0,1,1,0,1],u=[255,255,255,255],l=[[b.VertexAttribute.POSITION,new c.Attribute(r,n,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(o,s,3,!0)],[b.VertexAttribute.UV0,new c.Attribute(a,n,2,!0)],[b.VertexAttribute.COLOR,new c.Attribute(u,s,4,!0)]];return new A.Geometry(t,l)}function K(t,e,n,o,a,u=!0,l=!0){let i=0;const h=n,f=e;let p=r.fromValues(0,i,0),y=r.fromValues(0,i+f,0),m=r.fromValues(0,-1,0),w=r.fromValues(0,1,0);a&&(i=f,y=r.fromValues(0,0,0),p=r.fromValues(0,i,0),m=r.fromValues(0,1,0),w=r.fromValues(0,-1,0));const V=[y,p],g=[m,w],O=o+2,d=Math.sqrt(f*f+h*h);if(a)for(let s=o-1;s>=0;s--){const t=s*(2*Math.PI/o),e=r.fromValues(Math.cos(t)*h,i,Math.sin(t)*h);V.push(e);const n=r.fromValues(f*Math.cos(t)/d,-h/d,f*Math.sin(t)/d);g.push(n)}else for(let s=0;s<o;s++){const t=s*(2*Math.PI/o),e=r.fromValues(Math.cos(t)*h,i,Math.sin(t)*h);V.push(e);const n=r.fromValues(f*Math.cos(t)/d,h/d,f*Math.sin(t)/d);g.push(n)}const x=new Array,M=new Array;if(u){for(let t=3;t<V.length;t++)x.push(1),x.push(t-1),x.push(t),M.push(0),M.push(0),M.push(0);x.push(V.length-1),x.push(2),x.push(1),M.push(0),M.push(0),M.push(0)}if(l){for(let t=3;t<V.length;t++)x.push(t),x.push(t-1),x.push(0),M.push(t),M.push(t-1),M.push(1);x.push(0),x.push(2),x.push(V.length-1),M.push(1),M.push(2),M.push(g.length-1)}const I=s.newFloatArray(3*O);for(let r=0;r<O;r++)I[3*r]=V[r][0],I[3*r+1]=V[r][1],I[3*r+2]=V[r][2];const P=s.newFloatArray(3*O);for(let r=0;r<O;r++)P[3*r]=g[r][0],P[3*r+1]=g[r][1],P[3*r+2]=g[r][2];const G=[[b.VertexAttribute.POSITION,new c.Attribute(I,x,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(P,M,3,!0)]];return new A.Geometry(t,G)}function Q(t,n,o,a,u,l,i){const h=u?r.clone(u):r.fromValues(1,0,0),f=l?r.clone(l):r.fromValues(0,0,0);i??(i=!0);const p=r.create();e.normalize(p,h);const y=r.create();e.scale(y,p,Math.abs(n));const m=r.create();e.scale(m,y,-.5),e.add(m,m,f);const w=r.fromValues(0,1,0);Math.abs(1-e.dot(p,w))<.2&&e.set(w,0,0,1);const V=r.create();e.cross(V,p,w),e.normalize(V,V),e.cross(w,V,p);const g=2*a+(i?2:0),O=a+(i?2:0),d=s.newFloatArray(3*g),x=s.newFloatArray(3*O),M=s.newFloatArray(2*g),I=new Array(3*a*(i?4:2)),P=new Array(3*a*(i?4:2));i&&(d[3*(g-2)]=m[0],d[3*(g-2)+1]=m[1],d[3*(g-2)+2]=m[2],M[2*(g-2)]=0,M[2*(g-2)+1]=0,d[3*(g-1)]=d[3*(g-2)]+y[0],d[3*(g-1)+1]=d[3*(g-2)+1]+y[1],d[3*(g-1)+2]=d[3*(g-2)+2]+y[2],M[2*(g-1)]=1,M[2*(g-1)+1]=1,x[3*(O-2)]=-p[0],x[3*(O-2)+1]=-p[1],x[3*(O-2)+2]=-p[2],x[3*(O-1)]=p[0],x[3*(O-1)+1]=p[1],x[3*(O-1)+2]=p[2]);const G=(t,e,r)=>{I[t]=e,P[t]=r};let N=0;const T=r.create(),S=r.create();for(let r=0;r<a;r++){const t=r*(2*Math.PI/a);e.scale(T,w,Math.sin(t)),e.scale(S,V,Math.cos(t)),e.add(T,T,S),x[3*r]=T[0],x[3*r+1]=T[1],x[3*r+2]=T[2],e.scale(T,T,o),e.add(T,T,m),d[3*r]=T[0],d[3*r+1]=T[1],d[3*r+2]=T[2],M[2*r]=r/a,M[2*r+1]=0,d[3*(r+a)]=d[3*r]+y[0],d[3*(r+a)+1]=d[3*r+1]+y[1],d[3*(r+a)+2]=d[3*r+2]+y[2],M[2*(r+a)]=r/a,M[2*r+1]=1;const n=(r+1)%a;G(N++,r,r),G(N++,r+a,r),G(N++,n,n),G(N++,n,n),G(N++,r+a,r),G(N++,n+a,n)}if(i){for(let t=0;t<a;t++){const e=(t+1)%a;G(N++,g-2,O-2),G(N++,t,O-2),G(N++,e,O-2)}for(let t=0;t<a;t++){const e=(t+1)%a;G(N++,t+a,O-1),G(N++,g-1,O-1),G(N++,e+a,O-1)}}const F=[[b.VertexAttribute.POSITION,new c.Attribute(d,I,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(x,P,3,!0)],[b.VertexAttribute.UV0,new c.Attribute(M,I,2,!0)]];return new A.Geometry(t,F)}function W(t,e,r,n,o,s){n=n||10,o=null==o||o,f.assert(e.length>1);const a=[[0,0,0]],u=[],l=[];for(let c=0;c<n;c++){u.push([0,-c-1,-(c+1)%n-1]);const t=c/n*2*Math.PI;l.push([Math.cos(t)*r,Math.sin(t)*r])}return Y(t,l,e,a,u,o,s)}function Y(t,o,a,i,h,f,p=r.fromValues(0,0,0)){const y=o.length,m=s.newFloatArray(a.length*y*3+(6*i.length||0)),w=s.newFloatArray(a.length*y*3+(i?6:0)),V=new Array,g=new Array;let O=0,d=0;const x=r.create(),M=r.create(),I=r.create(),P=r.create(),G=r.create(),N=r.create(),T=r.create(),S=n.create(),F=r.create(),R=r.create(),L=r.create(),z=r.create(),C=r.create(),U=u.create();e.set(F,0,1,0),e.subtract(M,a[1],a[0]),e.normalize(M,M),f?(e.add(S,a[0],p),e.normalize(I,S)):e.set(I,0,0,1),nt(M,I,F,F,G,I,ot),e.copy(P,I),e.copy(z,G);for(let r=0;r<i.length;r++)e.scale(N,G,i[r][0]),e.scale(S,I,i[r][2]),e.add(N,N,S),e.add(N,N,a[0]),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2];w[d++]=-M[0],w[d++]=-M[1],w[d++]=-M[2];for(let e=0;e<h.length;e++)V.push(h[e][0]>0?h[e][0]:-h[e][0]-1+i.length),V.push(h[e][1]>0?h[e][1]:-h[e][1]-1+i.length),V.push(h[e][2]>0?h[e][2]:-h[e][2]-1+i.length),g.push(0),g.push(0),g.push(0);let v=i.length;const E=i.length-1;for(let r=0;r<a.length;r++){let t=!1;if(r>0){e.copy(x,M),r<a.length-1?(e.subtract(M,a[r+1],a[r]),e.normalize(M,M)):t=!0,e.add(R,x,M),e.normalize(R,R),e.add(L,a[r-1],P),u.fromPositionAndNormal(a[r],R,U);u.intersectRay(U,l.wrap(L,x),S)?(e.subtract(S,S,a[r]),e.normalize(I,S),e.cross(G,R,I),e.normalize(G,G)):nt(R,P,z,F,G,I,ot),e.copy(P,I),e.copy(z,G)}f&&(e.add(S,a[r],p),e.normalize(C,S));for(let n=0;n<y;n++)if(e.scale(N,G,o[n][0]),e.scale(S,I,o[n][1]),e.add(N,N,S),e.normalize(T,N),w[d++]=T[0],w[d++]=T[1],w[d++]=T[2],e.add(N,N,a[r]),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2],!t){const t=(n+1)%y;V.push(v+n),V.push(v+y+n),V.push(v+t),V.push(v+t),V.push(v+y+n),V.push(v+y+t);for(let e=0;e<6;e++){const t=V.length-6;g.push(V[t+e]-E)}}v+=y}const k=a[a.length-1];for(let r=0;r<i.length;r++)e.scale(N,G,i[r][0]),e.scale(S,I,i[r][1]),e.add(N,N,S),e.add(N,N,k),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2];const D=d/3;w[d++]=M[0],w[d++]=M[1],w[d++]=M[2];const j=v-y;for(let e=0;e<h.length;e++)V.push(h[e][0]>=0?v+h[e][0]:-h[e][0]-1+j),V.push(h[e][2]>=0?v+h[e][2]:-h[e][2]-1+j),V.push(h[e][1]>=0?v+h[e][1]:-h[e][1]-1+j),g.push(D),g.push(D),g.push(D);const B=[[b.VertexAttribute.POSITION,new c.Attribute(m,V,3,!0)],[b.VertexAttribute.NORMAL,new c.Attribute(w,g,3,!0)]];return new A.Geometry(t,B)}function $(t,e,r,n){f.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),f.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),f.assert(null==r||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),f.assert(null==r||3===r[0].length,"createPolylineGeometry(): malformed normal");const u=o.newDoubleArray(3*e.length),l=new Array(2*(e.length-1));let i=0,p=0;for(let o=0;o<e.length;o++){for(let t=0;t<3;t++)u[i++]=e[o][t];o>0&&(l[p++]=o-1,l[p++]=o)}const y=[[b.VertexAttribute.POSITION,new c.Attribute(u,l,3,!0)]];if(r){const t=s.newFloatArray(3*r.length);let n=0;for(let o=0;o<e.length;o++)for(let e=0;e<3;e++)t[n++]=r[o][e];y.push([b.VertexAttribute.NORMAL,new c.Attribute(t,l,3,!0)])}return n&&y.push([b.VertexAttribute.COLOR,new c.Attribute(n,a.getContinuousIndexArray(n.length/4),4)]),new A.Geometry(t,y,null,h.ContentObjectType.Line)}function _(t,e,r,n,o,s=0){const a=new Array(18),u=[[-r,s,o/2],[n,s,o/2],[0,e+s,o/2],[-r,s,-o/2],[n,s,-o/2],[0,e+s,-o/2]],l=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let c=0;c<6;c++)a[3*c]=u[c][0],a[3*c+1]=u[c][1],a[3*c+2]=u[c][2];return new A.Geometry(t,[[b.VertexAttribute.POSITION,new c.Attribute(a,l,3,!0)]])}function tt(t,r){const n=t.getMutableAttribute(b.VertexAttribute.POSITION).data;for(let o=0;o<n.length;o+=3){const t=n[o],s=n[o+1],a=n[o+2];e.set(st,t,s,a),e.transformMat4(st,st,r),n[o]=st[0],n[o+1]=st[1],n[o+2]=st[2]}}function et(t,e=t){const r=t.attributes,n=r.get(b.VertexAttribute.POSITION).data,o=r.get(b.VertexAttribute.NORMAL).data;if(o){const t=e.getMutableAttribute(b.VertexAttribute.NORMAL).data;for(let e=0;e<o.length;e+=3){const r=o[e+1];t[e+1]=-o[e+2],t[e+2]=r}}if(n){const t=e.getMutableAttribute(b.VertexAttribute.POSITION).data;for(let e=0;e<n.length;e+=3){const r=n[e+1];t[e+1]=-n[e+2],t[e+2]=r}}}function rt(t,r,n,o,s){return!(Math.abs(e.dot(r,t))>s)&&(e.cross(n,t,r),e.normalize(n,n),e.cross(o,n,t),e.normalize(o,o),!0)}function nt(t,e,r,n,o,s,a){return rt(t,e,o,s,a)||rt(t,r,o,s,a)||rt(t,n,o,s,a)}const ot=.99619469809,st=r.create();t.cgToGIS=et,t.createBoxGeometry=d,t.createConeGeometry=K,t.createCylinderGeometry=Q,t.createDiamondGeometry=G,t.createExtrudedTriangle=_,t.createPathExtrusionGeometry=Y,t.createPointGeometry=X,t.createPolySphereData=Z,t.createPolySphereGeometry=q,t.createPolylineGeometry=$,t.createSphereGeometry=B,t.createSquareGeometry=J,t.createTetrahedronGeometry=j,t.createTubeGeometry=W,t.makeOrthoBasisDirUpFallback=nt,t.transformInPlace=tt,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
