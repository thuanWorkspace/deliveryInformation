/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/vec2","../../../../chunks/vec2f64"],(function(e,t,s){"use strict";class i{rebuildConnectingProfileGeometry(e,t,s){for(let i=0;i<t.vertices.length;++i)s(e.frame,t.vertices[i],t.normals[i],0,0)}}class r extends i{constructor(){super(),this.numVertices=0,this.numIndices=0}rebuildCapGeometry(){}buildTopology(){}}class n extends i{constructor(e,t=0,s=!1){super(),this.profile=e,this.profilePlaneOffset=t,this.flip=s}get numVertices(){return this.profile.vertices.length}get numIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(e,t,s){const i=this.profilePlaneOffset;for(let r=0;r<t.vertices.length;++r)s(e.frame,t.vertices[r],t.normals[r],i,0)}rebuildCapGeometry(e,s){const i=this.profile,r=this.flip?1:-1,n=this.profilePlaneOffset,o=c;t.set(o,0,0);for(let t=0;t<i.vertices.length;++t)s(e.frame,i.vertices[t],o,n,r)}buildTopology(e,t){const s=this.profile,i=this.vertexBufferStart+s.indices[0];for(let r=1;r<s.numSegments;++r){const e=s.indices[2*r],n=s.indices[2*r+1],o=this.vertexBufferStart+e,l=this.vertexBufferStart+n;this.flip?t(l,o,i):t(i,o,l)}}}class o extends i{constructor(e){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=e.profile,this.flip=e.flip,this.sign=this.flip?1:-1,this.breakNormals=e.breakNormals,this.numSegments=e.subdivisions}get numVertices(){let e=this.profile.vertices.length*(this.numSegments-1)+this.profile.poles.length;return this.breakNormals&&(e+=this.profile.vertices.length),e}get numIndices(){let e=0;const t=this.profile;e+=2*t.numSegments*(this.numSegments-1);for(let s=0;s<t.numSegments;++s){const i=t.indices[2*s],r=t.indices[2*s+1];t.poleIndices[i]===t.poleIndices[r]?e+=1:e+=2}return 3*e}rebuildCapGeometry(e,s){const i=this.profile,r=e.frame,n=.5*this.sign,o=l,h=c;t.set(h,0,0);for(const t of i.poles)t.normal?s(r,t.position,t.normal,n,0):s(r,t.position,h,n,this.sign);if(this.breakNormals)for(let t=0;t<i.vertices.length;++t)s(r,i.vertices[t],i.normals[t],0,0);for(let l=0;l<this.numSegments-1;++l){const e=(1-(l+1)/this.numSegments)*Math.PI*.5,c=Math.sin(e),f=Math.cos(e);for(let l=0;l<i.vertices.length;++l){const e=i.poles[i.poleIndices[l]];t.subtract(o,i.vertices[l],e.position),t.scale(o,o,c),e.normal?(t.add(o,o,e.position),s(r,o,e.normal,n*f,0)):(t.normalize(h,o),t.scale(h,h,c),t.add(o,o,e.position),s(r,o,h,n*f,this.sign*f))}}}buildTopology(e,t){const s=this.profile,i=this.breakNormals?this.vertexBufferStart+s.poles.length:this.firstProfileVertexIndex,r=this.breakNormals?this.vertexBufferStart+s.poles.length+s.vertices.length:this.vertexBufferStart+s.poles.length;for(let n=0;n<s.numSegments;++n){const e=s.indices[2*n],o=s.indices[2*n+1],l=this.vertexBufferStart+s.poleIndices[e],c=this.vertexBufferStart+s.poleIndices[o];let h=i+e,f=i+o;for(let i=0;i<this.numSegments-1;++i){const n=r+i*s.vertices.length+e,l=r+i*s.vertices.length+o;this.flip?(t(n,f,h),t(f,n,l)):(t(h,f,n),t(l,n,f)),h=n,f=l}this.flip?(t(l,f,h),l!==c&&t(l,c,f)):(t(h,f,l),l!==c&&t(f,c,l))}}}const l=s.create(),c=s.create();e.NoCapBuilder=r,e.PathCapBuilder=i,e.RoundCapBuilder=o,e.TriangulationCapBuilder=n,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
