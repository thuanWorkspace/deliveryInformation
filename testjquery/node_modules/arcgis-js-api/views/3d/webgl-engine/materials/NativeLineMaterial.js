/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/Logger","../../../../core/mathUtils","../../../../core/screenUtils","../../../../chunks/vec2","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../chunks/vec4f64","../../../../geometry/support/frustum","../../../../geometry/support/lineSegment","../../../../geometry/support/plane","../core/shaderLibrary/ShaderOutput","../lib/GLMaterial","../lib/Material","../lib/RenderSlot","../lib/Util","../lib/VertexAttribute","./DefaultBufferWriter","./DefaultLayouts","../shaders/NativeLineTechnique","../shaders/NativeLineTechniqueConfiguration"],(function(e,t,r,a,n,i,s,o,c,u,l,d,h,f,g,p,m,S,P,A,y){"use strict";class b extends f.Material{constructor(e){super(e,new R),this._configuration=new y.NativeLineTechniqueConfiguration}getConfiguration(e){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration}intersect(e,r,a,s,o,d){if(!a.options.selectionMode||!e.visible)return;if(!p.isTranslationMatrix(r))return void t.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");const h=e.attributes.get(m.VertexAttribute.POSITION).data,f=a.camera,g=C;n.copy(g,a.point);const S=2;i.set(V[0],g[0]-S,g[1]+S,0),i.set(V[1],g[0]+S,g[1]+S,0),i.set(V[2],g[0]+S,g[1]-S,0),i.set(V[3],g[0]-S,g[1]-S,0);for(let t=0;t<4;t++)if(!f.unprojectFromRenderScreen(V[t],w[t]))return;l.fromPoints(f.eye,w[0],w[1],j),l.fromPoints(f.eye,w[1],w[2],U),l.fromPoints(f.eye,w[2],w[3],q),l.fromPoints(f.eye,w[3],w[0],k);let P=Number.MAX_VALUE,A=0;for(let t=0;t<h.length-5;t+=3){if(L[0]=h[t]+r[12],L[1]=h[t+1]+r[13],L[2]=h[t+2]+r[14],x[0]=h[t+3]+r[12],x[1]=h[t+4]+r[13],x[2]=h[t+5]+r[14],l.signedDistance(j,L)<0&&l.signedDistance(j,x)<0||l.signedDistance(U,L)<0&&l.signedDistance(U,x)<0||l.signedDistance(q,L)<0&&l.signedDistance(q,x)<0||l.signedDistance(k,L)<0&&l.signedDistance(k,x)<0)continue;if(f.projectToRenderScreen(L,M),f.projectToRenderScreen(x,N),M[2]<0&&N[2]>0){i.subtract(_,L,x);const e=f.frustum,t=-l.signedDistance(e[c.PlaneIndex.NEAR],L)/i.dot(_,l.normal(e[c.PlaneIndex.NEAR]));i.scale(_,_,t),i.add(L,L,_),f.projectToRenderScreen(L,M)}else if(M[2]>0&&N[2]<0){i.subtract(_,x,L);const e=f.frustum,t=-l.signedDistance(e[c.PlaneIndex.NEAR],x)/i.dot(_,l.normal(e[c.PlaneIndex.NEAR]));i.scale(_,_,t),i.add(x,x,_),f.projectToRenderScreen(x,N)}else if(M[2]<0&&N[2]<0)continue;M[2]=0,N[2]=0;const e=u.distance2(u.fromPoints(M,N,E),g);e<P&&(P=e,i.copy(T,L),i.copy(v,x),A=t/3)}const y=a.rayBegin,b=a.rayEnd;if(P<S*S){let e=Number.MAX_VALUE;if(u.closestLineSegmentPoint(u.fromPoints(T,v,E),u.fromPoints(y,b,I),D)){i.subtract(D,D,y);const t=i.length(D);i.scale(D,D,1/t),e=t/i.distance(y,b)}d(e,D,A,!1)}}intersectDraped(e,t,a,n,i,s){if(!a.options.selectionMode)return;const o=e.attributes.get(m.VertexAttribute.POSITION).data,c=e.attributes.get(m.VertexAttribute.SIZE),u=c?c.data[0]:0,l=n[0],d=n[1],h=((u+1)/2+4)*e.screenToWorldRatio;let f=Number.MAX_VALUE,g=0;for(let p=0;p<o.length-5;p+=3){const e=o[p],t=o[p+1],a=l-e,n=d-t,i=o[p+3]-e,s=o[p+4]-t,c=i*a+s*n,u=i*i+s*s,h=r.clamp(c/u,0,1),m=i*h-a,S=s*h-n,P=m*m+S*S;P<f&&(f=P,g=p/3)}f<h*h&&i(s.dist,s.normal,g,!1)}produces(e,t){return!(t!==d.ShaderOutput.Color&&t!==d.ShaderOutput.Highlight&&t!==d.ShaderOutput.ObjectAndLayerIdColor||e!==g.RenderSlot.OPAQUE_MATERIAL&&e!==g.RenderSlot.DRAPED_MATERIAL)}createGLMaterial(e){return new O(e)}createBufferWriter(){const e=this.parameters.hasVertexColors?P.PositionColorLayout:P.PositionLayout;return new S.DefaultBufferWriter(e)}}class O extends h{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output===d.ShaderOutput.Color&&this._updateOccludeeState(e),this.ensureTechnique(A.NativeLineTechnique,e)}}class R extends f.MaterialParameters{constructor(){super(...arguments),this.color=o.ONES,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.hasOccludees=!1}}const L=s.create(),x=s.create(),_=s.create(),D=s.create(),M=a.createRenderScreenPointArray3(),N=a.createRenderScreenPointArray3(),T=s.create(),v=s.create(),E=u.create(),I=u.create(),C=s.create(),V=[a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3()],w=[s.create(),s.create(),s.create(),s.create()],j=l.create(),U=l.create(),q=l.create(),k=l.create();e.NativeLineMaterial=b,e.Parameters=R,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
