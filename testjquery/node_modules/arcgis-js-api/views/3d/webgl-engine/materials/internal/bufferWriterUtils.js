/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/mat4","../../../../../geometry/support/buffer/BufferView","../../lib/Util","../../lib/VertexAttribute"],(function(e,t,r,f,i){"use strict";function o(e,t,r,f=1){const{data:i,indices:o}=e,s=t.typedBuffer,n=t.typedBufferStride,c=o.length;if(r*=n,1===f)for(let u=0;u<c;++u)s[r]=i[o[u]],r+=n;else for(let u=0;u<c;++u){const e=i[o[u]];for(let t=0;t<f;t++)s[r]=e,r+=n}}function s(e,t,r){const{data:f,indices:i}=e,o=t.typedBuffer,s=t.typedBufferStride,n=i.length;r*=s;for(let c=0;c<n;++c){const e=2*i[c];o[r]=f[e],o[r+1]=f[e+1],r+=s}}function n(e,t,r,f){const{data:i,indices:o}=e,s=t.typedBuffer,n=t.typedBufferStride,c=o.length;if(r*=n,null==f||1===f)for(let u=0;u<c;++u){const e=3*o[u];s[r]=i[e],s[r+1]=i[e+1],s[r+2]=i[e+2],r+=n}else for(let u=0;u<c;++u){const e=3*o[u];for(let t=0;t<f;++t)s[r]=i[e],s[r+1]=i[e+1],s[r+2]=i[e+2],r+=n}}function c(e,t,r,f=1){const{data:i,indices:o}=e,s=t.typedBuffer,n=t.typedBufferStride,c=o.length;if(r*=n,1===f)for(let u=0;u<c;++u){const e=4*o[u];s[r]=i[e],s[r+1]=i[e+1],s[r+2]=i[e+2],s[r+3]=i[e+3],r+=n}else for(let u=0;u<c;++u){const e=4*o[u];for(let t=0;t<f;++t)s[r]=i[e],s[r+1]=i[e+1],s[r+2]=i[e+2],s[r+3]=i[e+3],r+=n}}function u(e,t,r){const f=e.typedBuffer,i=e.typedBufferStride;t*=i;for(let o=0;o<r;++o)f[t]=0,f[t+1]=0,f[t+2]=0,f[t+3]=0,t+=i}function l(e,t,r){const{data:f,indices:i}=e,o=t.typedBuffer,s=t.typedBufferStride,n=i.length;r*=s;for(let c=0;c<n;++c){const e=9*i[c];for(let t=0;t<9;++t)o[r+t]=f[e+t];r+=s}}function d(e,t,r){const{data:f,indices:i}=e,o=t.typedBuffer,s=t.typedBufferStride,n=i.length;r*=s;for(let c=0;c<n;++c){const e=16*i[c];for(let t=0;t<16;++t)o[r+t]=f[e+t];r+=s}}function a(e,r,f,i,o=1){if(!r)return void n(e,f,i,o);const{data:s,indices:c}=e,u=f.typedBuffer,l=f.typedBufferStride,d=c.length,a=r[0],B=r[1],b=r[2],V=r[4],y=r[5],w=r[6],A=r[8],p=r[9],g=r[10],O=r[12],h=r[13],N=r[14];i*=l;let S=0,R=0,F=0;const x=t.hasIdentityRotation(r)?e=>{S=s[e]+O,R=s[e+1]+h,F=s[e+2]+N}:e=>{const t=s[e],r=s[e+1],f=s[e+2];S=a*t+V*r+A*f+O,R=B*t+y*r+p*f+h,F=b*t+w*r+g*f+N};if(1===o)for(let t=0;t<d;++t)x(3*c[t]),u[i]=S,u[i+1]=R,u[i+2]=F,i+=l;else for(let t=0;t<d;++t){x(3*c[t]);for(let e=0;e<o;++e)u[i]=S,u[i+1]=R,u[i+2]=F,i+=l}}function B(e,r,f,i,o=1){if(!r)return void n(e,f,i,o);const{data:s,indices:c}=e,u=r,l=f.typedBuffer,d=f.typedBufferStride,a=c.length,B=u[0],b=u[1],V=u[2],y=u[4],w=u[5],A=u[6],p=u[8],g=u[9],O=u[10],h=!t.isOrthoNormal(u),N=1e-6,S=1-N;i*=d;let R=0,F=0,x=0;const E=t.hasIdentityRotation(u)?e=>{R=s[e],F=s[e+1],x=s[e+2]}:e=>{const t=s[e],r=s[e+1],f=s[e+2];R=B*t+y*r+p*f,F=b*t+w*r+g*f,x=V*t+A*r+O*f};if(1===o)if(h)for(let t=0;t<a;++t){E(3*c[t]);const e=R*R+F*F+x*x;if(e<S&&e>N){const t=1/Math.sqrt(e);l[i]=R*t,l[i+1]=F*t,l[i+2]=x*t}else l[i]=R,l[i+1]=F,l[i+2]=x;i+=d}else for(let t=0;t<a;++t)E(3*c[t]),l[i]=R,l[i+1]=F,l[i+2]=x,i+=d;else for(let t=0;t<a;++t){if(E(3*c[t]),h){const e=R*R+F*F+x*x;if(e<S&&e>N){const t=1/Math.sqrt(e);R*=t,F*=t,x*=t}}for(let e=0;e<o;++e)l[i]=R,l[i+1]=F,l[i+2]=x,i+=d}}function b(e,r,f,i,o=1){if(!r)return void c(e,f,i,o);const{data:s,indices:n}=e,u=r,l=f.typedBuffer,d=f.typedBufferStride,a=n.length,B=u[0],b=u[1],V=u[2],y=u[4],w=u[5],A=u[6],p=u[8],g=u[9],O=u[10],h=!t.isOrthoNormal(u),N=1e-6,S=1-N;if(i*=d,1===o)for(let t=0;t<a;++t){const e=4*n[t],r=s[e],f=s[e+1],o=s[e+2],c=s[e+3];let u=B*r+y*f+p*o,a=b*r+w*f+g*o,R=V*r+A*f+O*o;if(h){const e=u*u+a*a+R*R;if(e<S&&e>N){const t=1/Math.sqrt(e);u*=t,a*=t,R*=t}}l[i]=u,l[i+1]=a,l[i+2]=R,l[i+3]=c,i+=d}else for(let t=0;t<a;++t){const e=4*n[t],r=s[e],f=s[e+1],c=s[e+2],u=s[e+3];let a=B*r+y*f+p*c,R=b*r+w*f+g*c,F=V*r+A*f+O*c;if(h){const e=a*a+R*R+F*F;if(e<S&&e>N){const t=1/Math.sqrt(e);a*=t,R*=t,F*=t}}for(let t=0;t<o;++t)l[i]=a,l[i+1]=R,l[i+2]=F,l[i+3]=u,i+=d}}function V(e,t,r,f,i=1){const{data:o,indices:s}=e,n=r.typedBuffer,c=r.typedBufferStride,u=s.length;if(f*=c,t!==o.length||4!==t)if(1!==i)if(4!==t)for(let l=0;l<u;++l){const e=3*s[l];for(let t=0;t<i;++t)n[f]=o[e],n[f+1]=o[e+1],n[f+2]=o[e+2],n[f+3]=255,f+=c}else for(let l=0;l<u;++l){const e=4*s[l];for(let t=0;t<i;++t)n[f]=o[e],n[f+1]=o[e+1],n[f+2]=o[e+2],n[f+3]=o[e+3],f+=c}else{if(4===t){for(let e=0;e<u;++e){const t=4*s[e];n[f]=o[t],n[f+1]=o[t+1],n[f+2]=o[t+2],n[f+3]=o[t+3],f+=c}return}for(let e=0;e<u;++e){const t=3*s[e];n[f]=o[t],n[f+1]=o[t+1],n[f+2]=o[t+2],n[f+3]=255,f+=c}}else{n[f]=o[0],n[f+1]=o[1],n[f+2]=o[2],n[f+3]=o[3];const e=new Uint32Array(r.typedBuffer.buffer,r.start),t=c/4,s=e[f/=4];f+=t;const l=u*i;for(let r=1;r<l;++r)e[f]=s,f+=t}}function y(e,t,r){const{data:f,indices:i}=e,o=t.typedBuffer,s=t.typedBufferStride,n=i.length,c=f[0];r*=s;for(let u=0;u<n;++u)o[r]=c,r+=s}function w(e,t,r,f,i=1){const o=t.typedBuffer,s=t.typedBufferStride;if(f*=s,1===i)for(let n=0;n<r;++n)o[f]=e[0],o[f+1]=e[1],o[f+2]=e[2],o[f+3]=e[3],f+=s;else for(let n=0;n<r;++n)for(let t=0;t<i;++t)o[f]=e[0],o[f+1]=e[1],o[f+2]=e[2],o[f+3]=e[3],f+=s}function A(e,t,f,o,s,n){for(const c of t.fields.keys()){const t=e.attributes.get(c),u=t?.indices;if(t&&u)p(c,t,f,o,s,n);else if(c===i.VertexAttribute.OBJECTANDLAYERIDCOLOR&&null!=e.objectAndLayerIdColor){const t=e.attributes.get(i.VertexAttribute.POSITION)?.indices;if(t){const f=t.length,i=s.getField(c,r.BufferViewVec4u8);w(e.objectAndLayerIdColor,i,f,n)}}}}function p(e,t,o,n,u,l){switch(e){case i.VertexAttribute.POSITION:{f.assert(3===t.size);const i=u.getField(e,r.BufferViewVec3f);f.assert(!!i,`No buffer view for ${e}`),i&&a(t,o,i,l);break}case i.VertexAttribute.NORMAL:{f.assert(3===t.size);const i=u.getField(e,r.BufferViewVec3f);f.assert(!!i,`No buffer view for ${e}`),i&&B(t,n,i,l);break}case i.VertexAttribute.NORMALCOMPRESSED:{f.assert(2===t.size);const i=u.getField(e,r.BufferViewVec2i16);f.assert(!!i,`No buffer view for ${e}`),i&&s(t,i,l);break}case i.VertexAttribute.UV0:{f.assert(2===t.size);const i=u.getField(e,r.BufferViewVec2f);f.assert(!!i,`No buffer view for ${e}`),i&&s(t,i,l);break}case i.VertexAttribute.COLOR:case i.VertexAttribute.SYMBOLCOLOR:{const i=u.getField(e,r.BufferViewVec4u8);f.assert(!!i,`No buffer view for ${e}`),f.assert(3===t.size||4===t.size),!i||3!==t.size&&4!==t.size||V(t,t.size,i,l);break}case i.VertexAttribute.COLORFEATUREATTRIBUTE:{const i=u.getField(e,r.BufferViewFloat);f.assert(!!i,`No buffer view for ${e}`),f.assert(1===t.size),i&&1===t.size&&y(t,i,l);break}case i.VertexAttribute.TANGENT:{f.assert(4===t.size);const i=u.getField(e,r.BufferViewVec4f);f.assert(!!i,`No buffer view for ${e}`),i&&b(t,n,i,l);break}case i.VertexAttribute.PROFILERIGHT:case i.VertexAttribute.PROFILEUP:case i.VertexAttribute.PROFILEVERTEXANDNORMAL:case i.VertexAttribute.FEATUREVALUE:{f.assert(4===t.size);const i=u.getField(e,r.BufferViewVec4f);f.assert(!!i,`No buffer view for ${e}`),i&&c(t,i,l)}}}e.writeBufferFloat=o,e.writeBufferMat3f=l,e.writeBufferMat4f=d,e.writeBufferVec2=s,e.writeBufferVec3=n,e.writeBufferVec4=c,e.writeBufferVec4Zeros=u,e.writeColor=V,e.writeColorFeatureAttribute=y,e.writeDefaultAttribute=p,e.writeDefaultAttributes=A,e.writeNormal=B,e.writeObjectAndLayerIdColor=w,e.writePosition=a,e.writeTangent=b,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
