/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/mathUtils","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../chunks/vec4f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/buffer/BufferView","../../layers/support/FastSymbolUpdates","../../support/debugFlags","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../core/shaderLibrary/hud/HUD.glsl","../lib/GLTextureMaterial","../lib/Material","../lib/RenderSlot","../lib/screenSizePerspectiveUtils","../lib/Util","../lib/VertexAttribute","./ScaleInfo","./internal/bufferWriterUtils","./internal/MaterialUtil","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique","../shaders/HUDMaterialTechniqueConfiguration"],(function(e,t,r,a,i,s,n,o,c,l,u,f,h,p,d,g,m,S,b,A,O,x,v,V,y,T,P,_,I,R,M,E){"use strict";class C extends x.Material{constructor(e){super(e,new te),this._configuration=new E.HUDMaterialTechniqueConfiguration}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===v.RenderSlot.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===b.ShaderOutput.Color||e===b.ShaderOutput.Alpha),e===b.ShaderOutput.Color&&(this._configuration.debugDrawLabelBorder=!!m.debugFlags.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,r,i,n,o){if(!(r.options.selectionMode&&r.options.hud&&e.visible&&r.point))return;const c=this.parameters,f=r.point,h=r.camera;let{scaleX:p,scaleY:d}=this._getScreenScale(e);p*=h.pixelRatio,d*=h.pixelRatio,a.fromMat4(X,t),e.attributes.has(T.VertexAttribute.FEATUREATTRIBUTE)&&D(X);const g=e.attributes.get(T.VertexAttribute.POSITION),m=e.attributes.get(T.VertexAttribute.SIZE),S=e.attributes.get(T.VertexAttribute.NORMAL),b=e.attributes.get(T.VertexAttribute.AUXPOS1);y.assert(g.size>=3);const A=R.calculateAnchorPosForRendering(c),O="screen"===this.parameters.centerOffsetUnits;for(let a=0;a<g.data.length/g.size;a++){const e=a*g.size;l.set(B,g.data[e],g.data[e+1],g.data[e+2]),l.transformMat4(B,B,t);const i=a*m.size;$[0]=m.data[i]*p,$[1]=m.data[i+1]*d,l.transformMat4(B,B,h.viewMatrix);const n=a*b.size;if(l.set(W,b.data[n],b.data[n+1],b.data[n+2]),!O&&(B[0]+=W[0],B[1]+=W[1],0!==W[2])){const e=W[2];l.normalize(W,B),l.subtract(B,B,l.scale(W,W,e))}const x=a*S.size;if(l.set(N,S.data[x],S.data[x+1],S.data[x+2]),this._normalAndViewAngle(N,X,h,J),this._applyVerticalOffsetTransformationView(B,J,h,z),h.applyProjection(B,H),H[0]>-1){O&&(W[0]||W[1])&&(H[0]+=W[0]*h.pixelRatio,0!==W[1]&&(H[1]+=V.applyScaleFactor(W[1],z.factorAlignment)*h.pixelRatio),h.unapplyProjection(H,B)),H[0]+=this.parameters.screenOffset[0]*h.pixelRatio,H[1]+=this.parameters.screenOffset[1]*h.pixelRatio,H[0]=Math.floor(H[0]),H[1]=Math.floor(H[1]),V.applyPrecomputedScaleFactor($,z.factor,$);const e=K*h.pixelRatio;let t=0;if(c.textureIsSignedDistanceField&&(t=c.outlineSize*h.pixelRatio/2),L(f,H[0],H[1],$,e,t,c,A)){const e=r.ray;if(l.transformMat4(k,B,s.invert(q,h.viewMatrix)),H[0]=f[0],H[1]=f[1],h.unprojectFromRenderScreen(H,B)){const t=u.create();l.copy(t,e.direction);const r=1/l.length(t);l.scale(t,t,r);o(l.distance(e.origin,B)*r,t,-1,!0,1,k)}}}}}intersectDraped(e,t,r,a,i,s){const n=e.attributes.get(T.VertexAttribute.POSITION),o=e.attributes.get(T.VertexAttribute.SIZE),c=this.parameters,l=R.calculateAnchorPosForRendering(c);let{scaleX:u,scaleY:f}=this._getScreenScale(e);u*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const h=Q*e.screenToWorldRatio;for(let p=0;p<n.data.length/n.size;p++){const t=p*n.size,r=n.data[t],d=n.data[t+1],g=p*o.size;$[0]=o.data[g]*u,$[1]=o.data[g+1]*f;let m=0;c.textureIsSignedDistanceField&&(m=c.outlineSize*e.screenToWorldRatio/2),L(a,r,d,$,h,m,c,l)&&i(s.dist,s.normal,-1,!1)}}createBufferWriter(){return new ie(this)}_normalAndViewAngle(e,t,r,i){return h.isMat4(t)&&(t=a.fromMat4(j,t)),l.transformMat3(i.normal,e,t),l.transformMat4(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=l.dot(G,ee),i}_updateScaleInfo(e,t,r){const a=this.parameters;null!=a.screenSizePerspective?V.precomputeScaleFactor(r,t,a.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),null!=a.screenSizePerspectiveAlignment?V.precomputeScaleFactor(r,t,a.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,r,a,i,s,n){const o=this._normalAndViewAngle(t,r,i,J);return this._applyVerticalGroundOffsetView(e,o,i,n),this._applyVerticalOffsetTransformationView(n,o,i,s),this._applyPolygonOffsetView(n,o,a[3],i,n),this._applyCenterOffsetView(n,a,n),n}applyShaderOffsetsNDC(e,t,r,a,i){return this._applyCenterOffsetNDC(e,t,r,a),null!=i&&l.copy(i,a),this._applyPolygonOffsetNDC(a,t,r,a),a}_applyPolygonOffsetView(e,t,a,i,s){const n=i.aboveGround?1:-1;let o=Math.sign(a);0===o&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return l.copy(s,e);const u=r.clamp(Math.abs(t.cosAngle),.01,1),f=1-Math.sqrt(1-u*u)/u/i.viewport[2];return c>0?l.scale(s,e,f):l.scale(s,e,1/f),s}_applyVerticalGroundOffsetView(e,t,r,a){const i=l.length(e),s=r.aboveGround?1:-1,n=r.computeRenderPixelSizeAtDist(i)*A.HUDVerticalPixelOffset,o=l.scale(B,t.normal,s*n);return l.add(a,e,o),a}_applyVerticalOffsetTransformationView(e,t,r,a){const i=this.parameters;if(!i.verticalOffset?.screenLength){if(i.screenSizePerspective||i.screenSizePerspectiveAlignment){const r=l.length(e);this._updateScaleInfo(a,r,t.cosAngle)}else a.factor.scale=1,a.factorAlignment.scale=1;return e}const s=l.length(e),n=i.screenSizePerspectiveAlignment??i.screenSizePerspective,o=I.verticalOffsetAtDistance(r,s,i.verticalOffset,t.cosAngle,n);return this._updateScaleInfo(a,s,t.cosAngle),l.scale(t.normal,t.normal,o),l.add(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const a="screen"!==this.parameters.centerOffsetUnits;return r!==e&&l.copy(r,e),a&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(l.normalize(N,r),l.add(r,r,l.scale(N,N,t[2])))),r}_applyCenterOffsetNDC(e,t,r,a){const i="screen"!==this.parameters.centerOffsetUnits;return a!==e&&l.copy(a,e),i||(a[0]+=t[0]/r.fullWidth*2,a[1]+=t[1]/r.fullHeight*2),a}_applyPolygonOffsetNDC(e,t,r,a){const i=this.parameters.shaderPolygonOffset;if(e!==a&&l.copy(a,e),i){const e=r.aboveGround?1:-1,s=e*Math.sign(t[3]);a[2]-=(s||e)*i}return a}produces(e,t){if(t===b.ShaderOutput.Color||t===b.ShaderOutput.Alpha||t===b.ShaderOutput.Highlight||t===b.ShaderOutput.ObjectAndLayerIdColor){if(e===v.RenderSlot.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?v.RenderSlot.LABEL_MATERIAL:v.RenderSlot.HUD_MATERIAL)||r&&e===v.RenderSlot.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new U(e)}calculateRelativeScreenBounds(e,t,r=p.create()){return w(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}_getScreenScale(e){const t=e.attributes.get(T.VertexAttribute.FEATUREATTRIBUTE);if(null==t)return{scaleX:1,scaleY:1};const r=f.fromArray(t.data,Z),[a,i]=g.evaluateModelTransformScale(Y,this.parameters,r);return{scaleX:a,scaleY:i}}}class U extends O.GLTextureMaterial{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(M.HUDMaterialTechnique,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function w(e,t,r,a=F){return o.copy(a,e.anchorPosition),a[0]*=-t[0],a[1]*=-t[1],a[0]+=e.screenOffset[0]*r,a[1]+=e.screenOffset[1]*r,a}function D(e){const t=e[0],r=e[1],a=e[2],i=e[3],s=e[4],n=e[5],o=e[6],c=e[7],l=e[8],u=1/Math.sqrt(t*t+r*r+a*a),f=1/Math.sqrt(i*i+s*s+n*n),h=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*u,e[1]=r*u,e[2]=a*u,e[3]=i*f,e[4]=s*f,e[5]=n*f,e[6]=o*h,e[7]=c*h,e[8]=l*h,e}function L(e,t,r,a,i,s,n,o){let c=t-i-(o[0]>0?a[0]*o[0]:0),l=c+a[0]+2*i,u=r-i-(o[1]>0?a[1]*o[1]:0),f=u+a[1]+2*i;const h=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&null!=h&&(c+=a[0]*h[0],u+=a[1]*h[1],l-=a[0]*(1-h[2]),f-=a[1]*(1-h[3]),c-=s,l+=s,u-=s,f+=s),e[0]>c&&e[0]<l&&e[1]>u&&e[1]<f}const z=new P.ScaleInfo,F=c.create(),B=u.create(),N=u.create(),H=f.create(),G=u.create(),k=u.create(),X=i.create(),j=i.create(),q=n.create(),W=u.create(),Y=f.create(),Z=f.create(),J={normal:G,cosAngle:0},K=1,Q=2,$=[0,0],ee=u.fromValues(0,0,1);class te extends O.GLTextureMaterialBindParameters{constructor(){super(...arguments),this.renderOccluded=x.RenderOccludedFlag.Occlude,this.isDecoration=!1,this.color=f.fromValues(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=c.fromValues(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=f.fromValues(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const re=S.newLayout().vec3f(T.VertexAttribute.POSITION).vec3f(T.VertexAttribute.NORMAL).vec2f(T.VertexAttribute.UV0).vec4u8(T.VertexAttribute.COLOR).vec2f(T.VertexAttribute.SIZE).vec4f(T.VertexAttribute.AUXPOS1).vec4f(T.VertexAttribute.FEATUREATTRIBUTE),ae=re.clone().vec4u8(T.VertexAttribute.OBJECTANDLAYERIDCOLOR);class ie{constructor(e){this._material=e,this.vertexBufferLayout=t("enable-feature:objectAndLayerId-rendering")?ae:re}elementCount(e){return 6*e.attributes.get(T.VertexAttribute.POSITION).indices.length}write(e,t,r,a,i){_.writePosition(r.attributes.get(T.VertexAttribute.POSITION),e,a.position,i,6),_.writeNormal(r.attributes.get(T.VertexAttribute.NORMAL),t,a.normal,i,6);const s=r.attributes.get(T.VertexAttribute.UV0).data;let n,o,c,l;if(null==s||s.length<4){const e=this._material.parameters;n=0,o=0,c=e.texCoordScale[0],l=e.texCoordScale[1]}else n=s[0],o=s[1],c=s[2],l=s[3];c=Math.min(1.99999,c+1),l=Math.min(1.99999,l+1);let u=r.attributes.get(T.VertexAttribute.POSITION).indices.length,f=i;const h=a.uv0;for(let d=0;d<u;++d)h.set(f,0,n),h.set(f,1,o),f++,h.set(f,0,c),h.set(f,1,o),f++,h.set(f,0,c),h.set(f,1,l),f++,h.set(f,0,c),h.set(f,1,l),f++,h.set(f,0,n),h.set(f,1,l),f++,h.set(f,0,n),h.set(f,1,o),f++;_.writeColor(r.attributes.get(T.VertexAttribute.COLOR),4,a.color,i,6);const{data:p,indices:g}=r.attributes.get(T.VertexAttribute.SIZE);u=g.length;const m=a.size;f=i;for(let d=0;d<u;++d){const e=p[2*g[d]],t=p[2*g[d]+1];for(let r=0;r<6;++r)m.set(f,0,e),m.set(f,1,t),f++}if(r.attributes.get(T.VertexAttribute.AUXPOS1)?_.writeBufferVec4(r.attributes.get(T.VertexAttribute.AUXPOS1),a.auxpos1,i,6):_.writeBufferVec4Zeros(a.auxpos1,i,6*u),r.attributes.get(T.VertexAttribute.FEATUREATTRIBUTE)?_.writeBufferVec4(r.attributes.get(T.VertexAttribute.FEATUREATTRIBUTE),a.featureAttribute,i,6):_.writeBufferVec4Zeros(a.featureAttribute,i,6*u),null!=r.objectAndLayerIdColor){const e=r.attributes.get(T.VertexAttribute.POSITION)?.indices;if(e){const t=e.length,s=a.getField(T.VertexAttribute.OBJECTANDLAYERIDCOLOR,d.BufferViewVec4u8);_.writeObjectAndLayerIdColor(r.objectAndLayerIdColor,s,t,i,6)}}}}e.HUDMaterial=C,e.Parameters=te,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
