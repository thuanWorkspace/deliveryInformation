/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/tslib.es6","../../../../geometry","../../../../analysis/featureReferenceUtils","../../../../core/Accessor","../../../../core/asyncUtils","../../../../core/Evented","../../../../core/Handles","../../../../core/handleUtils","../../../../core/Logger","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/reactiveUtils","../../../../core/accessorSupport/decorators/property","../../../../core/accessorSupport/ensureType","../../../../core/arrayUtils","../../../../core/has","../../../../core/accessorSupport/decorators/subclass","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../core/support/UpdatingHandles","../../../../geometry/projection","../../../../geometry/projection/projectBoundingRect","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/ray","../../../../support/elevationInfoUtils","../LineOfSightAnalysisResult","./LineOfSightComputation","./LineOfSightRayIntersector","../support/projectionUtils","../../webgl-engine/lib/IntersectorInterfaces","../../webgl-engine/lib/intersectorUtilsConversions","../../../support/Scheduler","../../../../geometry/Point"],(function(e,t,n,o,i,r,s,a,l,c,d,u,p,g,h,v,_,f,m,y,b,C,O,I,T,S,P,R,L,w,A,H,E,F){"use strict";const j="esri.views.3d.analysis.LineOfSight.LineOfSightController",V=c.getLogger(j);e.LineOfSightController=class extends(s.EventedMixin(i)){constructor(e){super(e),this.updateOnCameraChange=!0,this._observerGroundOffsetRenderSpace=0,this._effectiveObserverElevationMode="absolute-height",this._observerFeatureId=null,this._updatingHandles=new b.UpdatingHandles,this._frameTask=E.ImmediateTask,this._computationHandles=new a,this._externalObserverUpdate=!0}initialize(){const e=this.view.resourceController?.scheduler;this._frameTask=e?e.registerTask(E.TaskPriority.LINE_OF_SIGHT_TOOL):E.ImmediateTask,this._intersector=new L.LineOfSightRayIntersector({view:this.view}),this.addHandles([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(e){this._frameTask.priority=e}get _computations(){return this.analysisViewData.computations}get _elevationAlignedObserverPositionRenderSpace(){return this.analysisViewData.observerEngineLocation}set _elevationAlignedObserverPositionRenderSpace(e){this.analysisViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}_computeResult(e){const t=e.computation,{inputPoints:n,computationResult:o}=t,{observerAdjusted:i,targetAdjusted:r}=n,{start:s,end:a}=o;m.copy(s,i),m.copy(a,r);this._canCompute(t)?this._computeIntersection(e):this._interpolateIntersection(e),t.notifyResultChanged(),this.emit("result-changed",{target:e.computation.target,result:t.result})}_updateAdjustedPointsFromFeatures(e){const t=this.view,{sceneIntersectionHelper:n}=t,{inputPoints:i}=e,{observerAdjusted:r,observerFeatureId:s,targetFeatureId:a,targetAdjusted:l}=i;if(null==s&&null==a)return;const c=m.distance(r,l),d=this._intersector.intersector,u=T.fromPoints(i.observer,i.target,D);d.options.store=A.StoreResults.ALL,n.intersectToolIntersectorRay(u,d);let p=null,g=null,h=null,v=null;for(const _ of d.results.all){const e=H.toGraphic(_,this.view);if(null==e||null==_.distanceInRenderSpace)continue;const n=o.getFeatureId(e);null!=n&&(null!=s&&n===s&&(null==p&&(p=this._getFeatureDistanceThreshold(_,t,c)),_.distanceInRenderSpace<p&&(h=_)),null!=a&&n===a&&(null==g&&(g=this._getFeatureDistanceThreshold(_,t,c)),null==v&&_.distanceInRenderSpace<c&&c-_.distanceInRenderSpace<g&&(v=_)))}null!=h&&h.getIntersectionPoint(r)&&(i.observerSurfaceNormal=h.getTransformedNormal(y.create())),null!=v&&v.getIntersectionPoint(l)&&(i.targetSurfaceNormal=v.getTransformedNormal(y.create()))}_getFeatureDistanceThreshold(e,t,n){if(H.hasLod(e)){const o=H.getIntersectedFeatureBSRadius(e,t);if(null!=o)return Math.min(o*N,n)}return 1e-5*n}_adjustStartEndPositions(e){const t=this._screenPixelSize,n=this.view,{inputPoints:o}=e,{observer:i,observerSurfaceNormal:r,target:s,targetSurfaceNormal:a,observerAdjusted:l,targetAdjusted:c}=o,d=k;m.copy(l,i),m.copy(c,s),this._updateAdjustedPointsFromFeatures(e),null!=r?m.copy(d,r):m.subtract(d,c,l);const u=t;m.normalize(d,d),m.scale(d,d,Math.min(u,1)),m.add(l,l,d),null!=a?m.copy(d,a):m.subtract(d,l,c);const p=n.state.camera.computeScreenPixelSizeAt(c);m.normalize(d,d),m.scale(d,d,Math.min(p,1)),m.add(c,c,d)}_computeIntersection({computation:e,interpolationInfo:t}){const{view:n}=this,{sceneIntersectionHelper:o,renderCoordsHelper:i}=n;if(null==o)return;const r=this._intersector.intersector,{computationResult:s,inputPoints:a}=e,{observer:l,target:c}=a,{start:d,end:u}=s,p=T.fromPoints(d,u,D);r.options.store=A.StoreResults.MIN,o.intersectToolIntersectorRay(p,r);const g=r.results.min,h=s.intersection,v=k;let _=!0;if(null!=g&&g.getIntersectionPoint(h)){m.copy(t.originalIntersection,h),m.copy(t.originalObserver,d),m.copy(t.originalTarget,u),i.fromRenderCoords(h,v,n.spatialReference);const e=1-m.dist(u,c)/m.dist(d,c);_=m.dist(l,h)>=e*m.dist(l,c)}const f=new F(v,n.spatialReference);{const{result:t,target:o}=e;null!=t?(t.target=o,t.intersectedGraphic=_?null:H.toGraphic(g,n),t.intersectedLocation=_?null:f,t.visible=_):e.result=new P.LineOfSightAnalysisResult({target:o,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:_?null:H.toGraphic(g,n),intersectedLocation:_?null:f,visible:_})}s.isValid=a.isValid=!0,s.isTargetVisible=_}_interpolateIntersection({computation:e,interpolationInfo:t}){const{computationResult:n,inputPoints:o}=e,{start:i,end:r,intersection:s}=n,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(m.copy(s,a),o.isValid){const e=k,t=m.dist(l,a)/m.dist(l,c);m.sub(e,i,l),m.scale(e,e,1-t),m.add(s,s,e),m.sub(e,r,c),m.scale(e,e,t),m.add(s,s,e),n.isValid=!0}else e.result=null,n.isValid=!1,n.isTargetVisible=!1}_canCompute(e){const t=this.analysisViewData.elevationAlignedObserver,n=this.view.frustum;if(null==t||null==e.elevationAlignedTargetLocation||null==n)return!1;const{observerAdjusted:o,targetAdjusted:i}=e.inputPoints,r=n.intersectsPoint(o),s=n.intersectsPoint(i);return r&&s}_onObserverPositionChange(e,t,n,i,r){if(this._externalObserverUpdate=r,null==e)return this.analysisViewData.elevationAlignedObserver=null,void(this._observerFeatureId=null);if(null==t)return w.logFailedGeometryProjectionError(this.analysis,e.spatialReference,V),void(this.analysisViewData.elevationAlignedObserver=null);const s=this._getEffectiveElevationInfo(t,n),{absoluteZ:a,elevation:l}=S.zValueInAbsoluteHeightMode(t.x,t.y,t.z,this.view.spatialReference,this.view,s),c=t.clone();c.z=a,this._effectiveObserverElevationMode=s.mode,this.analysisViewData.elevationAlignedObserver=c;const d=y.create();this.view.renderCoordsHelper.toRenderCoords(c,d),this._elevationAlignedObserverPositionRenderSpace=d,this._observerGroundOffsetRenderSpace=a-l,this._observerFeatureId=o.getFeatureId(i),this.priority=E.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onObserverRenderSpacePositionChangeForComputation(e,t,n,o,i){const{inputPoints:r}=e;switch(m.copy(r.observer,t),r.observerFeatureId=i,r.observerSurfaceNormal=null,o){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(r.observer,n,r.observer);null==r.observerFeatureId&&(r.observerSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=E.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(e,t,n,i,r,s=!0){const a=e.inputPoints;if(s&&(a.isValid=!1),null==n)return null!=t&&w.logFailedGeometryProjectionError(this.analysis,t.spatialReference,V),e.elevationAlignedTargetLocation=null,void e.notifyInputPointsChanged();const l=this._getEffectiveElevationInfo(n,i),{absoluteZ:c,elevation:d}=S.zValueInAbsoluteHeightMode(n.x,n.y,n.z,this.view.spatialReference,this.view,l),u=n.clone();switch(u.z=c,e.elevationAlignedTargetLocation=u,this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,a.target),a.targetFeatureId=o.getFeatureId(r),a.targetSurfaceNormal=null,l.mode){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(a.target,c-d,a.target);null==a.targetFeatureId&&(a.targetSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=E.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectComputationToTarget(e){return l.handlesGroup([this._updatingHandles.add((()=>({computation:e,targetPosition:e.target.position,targetElevationInfo:e.target.elevationInfo,targetFeatureInfo:e.target.feature,projectedTargetPosition:C.projectOrLoad(e.target.position,this.view.spatialReference)})),(({computation:e,targetPosition:t,targetElevationInfo:n,targetFeatureInfo:o,projectedTargetPosition:i})=>{null==i.pending?this._onTargetPositionChange(e,t,i.geometry,n,o):this._updatingHandles.addPromise(i.pending)}),p.initial)])}_connectComputationToObserver(e){return this._updatingHandles.add((()=>({computation:e,observer:this.analysisViewData.elevationAlignedObserver})),(({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())}),p.initial)}_connectComputationToRenderSpaceObserver(e){return this._updatingHandles.add((()=>({computation:e,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId})),(({computation:e,observer:t,observerGroundOffset:n,observerElevationMode:o,observerFeatureId:i})=>{this._onObserverRenderSpacePositionChangeForComputation(e,t,n,o,i)}),p.initial)}_connectComputationToCamera(e){return this._updatingHandles.add((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{!this.updateOnCameraChange||e.inputPoints.isValid&&!t||e.notifyInputPointsChanged()}))}_connectComputationToSlicePlane(e){return this._updatingHandles.add((()=>this.view.slicePlane),(()=>{e.inputPoints.isValid=!1,e.notifyInputPointsChanged()}))}_connectComputationToElevation(e){const t=(n,o)=>{const i=this.analysis.observer,r=e.target;let s=null,a=null,l=null,c=null,d=null,u=null;if(null!=i?.position){const e=C.projectOrLoad(i.position,this.view.spatialReference);if(null!=e.pending)return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(n,o)));s=e.geometry,a=i.elevationInfo,l=i.feature}if(null!=r.position){const e=C.projectOrLoad(r.position,this.view.spatialReference);if(null!=e.pending)return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(n,o)));c=e.geometry,d=r.elevationInfo,u=r.feature}null==s&&null==c||(O.projectBoundingRect(n,o,x,this.view.spatialReference),null!=s&&I.containsPointObject(x,s)&&this._onObserverPositionChange(null!=i?i.position:null,s,a,l,!1),null!=c&&I.containsPointObject(x,c)&&this._onTargetPositionChange(e,r.position,c,d,u,!1),null!=s&&null!=c&&I.intersectsSegment(x,s,c)&&e.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",(e=>t(e.extent,e.spatialReference)))}_connectComputationToTask(e){let t=null;const n={computation:e,interpolationInfo:{originalIntersection:y.create(),originalObserver:y.create(),originalTarget:y.create()}};return l.handlesGroup([this._updatingHandles.add((()=>e.inputPoints),(()=>{t=d.abortMaybe(t),t=r.createTask((async e=>{await u.ignoreAbortErrors(this._frameTask.schedule((()=>this._computeResult(n)),e))}))}),{initial:!0,equals:()=>!1}),l.makeHandle((()=>t=d.abortMaybe(t)))])}_connectComputation(e){const t=this._computationHandles;t.has(e)||t.add([this._connectComputationToTarget(e),this._connectComputationToObserver(e),this._connectComputationToRenderSpaceObserver(e),this._connectComputationToCamera(e),this._connectComputationToSlicePlane(e),this._connectComputationToElevation(e),this._connectComputationToTask(e)],e)}_disconnectComputation(e){this._computationHandles.remove(e)}_onComputationCollectionChange({added:e,removed:t}){for(const n of t)this._disconnectComputation(n);for(const n of e)this._connectComputation(n)}_onTargetCollectionChange({added:e,removed:t}){for(const n of t)this._removeTarget(n);for(const n of e)this._addTarget(n)}_onCursorTargetChange(e,t){null!=t&&this._removeTarget(t),null!=e&&this._addTarget(e)}_addTarget(e){this._computations.some((t=>t.target===e))||this._computations.add(new R.LineOfSightComputation({target:e}))}_removeTarget(e){const t=this._computations.findIndex((t=>t.target===e));this._computations.removeAt(t)}_connectObserver(){return l.handlesGroup([this._updatingHandles.add((()=>({observerPosition:null!=this.analysis.observer?this.analysis.observer.position:null,projectedObserverPosition:C.projectOrLoad(null!=this.analysis.observer?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:null!=this.analysis.observer?this.analysis.observer.elevationInfo:null,observerFeatureInfo:null!=this.analysis.observer?this.analysis.observer.feature:null})),(({observerPosition:e,projectedObserverPosition:t,observerElevationInfo:n,observerFeatureInfo:o})=>{null==t.pending?this._onObserverPositionChange(e,t.geometry,n,o,!0):this._updatingHandles.addPromise(t.pending)}),p.initial)])}_connectComputations(){return this._updatingHandles.addOnCollectionChange((()=>this._computations),(e=>this._onComputationCollectionChange(e)),{initial:!0,final:!0})}_connectTargets(){return l.handlesGroup([this._updatingHandles.addOnCollectionChange((()=>this.analysis.targets),(e=>this._onTargetCollectionChange(e)),{initial:!0,final:!0}),this._updatingHandles.add((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)}))])}get _isCameraDirty(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:n}=t;if(null==e||null==n)return!1;const o=k;n.toRenderCoords(e,o);const i=t.state.camera.computeScreenPixelSizeAt(o);return Math.abs((i-this._screenPixelSize)/this._screenPixelSize)>G}_getEffectiveElevationInfo(e,t){return e.hasZ?t??{mode:"absolute-height",offset:0}:{mode:"on-the-ground",offset:0}}},t.__decorate([g.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysis",void 0),t.__decorate([g.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysisViewData",void 0),t.__decorate([g.property({constructOnly:!0})],e.LineOfSightController.prototype,"view",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"updating",null),t.__decorate([g.property()],e.LineOfSightController.prototype,"priority",null),t.__decorate([g.property()],e.LineOfSightController.prototype,"updateOnCameraChange",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_computations",null),t.__decorate([g.property()],e.LineOfSightController.prototype,"_elevationAlignedObserverPositionRenderSpace",null),t.__decorate([g.property()],e.LineOfSightController.prototype,"_observerGroundOffsetRenderSpace",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_effectiveObserverElevationMode",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_observerFeatureId",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_screenPixelSize",null),t.__decorate([g.property({readOnly:!0})],e.LineOfSightController.prototype,"_updatingHandles",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_frameTask",void 0),t.__decorate([g.property()],e.LineOfSightController.prototype,"_isCameraDirty",null),e.LineOfSightController=t.__decorate([f.subclass(j)],e.LineOfSightController);const G=.1,k=y.create(),D=T.create(),x=I.empty(),N=.05;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
