/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/quantityUtils","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/vec4f64","../../../../../geometry/ellipsoidUtils","../../../../../geometry/projection","../../../../../geometry/SpatialReference","../../../../../geometry/spatialReferenceEllipsoidUtils","../../../../../geometry/projection/projectDirection","../../../../../geometry/projection/projectPointToVector","../../../../../geometry/projection/projectPointToWGS84ComparableLonLat","../../../../../geometry/projection/projectVectorToVector","../../../../../geometry/support/Axis","../../../../../geometry/support/Indices","../../../../../geometry/support/intersectsBase","../../../../../geometry/support/triangle","../../interfaces","../../support/measurementUtils","../../support/viewUtils","../../../support/ElevationProvider","../../../support/mathUtils","../../../../support/euclideanAreaMeasurementUtils"],(function(e,t,s,i,o,r,n,h,a,d,c,l,g,p,m,u,_,C,S,L,P,f,M,R,A,V){"use strict";class j{get numVertices(){return this._length}get hasStagedVertex(){return this._hasCursorPoint}constructor(e,t){this.validMeasurement=!1,this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=n.create(),this.areaCentroidRenderCoords=n.create(),this.geodesicAreaCentroidRenderCoords=n.create(),this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=n.create(),this._planeWorldCoords=h.create(),this._worldUp=n.create(),this._worldTangent=n.create(),this._frame=[n.create(),n.create(),n.create()],this._pathVersion=-1,this._hasCursorPoint=!1,this._mode=null,this._tempU=n.create(),this._tempV=n.create(),this._tempVec3=n.create(),this._tempSphere={center:n.create(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,t,s,i,o,r){const n=null!=t,h=this._pathVersion===e.version,a=this._hasCursorPoint===n,d=this._mode===o;return!(h&&!r&&a&&d&&e.isValidPolygon)&&(this._pathVersion=e.version,this._hasCursorPoint=n,this._updateCursorSegmentLength(e,t),this._update(e,t,s,i,o),!0)}_update(e,t,i,o,n){const h=this.unitNormalizer,a=this._sceneView.renderSpatialReference,c=this.unitNormalizer.spatialReference;let g=e.numVertices;const u=!(null==t||t.equals(e.lastPoint)||g>2&&t.equals(e.firstPoint));u&&(g+=1);const _=!e.polygonIsClosed&&g>2,C=e.polygonIsClosed||_;this._resize(g);const S=l.getSphericalPCPF(i.spatialReference),L=d.canProjectWithoutEngine(i.spatialReference,S)&&d.canProjectToWGS84ComparableLonLat(i.spatialReference),{positionsGeographic:P,positionsWorldCoords:f,positionsRenderCoords:M,positionsSpherical:R}=this,A=(e,t)=>{v(i.elevationProvider,e),p.projectPointToVector(e,f[t],c),p.projectPointToVector(e,M[t],a),L&&(m.projectPointToWGS84ComparableLonLat(e,P[t]),p.projectPointToVector(e,R[t],S),r.normalize(R[t],R[t]))};e.forEachVertexPosition(((e,t)=>A(e,t))),u&&A(t,g-1);const V=this._updatePathLengths(C);if(this.pathLength=this._length>1?s.createLength(h.normalizeDistance(V),"meters"):null,L){const e=this._updateGeodesicPathLengths(C,c);this.geodesicPathLength=this._length>1?s.createLength(e,"meters"):null}else this.geodesicPathLength=null;if(this._updateMode(n),!C)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),void(this.validMeasurement=!1);this._updateAreaAndPerimeterLength(i,h,a,c,o),L&&this._updateGeodesicArea(i),this.validMeasurement=!0}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(n.create()),this.positionsRenderCoords.push(n.create()),this.positionsProjectedWorldCoords.push(o.create()),this.positionsFittedRenderCoords.push(n.create()),this.positionsGeographic.push(n.create()),this.positionsSpherical.push(n.create()),this.positionsStereographic.push(o.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=r.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=n)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=f.segmentLengthGeodesicVector(s[r],s[(r+1)%this._length],t??void 0);(r<this._length-1||e)&&(o+=n)}return o}_updateAreaAndPerimeterLength(e,t,o,n,h){const a=e.renderCoordsHelper,d=this.positionsWorldCoords,c=this.positionsRenderCoords,l=this.positionsProjectedWorldCoords,p=this.positionsFittedRenderCoords,m=this._planeWorldCoords,C=this._centroidRenderCoords;M.midpoint(c,C),a.worldUpAtPosition(C,this._worldUp),a.worldBasisAtPosition(C,_.Axis.X,this._worldTangent),g.projectDirection(C,this._worldUp,o,this._worldUp,n),g.projectDirection(C,this._worldTangent,o,this._worldTangent,n),d.length>2&&f.bestFitPlane(d,m),this.fittingMode=this._selectFittingMode(m,d,this._worldUp,h);let S=0;if("horizontal"===this.fittingMode){let e=-1/0;c.forEach(((t,s)=>{const i=a.getAltitude(c[s]);i>e&&(e=i,S=s)}))}const L=d[S];let P=m,R=this._worldTangent;"horizontal"===this.fittingMode?P=this._worldUp:"vertical"===this.fittingMode&&(P=this._tempVec3,R=this._worldUp,A.makeOrthonormal(m,this._worldUp,P)),r.copy(this._frame[2],P),A.makeOrthonormal(R,P,this._frame[0]),r.cross(this._frame[1],this._frame[0],this._frame[2]),r.negate(this._frame[1],this._frame[1]);const V=this._tempVec3,j=this._tempU,v=this._tempV;for(let s=0;s<this._length;++s){const e=l[s],t=p[s];r.subtract(V,d[s],L),i.set(e,r.dot(this._frame[0],V),r.dot(this._frame[1],V)),r.scale(j,this._frame[0],e[0]),r.scale(v,this._frame[1],e[1]),r.add(V,j,v),r.add(V,V,L),u.projectVectorToVector(V,n,t,o)}this.perimeterLength=this._length>0?s.createLength(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,M.midpoint(p,this.areaCentroidRenderCoords),u.projectVectorToVector(this.areaCentroidRenderCoords,o,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?s.createArea(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const{renderCoordsHelper:t,spatialReference:o}=e,{positionsSpherical:n,positionsStereographic:h}=this,d=this._tempVec3,c=f.fitHemisphere(n,d);if(!c)return void(this.geodesicArea=null);const g=this._tempU,p=this._tempV;A.tangentFrame(d,g,p);for(let s=0;s<this._length;++s){const e=r.dot(n[s],g),t=r.dot(n[s],p),o=r.dot(n[s],d);i.set(h[s],e/o,t/o)}r.scale(d,d,a.getReferenceEllipsoid(o).radius),t.toRenderCoords(d,l.getSphericalPCPF(o),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=c&&0===this.geodesicIntersectingSegments.size?s.createArea(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let o=0;o<this._length;++o){s+=t[o]=i.distance(e[o],e[(o+1)%this._length])}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];S.segmentIntersects(o,r,n,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=this.triangleIndices=C.compactIndices(V.triangulate(e));let s=0;for(let i=0;i<t.length;i+=3)s+=L.areaPoints2d(e[t[i]],e[t[i+1]],e[t[i+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];S.segmentIntersects(o,r,n,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=this.positionsStereographic,s=this.geodesicTriangleIndices=C.compactIndices(V.triangulate(t));let i=0;for(let o=0;o<s.length;o+=3)i+=f.triangleAreaGeodesic(e[s[o]],e[s[o+1]],e[s[o+2]],c.WGS84);return i}_selectFittingMode(e,s,i,o){const n=s.map((t=>Math.abs(f.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);f.boundingSphere(s,this._tempSphere);const h=n/(2*this._tempSphere.radius),a=h<o.maxRelativeErrorCoplanar,d=h<o.maxRelativeErrorAlmostCoplanar;let c="horizontal";if(a)c="oblique";else if(d){c=Math.abs(r.dot(i,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return c}_updateCursorSegmentLength(e,t){const i=e.lastPoint;e.isValidPolygon||null==i||null==t?(this.geodesicStagedSegmentLength=null,this.stagedSegmentLength=null):(this.geodesicStagedSegmentLength=s.createLength(f.segmentLengthGeodesic(i,t),"meters"),this.stagedSegmentLength=s.createLength(this.unitNormalizer.normalizeDistance(f.segmentLengthEuclidean(i,t,this.unitNormalizer.spatialReference)),"meters"))}_updateMode(e){if(e===P.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let e=0;null!=this.geodesicPathLength&&(e+=this.geodesicPathLength.value),e>W&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=e===P.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=e}}function v(e,t){t.hasZ||(t.z=R.getElevationAtPoint(e,t,"ground")??0)}const W=1e5;e.MeasurementDataManager=j,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
