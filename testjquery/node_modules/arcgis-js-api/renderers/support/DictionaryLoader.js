/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../Color","../../request","../../core/Error","../../core/has","../../core/Logger","../../core/LRUCache","../../core/promiseUtils","../../core/string","../../core/Version","../../layers/support/FieldsIndex","../../support/arcadeOnDemand","../../symbols/CIMSymbol"],(function(e,t,i,s,o,r,n,l,a,c,h,u,y){"use strict";const f="esri.renderers.support.DictionaryLoader",m={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class d{constructor(e,t,i){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new n.LRUCache(100),this._dictionaryVersion=null,this._fieldIndex=null,this._dictionaryPromise=null,this.url=e,this.config=t,this.fieldMap=i}getSymbolFields(){return this._symbolFields}async getSymbolAsync(e,i){let s;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(i));try{s=await this._dictionaryPromise}catch(p){if(l.isAbortError(p))return this._dictionaryPromise=null,null}const o=this._dictionaryVersion&&this._dictionaryVersion.since(4,0),r={};if(this.fieldMap)for(const t of this._symbolFields){const i=this._getFieldName(this.fieldMap[t]);if(i){const s=e.attributes[i];r[t]=o?s:null!=s?""+e.attributes[i]:""}else r[t]=""}let n=null;try{n=s?.(r,i)}catch(g){return null}if(!n||"string"!=typeof n)return null;const c=a.numericHash(n).toString(),h=this._symbolCache.get(c);if(h)return h.catch((()=>{this._symbolCache.pop(c)})),h;const u=n.split(";"),y=[],f=[];for(const l of u)if(l)if(l.includes("po:")){const e=l.substr(3).split("|");if(3===e.length){const i=e[0],s=e[1];let o=e[2];if("DashTemplate"===s)o=o.split(" ").map((e=>Number(e)));else if("Color"===s){const e=new t(o).toRgba();o=[e[0],e[1],e[2],255*e[3]]}else o=Number(o);f.push({primitiveName:i,propertyName:s,value:o})}}else if(l.includes("|")){for(const e of l.split("|"))if(this._itemNames.has(e)){y.push(e);break}}else this._itemNames.has(l)&&y.push(l);const m=null==e.geometry||!e.geometry.hasZ&&"point"===e.geometry.type,d=this._cimPartsToCIMSymbol(y,f,m,i);return this._symbolCache.put(c,d,1),d}async fetchResources(e){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void r.getLogger(f).error("no valid URL!");const t=i(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:null!=e?e.signal:null}),[{data:o}]=await Promise.all([t,u.loadArcade()]);if(!o)throw this._dictionaryPromise=null,new s("esri.renderers.DictionaryRenderer","Bad dictionary data!");const{authoringInfo:n,dictionary_version:l,expression:a,itemsNames:y}=o,m=a;let d=!1;l&&(this._dictionaryVersion=c.Version.parse(l),d=this._dictionaryVersion.since(4,0)),this._refSymbolUrlTemplate=this.url+"/"+o.cimRefTemplateUrl,this._itemNames=new Set(y),this._symbolFields=n.symbol;const p={};if(this.config){const e=this.config;for(const t in e)p[t]=e[t]}if(n.configuration)for(const i of n.configuration)p.hasOwnProperty(i.name)||(p[i.name]=i.value);const g=[];if(e?.fields&&this.fieldMap)for(const i of this._symbolFields){const t=this.fieldMap[i],s=e.fields.filter((e=>e.name.toLowerCase()===t?.toLowerCase()));s.length>0&&g.push({...s[0],type:d?s[0].type:"esriFieldTypeString"})}g.length>0&&(this._fieldIndex=new h(g));const b=u.createDictionaryExpression(m,null!=e?e.spatialReference:null,g,p).then((e=>{const t={scale:0};return(i,s)=>{if(null==e)return null;const o=e.repurposeFeature({geometry:null,attributes:i});return t.scale=null!=s?s.scale??void 0:void 0,e.evaluate({$feature:o,$view:t},e.services)}})).catch((e=>(r.getLogger(f).error("Creating dictinoary expression failed:",e),null)));return this._dictionaryPromise=b,b}async _cimPartsToCIMSymbol(e,t,i,s){const o=new Array(e.length);for(let l=0;l<e.length;l++)o[l]=this._getSymbolPart(e[l],s);const r=await Promise.all(o),n=this.fieldMap;if(n)for(const l of r)p(l,n);return new y({data:this._combineSymbolParts(r,t,i)})}async _getSymbolPart(e,t){if(this._ongoingRequests.has(e))return this._ongoingRequests.get(e).then((e=>e.data));const s=this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi,e),o=i(s,{responseType:"json",query:{f:"json"},...t});this._ongoingRequests.set(e,o);try{return(await o).data}catch(r){throw this._ongoingRequests.delete(e),r}}_combineSymbolParts(e,t,i){if(!e||0===e.length)return null;const s={...e[0]};if(e.length>1){s.symbolLayers=[];for(const t of e){const e=t;s.symbolLayers.unshift(...e.symbolLayers)}}return i&&(s.callout=m),{type:"CIMSymbolReference",symbol:s,primitiveOverrides:t}}_getFieldName(e){if(null!==this._fieldIndex){const t=this._fieldIndex.get(e);return t?t.name:e}return e}}function p(e,t){if(!e)return;const i=e.symbolLayers;if(!i)return;let s=i.length;for(;s--;){const e=i[s];if(e&&!1!==e.enable&&"CIMVectorMarker"===e.type)g(e,t)}}function g(e,t){const i=e.markerGraphics;if(i)for(const s of i){if(!s)continue;const e=s.symbol;if(e)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":p(e,t);break;case"CIMTextSymbol":e.fieldMap=t}}}e.DictionaryLoader=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
