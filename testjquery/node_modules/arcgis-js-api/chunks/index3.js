/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports"],(function(t){"use strict";
/*!
     * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
     * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
     * v1.9.2
     */const e=(()=>{const t=Intl.supportedValuesOf("timeZone");return[...new Set([...t,...["Etc/GMT+1","Etc/GMT+10","Etc/GMT+11","Etc/GMT+12","Etc/GMT+2","Etc/GMT+3","Etc/GMT+4","Etc/GMT+5","Etc/GMT+6","Etc/GMT+7","Etc/GMT+8","Etc/GMT+9","Etc/GMT-1","Etc/GMT-10","Etc/GMT-11","Etc/GMT-12","Etc/GMT-13","Etc/GMT-14","Etc/GMT-2","Etc/GMT-3","Etc/GMT-4","Etc/GMT-5","Etc/GMT-6","Etc/GMT-7","Etc/GMT-8","Etc/GMT-9"]])]})(),n={startDate:(new Date).toISOString(),groupDateRange:365,debug:!1},o=new Set(["Europe","Asia","America","America/Argentina","Africa","Australia","Pacific","Atlantic","Antarctica","Arctic","Indian"]),r=(t,e,n)=>{const o=[];let r=n.create(t);for(let a=0;a<=e;a++)r=n.increase(r),o.push(n.formatToIsoDateString(r));return o},a=t=>{if(t.includes("Istanbul"))return"Europe";const e=t.lastIndexOf("/");return-1===e?t:t.slice(0,e)},i=t=>o.has(t),s=(t,e,n,o,s=!1)=>{const c=new Map;s&&console.log(`Initializing data starting ${e} with ${n} days in the future, comparing ${t.length} timezones`);const l=r(e,n,o);return t.map((t=>{const e=t.label,n=a(e),r=l.map((t=>{const n=`${t}-${e}`;let r=c.get(n);return r||(r=o.isoToTimeZone(t,e),c.set(n,r),r)}));return{...t,continent:n,isRegularContinent:i(n),dates:r}}))},c=(t,e,n)=>t.length===e.length&&t.every(((t,o)=>n.same(t,e[o]))),l=(t,e=5)=>{const n=t.filter((({label:t})=>i(a(t))));if(0===n.length)return[0];return u(n.map((e=>t.indexOf(e))),e)};function u(t,e=5){const n=t.length;if(n<=e)return t;const o=Math.min(n-2,e-2),r=(n-1)/(o+1);return[t[0],...Array.from({length:o},((e,n)=>t[Math.round((n+1)*r)])),t[n-1]]}async function T(t){const{debug:o,groupDateRange:r,hooks:a,startDate:i,dateEngine:u}={...n,...t},T=[];if(!u)throw new Error("dateEngine is required");const g=e.map((t=>({label:t})));a?.onBeforeTimeZoneMetadataCreate?.(g);const d=s(g,i,r,u,o);a?.onTimeZoneMetadataCreate?.(d);for(const e of d){const{label:t,continent:n,dates:o}=e;if(e.visited)continue;e.visited=!0;const r={labelTzIndices:void 0,tzs:[{label:t}]};a?.onGroupCreate?.(r,e);for(const e of d.filter((t=>!t.visited))){const{label:t,continent:i,isRegularContinent:s,dates:l}=e;if((n===i||!s)&&c(o,l,u)){const n={label:t};r.tzs.push(n),a?.onGroupTimeZoneAdd?.(r,n,e),e.visited=!0}}T.push(r),a?.onGroupAdd?.(r)}const G=T.map((t=>{a?.onBeforeFinalGroupCreate?.(t),t.tzs=t.tzs.sort(((t,e)=>t.label.localeCompare(e.label)));const e={labelTzIndices:l(t.tzs,7),tzs:t.tzs.map((t=>t.label))};return a?.onFinalGroupCreate?.(e,t),e})).sort(((t,e)=>e.tzs.length-t.tzs.length));if(o){const t=e.map((t=>G.some((e=>e.tzs.includes(t)))?null:t)).filter(Boolean);if(t.length>0)throw new Error(`There are ${t.length} missing timezones: ${t.toString()}`)}return a?.onFinalGroupingCreate?a.onFinalGroupingCreate(G):G}t.groupTimeZones=T,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
