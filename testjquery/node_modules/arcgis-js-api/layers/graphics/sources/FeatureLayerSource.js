/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","../../../chunks/tslib.es6","../../../geometry","../../../kernel","../../../request","../../../TimeExtent","../../../core/arrayUtils","../../../core/Error","../../../core/has","../../../core/jsonMap","../../../core/Loadable","../../../core/Logger","../../../core/object","../../../core/promiseUtils","../../../core/urlUtils","../../../core/uuid","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/support/meshVertexSpaceUtils","../../../geometry/support/meshUtils/External","../applyEditsUtils","./support/clientSideDefaults","./support/QueryTask","../../support/arcgisLayerUrl","../../support/featureLayerUtils","../../support/infoFor3D","../../../rest/query/executeQueryJSON","../../../rest/query/operations/editsZScale","../../../rest/support/Query","../../../versionManagement/support/versionManagementUtils","../../../geometry/SpatialReference"],(function(e,t,s,a,r,i,n,o,u,l,c,d,p,y,h,g,f,m,S,w,q,E,O,R,b,F,A,_,x,I,v,T,N){"use strict";const J=new l.JSONMap({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),M=new Set(["Feature Layer","Oriented Imagery Layer","Table"]),U=new l.JSONMap({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let k=class extends c{constructor(){super(...arguments),this.type="feature-layer",this.refresh=y.debounce((async()=>{await this.load();const e=this.sourceJSON.editingInfo?.lastEditDate;if(null==e)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map}load(e){const t=this.layer.sourceJSON,s=this._fetchService(t,{...e}).then((()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e))).then((()=>this._ensureLatestMetadata(e)));return this.addResolvingPromise(s),Promise.resolve(this)}get queryTask(){const{capabilities:e,parsedUrl:t,dynamicDataSource:s,infoFor3D:a,gdbVersion:r,spatialReference:i,fieldsIndex:n}=this.layer,o=u("featurelayer-pbf")&&e?.query.supportsFormatPBF&&null==a,l=e?.operations?.supportsQueryAttachments??!1;return new b({url:t.path,pbfSupported:o,fieldsIndex:n,infoFor3D:a,dynamicDataSource:s,gdbVersion:r,sourceSpatialReference:i,queryAttachmentsSupported:l})}async addAttachment(e,t){await this.load();const{layer:s}=this;await A.ensureLayerCredential(s,"editing");const a=e.attributes[s.objectIdField],i=s.parsedUrl.path+"/"+a+"/addAttachment",n=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(t,n.query);try{const e=await r(i,{body:o});return O.createFeatureEditResult(e.data.addAttachmentResult)}catch(u){throw this._createAttachmentErrorResult(a,u)}}async updateAttachment(e,t,s){await this.load();const{layer:a}=this;await A.ensureLayerCredential(a,"editing");const i=e.attributes[a.objectIdField],n=a.parsedUrl.path+"/"+i+"/updateAttachment",o=this._getLayerRequestOptions({query:{attachmentId:t}}),u=this._getFormDataForAttachment(s,o.query);try{const e=await r(n,{body:u});return O.createFeatureEditResult(e.data.updateAttachmentResult)}catch(l){throw this._createAttachmentErrorResult(i,l)}}async applyEdits(e,t){await this.load();const{layer:s}=this;await A.ensureLayerCredential(s,"editing");const i=s.infoFor3D,o=null!=i,u=o||(t?.globalIdUsed??!1),l=o?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,c=e.addFeatures?.map((e=>O.getFeatureJSON(this.layer,e,i)))??[],d=(await Promise.all(c)).filter(n.isSome),p=e.updateFeatures?.map((e=>O.getFeatureJSON(this.layer,e,i)))??[],y=(await Promise.all(p)).filter(n.isSome),h=O.getFeatureIds(this.layer,e.deleteFeatures,u);I.unapplyEditsZUnitScaling(d,y,s.spatialReference);const g=await O.getAttachmentEditsJSON(this.layer,e),f=s.capabilities.editing.supportsAsyncApplyEdits&&o,m=t?.gdbVersion||s.gdbVersion,S={gdbVersion:m,rollbackOnFailure:t?.rollbackOnFailureEnabled,useGlobalIds:u,returnEditMoment:t?.returnEditMoment,usePreviousEditMoment:t?.usePreviousEditMoment,async:f};await T.isSafeToEditVersion(this.layer.url,m,!0);const w=T.isVersionInEditSession(this.layer.url,m||null);t?.returnServiceEditsOption?(S.edits=JSON.stringify([{id:s.layerId,adds:d,updates:y,deletes:h,attachments:g,assetMaps:l}]),S.returnServiceEditsOption=J.toJSON(t?.returnServiceEditsOption),S.returnServiceEditsInSourceSR=t?.returnServiceEditsInSourceSR):(S.adds=d.length?JSON.stringify(d):null,S.updates=y.length?JSON.stringify(y):null,S.deletes=h.length?u?JSON.stringify(h):h.join(","):null,S.attachments=g&&JSON.stringify(g),S.assetMaps=null!=l?JSON.stringify(l):void 0);const q=this._getLayerRequestOptions({method:"post",query:S});w&&(q.authMode="immediate",q.query.returnEditMoment=!0,q.query.sessionId=T.currentSessionId);const E=t?.returnServiceEditsOption?s.url:s.parsedUrl.path;let R;try{R=f?await this._asyncApplyEdits(E+"/applyEdits",q):await r(E+"/applyEdits",q)}catch(b){if(!O.isProtectedOrPrivateVersionError(b))throw b;q.authMode="immediate",R=f?await this._asyncApplyEdits(E+"/applyEdits",q):await r(E+"/applyEdits",q)}if(!s.capabilities.operations?.supportsEditing&&s.effectiveCapabilities?.operations?.supportsEditing){const e=a.id?.findCredential(s.url);await(e?.refreshToken())}return this._createEditsResult(R)}async deleteAttachments(e,t){await this.load();const{layer:s}=this;await A.ensureLayerCredential(s,"editing");const a=e.attributes[s.objectIdField],i=s.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await r(i,this._getLayerRequestOptions({query:{attachmentIds:t.join(",")},method:"post"}))).data.deleteAttachmentResults.map(O.createFeatureEditResult)}catch(n){throw this._createAttachmentErrorResult(a,n)}}fetchRecomputedExtents(e={}){const t=e.signal;return this.load({signal:t}).then((async()=>{const t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:s,url:a}=this.layer,{data:n}=await r(`${a}/${s}`,t),{id:o,extent:u,fullExtent:l,timeExtent:c}=n,d=u||l;return{id:o,fullExtent:d&&w.fromJSON(d),timeExtent:c&&i.fromJSON({start:c[0],end:c[1]})}}))}async queryAttachments(e,t={}){await this.load();const s=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,s)}async queryFeatures(e,t){await this.load();const s=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});return e.outStatistics?.length&&s.features.length&&s.features.forEach((t=>{const s=t.attributes;e.outStatistics?.forEach((({outStatisticFieldName:e})=>{if(e){const t=e.toLowerCase();t&&t in s&&e!==t&&(s[e]=s[t],delete s[t])}}))})),s}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!F.isHostedAgolService(this.layer.url))return"unavailable";const e=h.join(this.layer.url,"status"),t=await r(e,{query:{f:"json"}});return U.fromJSON(t.data.status)}async uploadAssets(t,s){const{uploadAssets:a}=await new Promise(((t,s)=>e(["./support/uploadAssets"],t,s)));return a(t,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},s)}async _asyncApplyEdits(e,t){const s=(await r(e,t)).data.statusUrl;for(;;){const e=(await r(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return r(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new o("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new o("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await y.after(C)}}_createRequestQueryOptions(e){const t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){const s={};u("featurelayer-advanced-symbols")&&(s.returnAdvancedSymbols=!0),t?.cacheBust&&(s._ts=Date.now());const{data:a}=await r(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:s,signal:t?.signal}));e=a}this.sourceJSON=await this._patchServiceJSON(e,t?.signal);const s=e.type;if(!M.has(s))throw new o("feature-layer-source:unsupported-type",`Source type "${s}" is not supported`)}async _patchServiceJSON(e,t){if("Table"!==e.type&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){const t=R.createDrawingInfo(e.geometryType).renderer;p.setDeepValue("drawingInfo.renderer",t,e)}if("esriGeometryMultiPatch"===e.geometryType&&e.infoFor3D&&(e.geometryType="mesh"),null==e.extent)try{const{data:s}=await r(this.layer.url,this._getLayerRequestOptions({signal:t}));s.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:s.spatialReference})}catch(s){y.throwIfAbortError(s)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){const{addAssetFeatures:t}=e;if(!t?.length)return null;const s=await this._filterRedundantAssetMaps(t);if(!t?.length)return null;const a=new Array,r=new Map;for(const i of s){const{geometry:e}=i,{vertexSpace:t}=e;if(t.isRelative)a.push(e);else{const t=q.toRelativeVertexSpace(e);r.set(t,e),i.geometry=t,a.push(t)}}await this.uploadAssets(a);for(const[i,n]of r)n.addExternalSources(i.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(s),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){const t=new Array,s=this.layer.globalIdField,a=this.layer.parsedUrl;for(const r of e){const e=r.geometry,{metadata:i}=e,n=i.getExternalSourcesOnService(a),o=r.getAttribute(s);if(0===n.length){d.getLogger(this).error(`Skipping feature ${o}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:u}=n.find(E.isOriginalExternal)??n[0],{vertexSpace:l}=e,c=l.isGeoreferenced?["PROJECT_VERTICES"]:[];for(const s of u)1===s.parts.length?t.push({globalId:g.generateBracedUUID(),parentGlobalId:o,assetName:s.assetName,assetHash:s.parts[0].partHash,flags:c}):d.getLogger(this).error(`Skipping asset ${s.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){const t=e.data,{layerId:s}=this.layer,a=[];let r=null;if(Array.isArray(t))for(const n of t)a.push({id:n.id,editedFeatures:n.editedFeatures}),n.id===s&&(r={addResults:n.addResults??[],updateResults:n.updateResults??[],deleteResults:n.deleteResults??[],attachments:n.attachments,editMoment:n.editMoment});else r=t;const i=O.unpackEditResultData(r);if(a.length>0){i.editedFeatureResults=[];for(const e of a){const{editedFeatures:t}=e,s=t?.spatialReference?new N(t.spatialReference):null;i.editedFeatureResults.push({layerId:e.id,editedFeatures:O.createEditedFeatures(t,s)})}}return i}_createAttachmentErrorResult(e,t){const s=t.details.messages?.[0]||t.message,a=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new o("feature-layer-source:attachment-failure",s,{code:a})}}_getFormDataForAttachment(e,t){const s=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(s)for(const a in t){const e=t[a];null!=e&&(s.set?s.set(a,e):s.append(a,e))}return s}_getLayerRequestOptions(e={}){const{parsedUrl:t,gdbVersion:s,dynamicDataSource:a}=this.layer;return{...e,query:{gdbVersion:s,layer:a?JSON.stringify({source:a}):void 0,...t.query,f:"json",...this._createRequestQueryOptions(e)},responseType:"json"}}async _filterRedundantAssetMaps(e){const{layer:t}=this,{globalIdField:s,infoFor3D:a,parsedUrl:r}=t;if(null==a||null==s)return e;const i=_.getAssetMapTable(a);if(null==i)return e;const o=h.join(r.path,`../${i.id}`),u=new Array,l=new Array;for(const n of e)n.geometry.metadata.getExternalSourcesOnService(r).length>0?l.push(n):u.push(n);const c=l.map((e=>e.getAttribute(s))).filter(n.isSome);if(0===c.length)return e;const{assetMapFieldRoles:{parentGlobalId:d,assetHash:p}}=a,y=new v;y.where=`${d} IN (${c.map((e=>`'${e}'`))})`,y.outFields=[p,d],y.returnGeometry=!1;const g=await x.executeQueryJSON(o,y),{features:f}=g;return 0===f.length?e:[...u,...l.filter((e=>{const t=e.getAttribute(s);if(!t)return!0;const{metadata:a}=e.geometry,i=f.filter((e=>e.getAttribute(d)===t));if(0===i.length)return!0;const n=i.map((e=>e.getAttribute(p)));return a.getExternalSourcesOnService(r).flatMap((({source:e})=>e.flatMap((e=>e.parts.map((e=>e.partHash)))))).some((e=>n.every((t=>e!==t))))}))]}};t.__decorate([f.property()],k.prototype,"type",void 0),t.__decorate([f.property({constructOnly:!0})],k.prototype,"layer",void 0),t.__decorate([f.property({readOnly:!0})],k.prototype,"queryTask",null),k=t.__decorate([S.subclass("esri.layers.graphics.sources.FeatureLayerSource")],k);const C=1e3;return k}));
