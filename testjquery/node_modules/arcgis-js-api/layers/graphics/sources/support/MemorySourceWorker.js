/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../core/Error","../../../../geometry/support/jsonUtils","../../../../geometry/support/spatialReferenceUtils","../../featureConversionUtils","../../objectIdUtils","../../data/FeatureStore","../../data/projectionSupport","../../data/QueryEngine","./clientSideDefaults","./sourceUtils","../../../support/FieldsIndex","../../../support/fieldType","../../../support/fieldUtils","../../../../time/timeZoneUtils"],(function(e,t,i,s,r,n,a,l,u,o,d,c,p,f){"use strict";const y=i.WGS84,m={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:i.WGS84},g={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function h(e){return t.isPoint(e)?null!=e.z:!!e.hasZ}function F(e){return t.isPoint(e)?null!=e.m:!!e.hasM}class I{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine?.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(t){const i=[],{features:s}=t,o=this._inferLayerProperties(s,t.fields),h=t.fields||[],F=null!=t.hasM?t.hasM:!!o.hasM,I=null!=t.hasZ?t.hasZ:!!o.hasZ,b=!t.spatialReference&&!o.spatialReference,E=b?y:t.spatialReference||o.spatialReference,j=b?m:null,T=t.geometryType||o.geometryType,R=!T;let _=t.objectIdField||o.objectIdField,x=t.timeInfo;const S=new d(h);if(!R&&(b&&i.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!T))throw new e("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!_)throw new e("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(o.objectIdField&&_!==o.objectIdField&&(i.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${_}" doesn't match the field name "${o.objectIdField}", found in the provided fields`}),_=o.objectIdField),_&&!o.objectIdField){const e=S.get(_);e?(_=e.name,e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):h.unshift({alias:_,name:_,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const r of h){if(null==r.name&&(r.name=r.alias),null==r.alias&&(r.alias=r.name),!r.name)throw new e("feature-layer:invalid-field-name","field name is missing",{field:r});if(r.name===_&&(r.type="esriFieldTypeOID"),!c.kebabDict.jsonValues.includes(r.type))throw new e("feature-layer:invalid-field-type",`invalid type for field "${r.name}"`,{field:r});null==r.length&&(r.length=p.getFieldDefaultLength(r))}const D={};for(const e of h)if("esriFieldTypeOID"!==e.type&&"esriFieldTypeGlobalID"!==e.type){const t=p.getFieldDefaultValue(e);void 0!==t&&(D[e.name]=t)}if(x){if(x.startTimeField){const e=S.get(x.startTimeField);e?(x.startTimeField=e.name,e.type="esriFieldTypeDate"):x.startTimeField=null}if(x.endTimeField){const e=S.get(x.endTimeField);e?(x.endTimeField=e.name,e.type="esriFieldTypeDate"):x.endTimeField=null}if(x.trackIdField){const e=S.get(x.trackIdField);e?x.trackIdField=e.name:(x.trackIdField=null,i.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:x}}))}x.startTimeField||x.endTimeField||(i.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:x}}),x=null)}const q=S.dateFields.length?{timeZoneIANA:t.dateFieldsTimeZone??f.utc}:null;this._createDefaultAttributes=u.createDefaultAttributesFunction(D,_);const O={warnings:i,featureErrors:[],layerDefinition:{...g,drawingInfo:u.createDrawingInfo(T),templates:u.createDefaultTemplate(D),extent:j,geometryType:T,objectIdField:_,fields:h,hasZ:I,hasM:F,timeInfo:x,dateFieldsTimeReference:q},assignedObjectIds:{}};if(this._queryEngine=new l.QueryEngine({fieldsIndex:d.fromLayerJSON({fields:h,timeInfo:x,dateFieldsTimeReference:q}),geometryType:T,hasM:F,hasZ:I,objectIdField:_,spatialReference:E,featureStore:new n({geometryType:T,hasM:F,hasZ:I}),timeInfo:x,cacheSpatialQueries:!0}),!s?.length)return this._nextObjectId=r.initialObjectId,O;const v=r.findLastObjectIdFromFeatures(_,s);return this._nextObjectId=v+1,await a.checkProjectionSupport(s,E),this._loadInitialFeatures(O,s)}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([o.loadGeometryEngineForSimplify(t,i),a.checkProjectionSupport(e.adds,t),a.checkProjectionSupport(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,i){let s,r,n=null,a=null,l=null;for(const u of e){const e=u.geometry;if(null!=e&&(n||(n=t.getJsonType(e)),a||(a=e.spatialReference),null==s&&(s=h(e)),null==r&&(r=F(e)),n&&a&&null!=s&&null!=r))break}if(i&&i.length){let e=null;i.some((t=>{const i="esriFieldTypeOID"===t.type,s=!t.type&&t.name&&"objectid"===t.name.toLowerCase();return e=t,i||s}))&&(l=e.name)}return{geometryType:n,spatialReference:a,objectIdField:l,hasM:r,hasZ:s}}async _loadInitialFeatures(e,i){const{geometryType:r,hasM:n,hasZ:l,objectIdField:u,spatialReference:d,featureStore:c,fieldsIndex:p}=this._queryEngine,f=[];for(const s of i){if(null!=s.uid&&(e.assignedObjectIds[s.uid]=-1),s.geometry&&r!==t.getJsonType(s.geometry)){e.featureErrors.push(o.createFeatureEditErrorResult("Incorrect geometry type."));continue}const i=this._createDefaultAttributes(),n=o.mixAttributes(p,i,s.attributes,!0);n?e.featureErrors.push(n):(this._assignObjectId(i,s.attributes,!0),s.attributes=i,null!=s.uid&&(e.assignedObjectIds[s.uid]=s.attributes[u]),null!=s.geometry&&(s.geometry=a.project(s.geometry,s.geometry.spatialReference,d)),f.push(s))}c.addMany(s.convertFromFeatures([],f,r,l,n,u));const{fullExtent:y,timeExtent:m}=await this._queryEngine.fetchRecomputedExtents();if(e.layerDefinition.extent=y,m){const{start:t,end:i}=m;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}async _applyEdits(e){const{adds:t,updates:i,deletes:s}=e,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t?.length&&this._applyAddEdits(r,t),i?.length&&this._applyUpdateEdits(r,i),s?.length){for(const e of s)r.deleteResults.push(o.createFeatureEditSuccessResult(e));this._queryEngine.featureStore.removeManyById(s)}const{fullExtent:n,timeExtent:a}=await this._queryEngine.fetchRecomputedExtents();return{extent:n,timeExtent:a,featureEditResults:r}}_applyAddEdits(e,i){const{addResults:r}=e,{geometryType:n,hasM:l,hasZ:u,objectIdField:d,spatialReference:c,featureStore:p,fieldsIndex:f}=this._queryEngine,y=[];for(const s of i){if(s.geometry&&n!==t.getJsonType(s.geometry)){r.push(o.createFeatureEditErrorResult("Incorrect geometry type."));continue}const i=this._createDefaultAttributes(),l=o.mixAttributes(f,i,s.attributes);if(l)r.push(l);else{if(this._assignObjectId(i,s.attributes),s.attributes=i,null!=s.uid){const t=s.attributes[d];e.uidToObjectId[s.uid]=t}if(null!=s.geometry){const e=s.geometry.spatialReference??c;s.geometry=a.project(o.simplify(s.geometry,e),e,c)}y.push(s),r.push(o.createFeatureEditSuccessResult(s.attributes[d]))}}p.addMany(s.convertFromFeatures([],y,n,u,l,d))}_applyUpdateEdits({updateResults:e},i){const{geometryType:r,hasM:n,hasZ:l,objectIdField:u,spatialReference:d,featureStore:c,fieldsIndex:p}=this._queryEngine;for(const f of i){const{attributes:i,geometry:y}=f,m=i?.[u];if(null==m){e.push(o.createFeatureEditErrorResult(`Identifier field ${u} missing`));continue}if(!c.has(m)){e.push(o.createFeatureEditErrorResult(`Feature with object id ${m} missing`));continue}const g=s.convertToFeature(c.getFeature(m),r,l,n);if(null!=y){if(r!==t.getJsonType(y)){e.push(o.createFeatureEditErrorResult("Incorrect geometry type."));continue}const i=y.spatialReference??d;g.geometry=a.project(o.simplify(y,i),i,d)}if(i){const t=o.mixAttributes(p,g.attributes,i);if(t){e.push(t);continue}}c.add(s.convertFromFeature(g,r,l,n,u)),e.push(o.createFeatureEditSuccessResult(m))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&t&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}}return I}));
