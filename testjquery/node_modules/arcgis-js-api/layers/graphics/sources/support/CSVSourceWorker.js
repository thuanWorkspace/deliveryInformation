/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../../geometry","../../../../request","../../../../core/asyncUtils","../../../../core/date","../../../../core/Error","../../../../core/Logger","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../geometry/projection","../../../../geometry/geometryAdapters/json","../../../../geometry/support/spatialReferenceUtils","../../../../geometry/support/webMercatorUtils","../../OptimizedFeature","../../OptimizedGeometry","../../data/FeatureStore","../../data/projectionSupport","../../data/QueryEngine","../csv/csv","./clientSideDefaults","../../../support/FieldsIndex","../../../support/fieldUtils","../../../../time/timeZoneUtils","../../../../geometry/SpatialReference"],(function(e,t,i,n,s,r,a,o,l,c,d,u,m,p,f,y,h,g,F,I,_,w,E){"use strict";const T=F.createDrawingInfo("esriGeometryPoint"),N=["csv"],x=[0,0];class S{constructor(e,t){this.x=e,this.y=t}}class b{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){this._queryEngine?.destroy(),this._queryEngine=null}async load(e,t={}){this._loadOptions=e;const[i]=await Promise.all([this._fetch(t.signal),this._checkProjection(e?.parsingOptions?.spatialReference)]),n=q(i,e);this._locationInfo=n.locationInfo,this._delimiter=n.delimiter,this._queryEngine=this._createQueryEngine(n);const s=await this._createFeatures(i);this._queryEngine.featureStore.addMany(s);const{fullExtent:r,timeExtent:a}=await this._queryEngine.fetchRecomputedExtents();if(n.layerDefinition.extent=r,a){const{start:e,end:t}=a;n.layerDefinition.timeInfo.timeExtent=[e,t]}return n}async applyEdits(){throw new s("csv-layer:editing-not-supported","applyEdits() is not supported on CSVLayer")}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(e,t.signal)}async refresh(e){this._loadOptions.customParameters=e,this._snapshotTask?.abort(),this._snapshotTask=i.createTask(this._snapshotFeatures),this._snapshotTask.promise.then((e=>{this._queryEngine.featureStore.clear(),e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),a.isAbortError(e)||r.getLogger("esri.layers.CSVLayer").error(new s("csv-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete();const{fullExtent:t,timeExtent:n}=await this._queryEngine.fetchRecomputedExtents();return{extent:t,timeExtent:n}}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(e){const{url:i,customParameters:n}=this._loadOptions;if(!i)throw new s("csv-layer:invalid-source","url not defined");const r=o.urlToObject(i);return(await t(r.path,{query:{...r.query,...n},responseType:"text",signal:e})).data}_createQueryEngine(e){const{objectIdField:t,fields:i,extent:n,timeInfo:s}=e.layerDefinition,r=new f({geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1});return new h.QueryEngine({fieldsIndex:I.fromLayerJSON({fields:i,dateFieldsTimeReference:{timeZoneIANA:w.utc}}),geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1,timeInfo:s,objectIdField:t,spatialReference:n.spatialReference||{wkid:4326},cacheSpatialQueries:!0,featureStore:r})}async _createFeatures(e){const{latitudeFieldName:t,longitudeFieldName:i}=this._locationInfo,{objectIdField:s,fieldsIndex:r,spatialReference:a}=this._queryEngine;let o=[];const f=[],y=r.fields.filter((e=>e.name!==s)).map((e=>e.name));let h=0;const I={};for(const n of r.fields)if("esriFieldTypeOID"!==n.type&&"esriFieldTypeGlobalID"!==n.type){const e=_.getFieldDefaultValue(n);void 0!==e&&(I[n.name]=e)}const w=g.parseRows(e,y,this._delimiter,F.createDefaultAttributesFunction(I,s));for(const l of w){const e=this._parseCoordinateValue(l[t]),a=this._parseCoordinateValue(l[i]);if(null!=a&&null!=e&&!isNaN(e)&&!isNaN(a)){l[t]=e,l[i]=a;for(const e in l)if(e!==t&&e!==i)if(r.isDateField(e))l[e]=n.parseDate(l[e]);else if(r.isNumericField(e)){const t=g.parseNumber(l[e]);isNaN(t)?l[e]=null:l[e]=t}l[s]=h,h++,o.push(new S(a,e)),f.push(l)}}if(!d.equals({wkid:4326},a))if(d.isWebMercator(a))for(const n of o)[n.x,n.y]=u.lngLatToXY(n.x,n.y,x);else o=l.projectMany(c.jsonAdapter,o,E.WGS84,a,null,null);const T=[];for(let n=0;n<o.length;n++){const{x:e,y:t}=o[n],i=f[n];i[s]=n+1,T.push(new m.OptimizedFeature(new p([],[e,t]),i,null,i[s]))}return T}_parseCoordinateValue(e){if(null==e||""===e)return null;let t=g.parseNumber(e);return(isNaN(t)||Math.abs(t)>181)&&(t=parseFloat(e)),t}async _checkProjection(e){try{await y.checkProjectionSupport(d.WGS84,e)}catch{throw new s("csv-layer:projection-not-supported","Projection not supported")}}}function q(e,t){const i=t.parsingOptions||{},n={delimiter:i.delimiter,layerDefinition:null,locationInfo:{latitudeFieldName:i.latitudeField,longitudeFieldName:i.longitudeField}},r=n.layerDefinition={name:o.getFilename(t.url,N)||"csv",dateFieldsTimeReference:{timeZoneIANA:w.utc},drawingInfo:T,geometryType:"esriGeometryPoint",objectIdField:null,fields:[],timeInfo:i.timeInfo,extent:{xmin:Number.POSITIVE_INFINITY,ymin:Number.POSITIVE_INFINITY,xmax:Number.NEGATIVE_INFINITY,ymax:Number.NEGATIVE_INFINITY,spatialReference:i.spatialReference||{wkid:4326}}},a=g.readRows(e),l=a.next().value?.trim(),c=a.next().value?.trim();if(!l)throw new s("csv-layer:empty-csv","CSV is empty",{csv:e});const{delimiter:d,locationInfo:u}=g.inferDelimiterAndLocationInfo(l,c,i);if(!d)throw new s("csv-layer:invalid-delimiter","Unable to detect the delimiter from CSV",{firstLine:l,secondLine:c,parsingOptions:i});if(!u)throw new s("csv-layer:location-fields-not-found","Unable to identify latitude and longitude fields from the CSV file",{firstLine:l,secondLine:c,parsingOptions:i});n.locationInfo=u,n.delimiter=d;const{names:m,aliases:p}=g.extractFieldNamesAndAliasesFromRow(l,d),f=g.inferFields(e,n.delimiter,m,p,n.locationInfo);if(i.fields?.length){const e=new I(i.fields);for(const t of f){const i=e.get(t.name);i&&Object.assign(t,i)}}if(!f.some((e=>"esriFieldTypeOID"===e.type&&(r.objectIdField=e.name,!0)))){const e={name:"__OBJECTID",alias:"__OBJECTID",type:"esriFieldTypeOID",editable:!1,nullable:!1};r.objectIdField=e.name,f.unshift(e)}r.fields=f;const y=new I(r.fields);if(n.locationInfo&&(n.locationInfo.latitudeFieldName=y.get(n.locationInfo.latitudeFieldName).name,n.locationInfo.longitudeFieldName=y.get(n.locationInfo.longitudeFieldName).name),r.timeInfo){const e=r.timeInfo;if(e.startTimeField){const t=y.get(e.startTimeField);t?(e.startTimeField=t.name,t.type="esriFieldTypeDate"):e.startTimeField=null}if(e.endTimeField){const t=y.get(e.endTimeField);t?(e.endTimeField=t.name,t.type="esriFieldTypeDate"):e.endTimeField=null}if(e.trackIdField){const t=y.get(e.trackIdField);e.trackIdField=t?t.name:null}e.startTimeField||e.endTimeField||(r.timeInfo=null)}return n}return b}));
