/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/has","../../../core/Loadable","../../../core/Logger","../../../core/promiseUtils","../../../core/workers/workers","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/accessorSupport/decorators/subclass","./support/clientSideDefaults","../../../rest/support/FeatureSet","../../../geometry/Extent","../../../geometry/Polygon","../../../geometry/support/typeUtils"],(function(e,t,r,o,s,i,n,a,u,l,c,d,h,p,y,S,f,g){"use strict";e.GeoJSONSource=class extends i{constructor(){super(...arguments),this.type="geojson",this.refresh=a.debounce((async e=>{await this.load();const{extent:t,timeExtent:r}=await this._connection.invoke("refresh",e);return this.sourceJSON.extent=t,r&&(this.sourceJSON.timeInfo.timeExtent=[r.start,r.end]),{dataChanged:!0,updates:{extent:this.sourceJSON.extent,timeInfo:this.sourceJSON.timeInfo}}}))}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this._startWorker(t)),Promise.resolve(this)}destroy(){this._connection?.close(),this._connection=null}applyEdits(e){return this.load().then((()=>this._applyEdits(e)))}openPorts(){return this.load().then((()=>this._connection.openPorts()))}queryFeatures(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryFeatures",e?e.toJSON():null,t))).then((e=>y.fromJSON(e)))}queryFeaturesJSON(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryFeatures",e?e.toJSON():null,t)))}queryFeatureCount(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryFeatureCount",e?e.toJSON():null,t)))}queryObjectIds(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryObjectIds",e?e.toJSON():null,t)))}queryExtent(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryExtent",e?e.toJSON():null,t))).then((e=>({count:e.count,extent:S.fromJSON(e.extent)})))}querySnapping(e,t={}){return this.load(t).then((()=>this._connection.invoke("querySnapping",e,t)))}_applyEdits(e){if(!this._connection)throw new o("geojson-layer-source:edit-failure","Memory source not loaded");const t=this.layer.objectIdField,r=[],s=[],i=[];if(e.addFeatures)for(const o of e.addFeatures)r.push(this._serializeFeature(o));if(e.deleteFeatures)for(const o of e.deleteFeatures)"objectId"in o&&null!=o.objectId?s.push(o.objectId):"attributes"in o&&null!=o.attributes[t]&&s.push(o.attributes[t]);if(e.updateFeatures)for(const o of e.updateFeatures)i.push(this._serializeFeature(o));return this._connection.invoke("applyEdits",{adds:r,updates:i,deletes:s}).then((({extent:e,timeExtent:t,featureEditResults:r})=>(this.sourceJSON.extent=e,t&&(this.sourceJSON.timeInfo.timeExtent=[t.start,t.end]),this._createEditsResult(r))))}_createEditsResult(e){return{addFeatureResults:e.addResults?e.addResults.map(this._createFeatureEditResult,this):[],updateFeatureResults:e.updateResults?e.updateResults.map(this._createFeatureEditResult,this):[],deleteFeatureResults:e.deleteResults?e.deleteResults.map(this._createFeatureEditResult,this):[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}_createFeatureEditResult(e){const t=!0===e.success?null:e.error||{code:void 0,description:void 0};return{objectId:e.objectId,globalId:e.globalId,error:t?new o("geojson-layer-source:edit-failure",t.description,{code:t.code}):null}}_serializeFeature(e){const{attributes:t}=e,r=this._geometryForSerialization(e);return r?{geometry:r.toJSON(),attributes:t}:{attributes:t}}_geometryForSerialization(e){const{geometry:t}=e;return null==t?null:"mesh"===t.type||"extent"===t.type?f.fromExtent(t.extent):t}async _startWorker(e){this._connection=await u.open("GeoJSONSourceWorker",{strategy:s("feature-layers-workers")?"dedicated":"local",signal:e,registryTarget:this});const{fields:t,spatialReference:r,hasZ:o,geometryType:i,objectIdField:a,url:l,timeInfo:c,customParameters:d}=this.layer,h="defaults"===this.layer.originOf("spatialReference"),y={url:l,customParameters:d,fields:t&&t.map((e=>e.toJSON())),geometryType:g.featureGeometryTypeKebabDictionary.toJSON(i),hasZ:o,objectIdField:a,timeInfo:c?c.toJSON():null,spatialReference:h?null:r&&r.toJSON()},S=await this._connection.invoke("load",y,{signal:e});for(const s of S.warnings)n.getLogger(this.layer).warn("#load()",`$${s.message} (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{warning:s});S.featureErrors.length&&n.getLogger(this.layer).warn("#load()",`Encountered ${S.featureErrors.length} validation errors while loading features. (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{errors:S.featureErrors}),this.sourceJSON=S.layerDefinition,this.capabilities=p.createCapabilities(this.sourceJSON.hasZ,!0)}},t.__decorate([l.property()],e.GeoJSONSource.prototype,"capabilities",void 0),t.__decorate([l.property()],e.GeoJSONSource.prototype,"type",void 0),t.__decorate([l.property({constructOnly:!0})],e.GeoJSONSource.prototype,"layer",void 0),t.__decorate([l.property()],e.GeoJSONSource.prototype,"sourceJSON",void 0),e.GeoJSONSource=t.__decorate([h.subclass("esri.layers.graphics.sources.GeoJSONSource")],e.GeoJSONSource),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
