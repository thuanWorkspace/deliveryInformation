/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","exports","../../../core/lang","../../../geometry/support/centroid","../../../geometry/support/extentUtils","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","./AttributesBuilder","./geometryUtils","./projectionSupport","./SnappingCandidate","../../support/fieldUtils","../../../statistics/utils"],(function(e,t,s,i,a,n,r,o,l,u,c,d,m){"use strict";class g{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new o(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query,a=t?.length;if(!!!a)return 1;const n=new Map,r=new Map,l=new Set;for(const o of i){const{statisticType:i}=o,a="exceedslimit"!==i?o.onStatisticField:void 0;if(!r.has(a)){const s=[];for(const i of t){const t=this._getAttributeValues(e,i,n);s.push(t)}r.set(a,this._calculateUniqueValues(s,e.returnDistinctValues))}const u=r.get(a);for(const t in u){const{data:i,items:a}=u[t],n=i.join(",");s&&!e.validateItems(a,s)||l.add(n)}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query)}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;r.isValid(this.query.outSR)&&!r.equals(t.spatialReference,this.query.outSR)?e.queryGeometry=l.cleanFromGeometryEngine({spatialReference:this.query.outSR,...u.project(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=l.cleanFromGeometryEngine({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const s=this.featureAdapter,i=y(this.hasZ,this.hasM),{point:a,mode:n}=e,r="number"==typeof e.distance?e.distance:e.distance.x,o="number"==typeof e.distance?e.distance:e.distance.y,l={candidates:[]},u="esriGeometryPolygon"===this.geometryType,d=this._getPointCreator(n,this.spatialReference,t),m=new f(null,0),g=new f(null,0),p={x:0,y:0,z:0};for(const y of this.items){const t=s.getGeometry(y);if(null==t)continue;const{coords:n,lengths:f}=t;if(m.coords=n,g.coords=n,e.returnEdge){let e=0;for(let t=0;t<f.length;t++){const n=f[t];for(let t=0;t<n;t++,e+=i){const u=m;if(u.coordsIndex=e,t!==n-1){const t=g;t.coordsIndex=e+i;const n=p;h(p,a,u,t);const m=(a.x-n.x)/r,f=(a.y-n.y)/o,x=m*m+f*f;x<=1&&l.candidates.push(c.makeEdgeCandidate(s.getObjectId(y),d(n),Math.sqrt(x),d(u),d(t)))}}}}if("none"!==e.vertexMode){const t=u?n.length-i:n.length;if("all"===e.vertexMode)for(let e=0;e<t;e+=i){const t=m;t.coordsIndex=e;const i=(a.x-t.x)/r,n=(a.y-t.y)/o,u=i*i+n*n;u<=1&&l.candidates.push(c.makeVertexCandidate(s.getObjectId(y),d(t),Math.sqrt(u)))}else if("ends"===e.vertexMode){const e=[0];u||e.push(n.length-i);for(const t of e){const e=m;e.coordsIndex=t;const i=(a.x-e.x)/r,n=(a.y-e.y)/o,u=i*i+n*n;u<=1&&l.candidates.push(c.makeVertexCandidate(s.getObjectId(y),d(e),Math.sqrt(u)))}}}}return l.candidates.sort(((e,t)=>e.distance-t.distance)),l}_getPointCreator(e,t,s){const i=null==s||r.equals(t,s)?e=>e:e=>u.project(e,t,s),{hasZ:a}=this,n=0;return"3d"===e?a?({x:e,y:t,z:s})=>i({x:e,y:t,z:s}):({x:e,y:t})=>i({x:e,y:t,z:n}):({x:e,y:t})=>i({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,minValue:r,maxValue:o,scale:l,timeZone:u}=e,c=this.fieldsIndex.get(t),g=d.isDateField(c)||d.isDateOnlyField(c)||d.isTimestampOffsetField(c),h=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:l,timeZone:u}),y=m.isNullCountSupported({normalizationType:a,normalizationField:i,minValue:r,maxValue:o}),f={value:.5,fieldType:c?.type},p=d.isStringField(c)?m.calculateStringStatistics({values:h,supportsNullCount:y,percentileParams:f}):m.calculateStatistics({values:h,minValue:r,maxValue:o,useSampleStdDev:!a,supportsNullCount:y,percentileParams:f});return m.processSummaryStatisticsResult(p,g)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domains:i,returnAllCodedValues:a,scale:n,timeZone:r}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:s,scale:n,timeZone:r},!1),l=m.calculateUniqueValuesCount(o);return m.createUVResult(l,i,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d,timeZone:g}=e,h=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:d,timeZone:g}),y=m.calculateClassBreaks(h,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return m.resolveCBResult(y,r)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d,timeZone:g}=e,h=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:d,timeZone:g});return m.calculateHistogram(h,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,s){if(e.length>1&&t?.length)for(const i of t.reverse()){const t=i.split(" "),a=t[0],n=this.fieldsIndex.get(a),r=!!t[1]&&"desc"===t[1].toLowerCase(),o=m.getAttributeComparator(n?.type,r);e.sort(((e,t)=>{const i=s(e,a,n),r=s(t,a,n);return o(i,r)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:u,outSR:c,quantizationParameters:d,resultRecordCount:m,resultOffset:g,returnZ:h,returnM:y}=e,f=null!=m&&t.length>(g||0)+m,p=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:f,features:this._createFeatures(e,t),fields:p,geometryType:s,hasM:i&&y,hasZ:a&&h,objectIdFieldName:r,spatialReference:l.cleanFromGeometryEngine(c||o),transform:d&&n.toQuantizationTransform(d)||null}}_createFeatures(e,t){const s=new o(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:a}=this,{orderByFields:r,quantizationParameters:u,returnGeometry:c,returnCentroid:d,maxAllowableOffset:m,resultOffset:g,resultRecordCount:h,returnZ:y=!1,returnM:f=!1}=e,p=a&&y,x=i&&f;let I=[],F=0;const S=[...t];if(this._sortFeatures(S,r,((e,t,i)=>s.getFieldValue(e,t,i))),this.geometryType&&(c||d)){const e=n.toQuantizationTransform(u)??void 0;if(c&&!d)for(const t of S)I[F++]={attributes:s.getAttributes(t),geometry:l.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,p,x)};else if(!c&&d)for(const t of S)I[F++]={attributes:s.getAttributes(t),centroid:l.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of S)I[F++]={attributes:s.getAttributes(t),centroid:l.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e),geometry:l.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,p,x)}}else for(const n of S){const e=s.getAttributes(n);e&&(I[F++]={attributes:e})}const T=g||0;if(null!=h){const e=T+h;I=I.slice(T,Math.min(I.length,e))}return I}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const n of e.outStatistics??[])if("exceedslimit"===n.statisticType){s=null!=n.maxPointCount?n.maxPointCount:Number.POSITIVE_INFINITY,i=null!=n.maxRecordCount?n.maxRecordCount:Number.POSITIVE_INFINITY,a=null!=n.maxVertexCount?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>s;else if(this.items.length>i)t=!0;else{const e=y(this.hasZ,this.hasM),s=this.featureAdapter;t=this.items.reduce(((e,t)=>{const i=s.getGeometry(t);return e+(null!=i&&i.coords.length||0)}),0)/e>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,a=new Map,n=new Map,r=new Map,l=new o(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:m,orderByFields:g,resultRecordCount:h}=e,y=c?.length,f=!!y,p=f?c[0]:null,x=f&&!this.fieldsIndex.get(p);for(const o of u??[]){const{outStatisticFieldName:e,statisticType:u}=o,g=o,h="exceedslimit"!==u?o.onStatisticField:void 0,I="percentile_disc"===u||"percentile_cont"===u,F="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,S=f&&1===y&&(h===p||x)&&"count"===u;if(f){if(!n.has(h)){const e=[];for(const t of c){const s=this._getAttributeValues(l,t,i);e.push(s)}n.set(h,this._calculateUniqueValues(e,!F&&l.returnDistinctValues))}const t=n.get(h);if(!t)continue;const s=Object.keys(t);for(const a of s){const{count:s,data:n,items:o,itemPositions:u}=t[a],d=n.join(",");if(!m||l.validateItems(o,m)){const t=r.get(d)||{attributes:{}};if(F){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(g,o);t.aggregateGeometries[s]=e}else{let a=null;if(S)a=s;else{const e=this._getAttributeValues(l,h,i),t=u.map((t=>e[t]));a=I&&"statisticParameters"in g?this._getPercentileValue(g,t):this._getStatisticValue(g,t,null,l.returnDistinctValues)}t.attributes[e]=a}let a=0;c.forEach(((e,s)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++a]=n[s])),r.set(d,t)}}}else if(F){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(g,this.items);t.aggregateGeometries[s]=e}else{const s=this._getAttributeValues(l,h,i);t.attributes[e]=I&&"statisticParameters"in g?this._getPercentileValue(g,s):this._getStatisticValue(g,s,a,l.returnDistinctValues)}const T="min"!==u&&"max"!==u||!d.isStringField(this.fieldsIndex.get(h))&&!this._isAnyDateField(h)?null:this.fieldsIndex.get(h)?.type;s.push({name:e,alias:e,type:T||"esriFieldTypeDouble"})}const I=f?Array.from(r.values()):[t];return this._sortFeatures(I,g,((e,t)=>e.attributes[t])),h&&(I.length=Math.min(h,I.length)),{fields:s,features:I}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return d.isDateField(t)||d.isDateOnlyField(t)||d.isTimestampOffsetField(t)||d.isTimeOnlyField(t)}async _getAggregateGeometry(t,s){const{convexHull:n,union:r}=await new Promise(((t,s)=>e(["../../../geometry/geometryEngineJSON"],t,s))),{statisticType:o,outStatisticFieldName:u}=t,{featureAdapter:c,spatialReference:d,geometryType:m,hasZ:g,hasM:h}=this,y=s.map((e=>l.getGeometry(m,g,h,c.getGeometry(e)))),f=n(d,y,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=f?a.getPolygonExtent(f):a.getGeometryExtent(r(d,y));p.aggregateGeometries={...e,spatialReference:d},p.outStatisticFieldName=u||"extent"}else if("CentroidAggregate"===o){const e=f?i.polygonCentroid(f):i.extentCentroid(a.getGeometryExtent(r(d,y)));p.aggregateGeometries={x:e[0],y:e[1],spatialReference:d},p.outStatisticFieldName=u||"centroid"}else"ConvexHullAggregate"===o&&(p.aggregateGeometries=f,p.outStatisticFieldName=u||"convexHull");return p}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:n}=e;let r=null;r=s?.has(a)?s.get(a):d.isStringField(this.fieldsIndex.get(a))||this._isAnyDateField(a)?m.calculateStringStatistics({values:t,returnDistinct:i}):m.calculateStatistics({values:i?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,r);return r["var"===n?"variance":n]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:n,orderBy:r}=i,o=this.fieldsIndex.get(s),l={value:n,orderBy:r,fieldType:o?.type,isDiscrete:"percentile_disc"===a};return m.calculatePercentile(t,l)}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),a=this.items.map((s=>e.getFieldValue(s,t,i)));return s.set(t,a),a}_calculateUniqueValues(e,t){const s={},i=this.items,a=i.length;for(let n=0;n<a;n++){const a=i[n],r=[];for(const t of e)r.push(t[n]);const o=r.join(",");null==s[o]?s[o]={count:1,data:r,items:[a],itemPositions:[n]}:(t||s[o].count++,s[o].items.push(a),s[o].itemPositions.push(n))}return s}async _getDataValues(e,t=!0){const i=new o(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:n,timeZone:r}=e;return a?i.getExpressionValues(this.items,a,{viewingMode:"map",scale:n,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},r):i.getDataValues(this.items,s.clone(e),t)}}function h(e,t,s,i){const a=i.x-s.x,n=i.y-s.y,r=a*a+n*n,o=(t.x-s.x)*a+(t.y-s.y)*n,l=Math.min(1,Math.max(0,o/r));e.x=s.x+a*l,e.y=s.y+n*l}function y(e,t){return e?t?4:3:t?3:2}class f{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}t.QueryEngineResult=g,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
