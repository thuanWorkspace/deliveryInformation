/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/arrayUtils","../../../core/Error","../../../core/JSONSupport","../../../core/lang","../../../core/maybe","../../../core/MemCache","../../../core/promiseUtils","../../../core/unitUtils","../../../geometry/projection","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../geometry/support/normalizeUtils","../../../geometry/support/spatialReferenceUtils","../featureConversionUtils","./attributeSupport","./geometryUtils","./projectionSupport","./QueryEngineCapabilities","./QueryEngineResult","./queryUtils","./queryValidationUtils","./spatialQuerySupport","./timeSupport","../../support/FieldsIndex","../../../views/support/Scheduler"],(function(e,t,i,r,s,a,n,u,l,o,h,c,y,m,d,p,f,g,x,_,w,R,Q,S,F,E,I,b){"use strict";const A="unsupported-query";class T{constructor(e,t=null,i,r,s){this.attributes=e,this.geometry=i,this.centroid=r,this.filterFlags=s,this.groupId=-1,this.displayId=t}}const v=new n.MemCacheStorage(2e6);let M=0;class j{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:w.queryCapabilities},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new n.MemCache(M+++"$$",v)),this.fieldsIndex=r.isSerializable(e.fieldsIndex)?e.fieldsIndex:I.fromJSON(e.fieldsIndex),this.availableFields=null==e.availableFields?new Set(this.fieldsIndex.fields.map((e=>e.name))):new Set(e.availableFields.map((e=>this.fieldsIndex.get(e)?.name)).filter((e=>null!=e))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=a.removeMaybe(this._frameTask),this.clearCache(),a.destroyMaybe(this._geometryQueryCache),this._changeHandle=a.removeMaybe(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==Q.queryEngineEmptyResult)throw i;return new R.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==Q.queryEngineEmptyResult)throw i;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const r=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=r.size;if(!s)return{count:0,extent:null};return{count:s,extent:await this._getBounds(r.items,r.spatialReference,i||this.spatialReference)}}catch(r){if(r===Q.queryEngineEmptyResult)return{count:0,extent:null};throw r}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=i.items,s=new Set;return await this._reschedule((()=>{for(const e of r)s.add(i.featureAdapter.getObjectId(e))}),t),s}catch(i){if(i===Q.queryEngineEmptyResult)return new Set;throw i}}async executeQueryForSnapping(e,t){const{point:i,distance:r,returnEdge:a,vertexMode:n}=e;if(!a&&"none"===n)return{candidates:[]};let u=s.clone(e.query);u=await this._schedule((()=>Q.normalizeQueryLike(u,this.definitionExpression,this.spatialReference)),t),u=await this._reschedule((()=>S.validateQuery(u,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),t);const l=!p.equals(i.spatialReference,this.spatialReference);l&&await _.checkProjectionSupport(i.spatialReference,this.spatialReference);const o="number"==typeof r?r:r.x,h="number"==typeof r?r:r.y,c={xmin:i.x-o,xmax:i.x+o,ymin:i.y-h,ymax:i.y+h,spatialReference:i.spatialReference},y=l?_.project(c,this.spatialReference):c;if(!y)return{candidates:[]};const f=(await d.normalizeCentralMeridian(m.fromJSON(i),null,{signal:t}))[0],g=(await d.normalizeCentralMeridian(m.fromJSON(y),null,{signal:t}))[0];if(null==f||null==g)return{candidates:[]};const x=new R.QueryEngineResult(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(g.toJSON()))),t),u,this);await this._reschedule((()=>this._executeObjectIdsQuery(x)),t),await this._reschedule((()=>this._executeTimeQuery(x)),t),await this._reschedule((()=>this._executeAttributesQuery(x)),t),await this._reschedule((()=>this._executeGeometryQueryForSnapping(x,t)),t);const w=f.toJSON(),F=l?_.project(w,this.spatialReference):w,E=l?Math.max(y.xmax-y.xmin,y.ymax-y.ymin)/2:r;return x.createSnappingResponse({...e,point:F,distance:E},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo?.trackIdField)throw new i(A,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(r){if(r!==Q.queryEngineEmptyResult)throw r;return new R.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:r,normalizationField:s,valueExpression:a}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:s,valueExpression:a},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:r,field2:s,field3:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,field2:s,field3:a,valueExpression:n},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:r,normalizationField:s,valueExpression:a}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:s,valueExpression:a},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:r,normalizationField:s,valueExpression:a}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:s,valueExpression:a},i)).createHistogramResponse(t)}async fetchRecomputedExtents(e){this._timeExtentPromise||(this._timeExtentPromise=E.getTimeExtent(this.timeInfo,this.featureStore));const[t,i]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return u.throwIfAborted(e),{fullExtent:t,timeExtent:i}}async _getBounds(e,t,i){const r=h.set(h.create(),h.negativeInfinity);await this.featureStore.forEachBounds(e,(e=>h.expandWithAABB(r,e)));const s={xmin:r[0],ymin:r[1],xmax:r[3],ymax:r[4],spatialReference:x.cleanFromGeometryEngine(this.spatialReference)};this.hasZ&&isFinite(r[2])&&isFinite(r[5])&&(s.zmin=r[2],s.zmax=r[5]);const a=_.project(s,t,i);if(a.spatialReference=x.cleanFromGeometryEngine(i),a.xmax-a.xmin==0){const e=l.getMetersPerUnitForSR(a.spatialReference);a.xmin-=e,a.xmax+=e}if(a.ymax-a.ymin==0){const e=l.getMetersPerUnitForSR(a.spatialReference);a.ymin-=e,a.ymax+=e}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=l.getMetersPerUnitForSR(a.spatialReference);a.zmin-=e,a.zmax+=e}return a}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference)))),this._fullExtentPromise}async _schedule(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(b.noBudget)}async _reschedule(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(b.noBudget)}async _getAllFeaturesQueryEngineResult(e){return new R.QueryEngineResult(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)))})().then((()=>e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=s.clone(e),e=await this._schedule((()=>Q.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>S.validateQuery(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),e={...e,...t};const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:r,returnCentroid:s}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,u=null==a||p.equals(a,n.spatialReference)?n:_.project(n,a);if(!u)return null;const l=r||s,o=p.isValid(i)&&!p.equals(this.spatialReference,i)&&l?async e=>this._project(e,i):e=>e,h=this.featureAdapter,c=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(u))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!c.length)return null;const i=new Set;for(const e of c)i.add(h.getObjectId(e));const r=await this._reschedule((()=>this._getAllFeatures()),t),s=await this._reschedule((async()=>{const s=await F.getSpatialQueryOperator("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(h.getObjectId(e))||s(h.getGeometry(e)),n=await this._runSpatialFilter(r,a,t);return new R.QueryEngineResult(n,e,this)}),t);return o(s)}if(!c.length)return new R.QueryEngineResult([],e,this);if(this._canExecuteSinglePass(u,e))return o(new R.QueryEngineResult(c,e,this));const y=await F.getSpatialQueryOperator("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(c,(e=>y(h.getGeometry(e))),t);return o(new R.QueryEngineResult(m,e,this))}async _executeGeometryQuery(e,i,r){if(null!=i&&0===i.items.length)return i;e=null!=i?i.query:e;const{geometry:s,outSR:a,spatialRel:n,returnGeometry:u,returnCentroid:l}=e,o=this.featureStore.featureSpatialReference,h=!s||null==o||p.equals(o,s.spatialReference)?s:_.project(s,o),c=u||l,y=p.isValid(a)&&!p.equals(this.spatialReference,a),m=this._geometryQueryCache&&null==i?y&&c?JSON.stringify({originalFilterGeometry:s,spatialRelationship:n,outSpatialReference:a}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:n}):null,d=m?this._geometryQueryCache.get(m):null;if(null!=d)return new R.QueryEngineResult(d,e,this);const f=async e=>(y&&c&&await this._project(e,a),m&&this._geometryQueryCache.put(m,e.items,e.items.length+1),e);if(!h)return f(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const g=this.featureAdapter;let x=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(s))),r);if("esriSpatialRelDisjoint"===n){if(!x.length)return f(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const t=new Set;for(const e of x)t.add(g.getObjectId(e));const s=null!=i?i.items:await this._reschedule((()=>this._getAllFeatures()),r),a=await this._reschedule((async()=>{const i=await F.getSpatialQueryOperator(n,h,this.geometryType,this.hasZ,this.hasM),a=e=>!t.has(g.getObjectId(e))||i(g.getGeometry(e)),u=await this._runSpatialFilter(s,a,r);return new R.QueryEngineResult(u,e,this)}),r);return f(a)}if(null!=i){const e=new t.PositionHint;x=x.filter((r=>t.indexOf(i.items,r,i.items.length,e)>=0))}if(!x.length){const t=new R.QueryEngineResult([],e,this);return m&&this._geometryQueryCache.put(m,t.items,1),t}if(this._canExecuteSinglePass(h,e))return f(new R.QueryEngineResult(x,e,this));const w=await F.getSpatialQueryOperator(n,h,this.geometryType,this.hasZ,this.hasM),Q=await this._runSpatialFilter(x,(e=>w(g.getGeometry(e))),r);return f(new R.QueryEngineResult(Q,e,this))}async _executeGeometryQueryForSnapping(e,t){const{query:i}=e,{spatialRel:r}=i;if(!e?.items?.length||!i.geometry||!r)return;const s=await F.getSpatialQueryOperator(r,i.geometry,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(e.items,(e=>s(e.geometry)),t);e.items=a}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const r of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(r).forEach((e=>t.add(e)))}const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=E.getTimeOperator(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=g.getWhereClause(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let r=0;const s=new Array,a=async n=>{for(;r<e.length;){const u=e[r++];t(u)&&(s.push(u),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>s))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:r}=this.timeInfo,s=r||i,a=new Map,n=this.featureAdapter.getAttribute;for(const u of e.items){const e=n(u,t),i=n(u,s),r=a.get(e);(!r||i>n(r,s))&&a.set(e,u)}e.items=Array.from(a.values())}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return F.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||p.equals(this.spatialReference,t))return e;const i=this.featureAdapter;let r;try{const e=await this._getFullExtent();r=o.getTransformation(this.spatialReference,t,e)}catch{}const s=await _.projectMany(e.items.map((e=>x.getGeometry(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t,r);return e.items=s.map(((t,r)=>i.cloneWithGeometry(e.items[r],f.convertFromGeometry(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(F.canQueryWithRBush(e)){if(m.isExtent(e))return[c.fromValues(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if(m.isPolygon(e))return e.rings.map((e=>c.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[y.getBoundsXY(c.create(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=s.clone(e);try{e=await this._schedule((()=>Q.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>S.validateStatisticsQuery(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(s)),i),await this._reschedule((()=>this._executeObjectIdsQuery(s)),i),await this._reschedule((()=>this._executeTimeQuery(s)),i),await this._reschedule((()=>this._executeAttributesQuery(s)),i),s}catch(r){if(r!==Q.queryEngineEmptyResult)throw r;return new R.QueryEngineResult([],e,this)}}}e.Feature=T,e.QueryEngine=j,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
