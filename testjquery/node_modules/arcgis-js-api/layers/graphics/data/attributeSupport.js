/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/Error","../../../core/sql/WhereClauseCache","../../support/fieldType"],(function(e,i,t,r){"use strict";const n=new t.WhereClauseCache(50,500),s="unsupported-query",a=" as ",o=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),l=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),d=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...o,...l]);function p(e,t,r={}){const a=f(t,e);if(!a){const r=n.getError(t,e);throw new i(s,"invalid SQL expression",{expression:t,error:r})}const o=r.expressionName||"expression";if(r.validateStandardized&&!a.isStandardized)throw new i(s,`${o} is not standard`,{expression:t});if(r.validateAggregate&&!a.isAggregate)throw new i(s,`${o} does not contain a valid aggregate function`,{expression:t});return a.fieldNames}function c(e,i,t,r){if(!t)return!0;const n="where clause";return m(e,i,p(e,t,{validateStandardized:!0,expressionName:n}),{expressionName:n,query:r}),!0}function u(e,t,r,n,a){if(!r)return!0;const o="having clause",l=p(e,r,{validateAggregate:!0,expressionName:o});m(e,t,l,{expressionName:o,query:a});const d=f(r,e),c=d?.getExpressions().every((i=>{const{aggregateType:t,field:r}=i,s=e.get(r)?.name;return n.some((i=>{const{onStatisticField:r,statisticType:n}=i,a=e.get(r)?.name;return a===s&&n.toLowerCase().trim()===t}))}));if(!c)throw new i(s,"expressions in having clause should also exist in outStatistics",{having:r});return!0}function f(e,i){return e?n.get(e,i):null}function y(e){return/\((.*?)\)/.test(e)?e:e.split(a)[0]}function g(e){return e.split(a)[1]}function m(e,t,r,n={}){const a=new Map;if(T(a,e,t,n.allowedFieldTypes??d,r),a.size){const e=n.expressionName??"expression";throw new i(s,`${e} contains invalid or missing fields`,{errors:Array.from(a.values()),query:n.query})}}function T(e,i,t,r,n){for(const a of n){if("*"===a)continue;if(i.get(a))F(e,i,t,r,a);else try{const n=p(i,y(a),{validateStandardized:!0});for(const s of n)F(e,i,t,r,s)}catch(s){e.set(a,{type:"expression-error",expression:a,error:s})}}}function F(e,i,t,n,s){if("*"===s)return;const a=i.get(s);a?t.has(a.name)?!1===n?.has(a.type)&&e.set(s,{type:"invalid-type",fieldName:a.name,fieldType:r.kebabDict.fromJSON(a.type),allowedFieldTypes:Array.from(n,(e=>r.kebabDict.fromJSON(e)))}):e.set(s,{type:"missing-field",fieldName:a.name}):e.set(s,{type:"invalid-field",fieldName:s})}e.allDateAndTimeFieldTypes=l,e.getAliasFromFieldName=g,e.getExpressionFromFieldName=y,e.getWhereClause=f,e.numericFieldTypes=o,e.validateFields=m,e.validateHaving=u,e.validateWhere=c,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
