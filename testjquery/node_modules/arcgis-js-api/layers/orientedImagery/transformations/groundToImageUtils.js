/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/Error","../../../core/Logger","../../../core/promiseUtils","../../../chunks/mat3","../../../geometry/Point","../../../geometry/projection","../../../geometry/support/webMercatorUtils","../../ElevationLayer","../core/ElevationSourceDefinitions","./utils"],(function(e,t,a,r,i,n,o,c,s,l,u){"use strict";function m(e){return"esri.Graphic"===e?.declaredClass}const f=Math.PI/180;async function p(e,t,a=!1){if(!e)return[];e=e.map((e=>"esri.geometry.Point"===e.declaredClass?e:n.fromJSON(e)));const{feature:r}=t,{attributes:i}=r;if(isNaN(parseFloat(i.elevation))){const e=await g([r.geometry],t);r.attributes.elevation=e[0].z}return g(e,t,a).then((e=>v(e,t)))}async function g(e,t,a=!1){if(a)return e;const{feature:{attributes:{cameraOrientation:r,elevationSource:i,cameraHeight:n,location:o}}}=t;return i&&(l.isConstantElevation(i)||i.url?.length)?d(e,t):h(e,r&&"number"==typeof o.z?o.z-n:0)}async function d(e,t){const{feature:i,options:n,currentCoveragePolygon:o}=t,c=i.attributes.elevationSource;if(!c)return e;if(l.isConstantElevation(c)){const{constantElevation:t}=c;return"number"!=typeof t?e:h(e,t)}const{url:u}=c;if(!u)return e;const{elevationSample:f}=i;if(!f){const t=m(o)?o.geometry?.extent:o.extent;if(!t)return e;const f=t.clone();f.xmin/=2,f.xmax*=2,f.ymin/=2,f.ymax*=2;const{error:g,isSupported:d}=await l.validateElevationSourceURL(u);if(!d){a.getLogger(c).warn(g);const{location:t,cameraHeight:r,cameraOrientation:n}=i.attributes;return h(e,n&&"number"==typeof t.z?t.z-r:0)}const v=new s(u);let b=e;try{await v.load(),i.elevationSample=await v.createElevationSampler(f,n),b=e.map(y(i.elevationSample))}catch(p){r.isAbortError(p)||a.getLogger("esri.layers.orientedImagery.transformations.groundToImageUtils").warn(`#updateElevation() failed to update elevation using the provided elevation source URL: ${u}. Please provide a valid elevation source url.`,p)}finally{v.destroy()}return b}return e.map(y(f))}function y(e){return t=>{t.z=1;const a=e.queryElevation(o.project(t,e.spatialReference));return a?.z&&(t.z=a.z),t}}function h(e,t){return e.map((e=>(e.z=t,e)))}function v(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?{}:a.cameraOrientation?.isAdvanced?M(e,t):Promise.resolve(b(e,t))}function b(e,t){const{feature:a,imageProperties:r}=t,{width:o,height:s}=r,{attributes:l}=a,m=u.calculateRotationMatrix("HPR",[l.cameraHeading,l.cameraPitch,l.cameraRoll]),p=Math.sin(l.imageRotation??0*f),g=Math.cos(l.imageRotation??0*f),d=o??1,y=s??1,h=[Math.abs(g*d+p*y),Math.abs(g*y-p*d)],v={horizontal:1/(2*Math.tan(l.horizontalFieldOfView*f/2)),vertical:1/(2*Math.tan(l.verticalFieldOfView*f/2))},b=[-v.horizontal,0,.5,0,v.vertical,.5,0,0,1];let M=new n(l.geometry);M.spatialReference.isWGS84&&4!==l.cameraOrientation?.type&&(M=c.geographicToWebMercator(M));const w=M.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*M.y/6378137))):1,R=i.mul(new Array(9),m,b);return e.map((e=>{let t=new n(e);if(t.spatialReference.isWGS84)if(4===l.cameraOrientation?.type){const e=l.cameraOrientation;t=new n(u.geographicToLTP(t,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}else t=new n(c.geographicToWebMercator(t));const a=(t.z??0)-(M.z??0),r=(t.x-M.x)/w,i=(t.y-M.y)/w,o=(R[0]*r+R[1]*i+R[2]*a)/(R[6]*r+R[7]*i+R[8]*a),s=(R[3]*r+R[4]*i+R[5]*a)/(R[6]*r+R[7]*i+R[8]*a),m={x:o*h[0],y:s*h[1]};return{x:g*(m.x-h[0]/2)+p*(m.y-h[1]/2)+d/2,y:-p*(m.x-h[0]/2)+g*(m.y-h[1]/2)+y/2}}))}function M(e,a){const{feature:r}=a,{attributes:i}=r,s=i.cameraOrientation;if(!s)throw new t("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");let l=new n(i.location);l.spatialReference.isWGS84&&4!==i.cameraOrientation?.type&&(l=c.geographicToWebMercator(l));const m=l.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*l.y/6378137))):1;let f;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===s.declaredClass){const{omega:e,phi:t,kappa:a}=s;f=u.calculateRotationMatrix("OPK",[e,t,a])}else{const{cameraHeading:e,cameraPitch:t,cameraRoll:a}=i;f=u.calculateRotationMatrix("HPR",[e,t,a])}const{principalOffsetPoint:p,focalLength:g,radialDistortionCoefficients:d,affineTransformations:y,tangentialDistortionCoefficients:h}=s;return Promise.all(e.map((e=>{let t;return e.spatialReference.equals(l.spatialReference)?(t=new n(e),a(t)):(t=o.project(e,l.spatialReference),t?a(t):null);function a(e){if(e.spatialReference.isWGS84)if(4===i.cameraOrientation?.type){const t=i.cameraOrientation;e=new n(u.geographicToLTP(e,[t.latitude,t.longitude,t.ellipsoidRadius,t.squaredEccentricity]))}else e=new n(c.geographicToWebMercator(e));const t=(e.z??0)-(l.z??0),a=(e.x-l.x)/m,r=(e.y-l.y)/m,o=(f[0]*a+f[1]*r+f[2]*t)/(f[6]*a+f[7]*r+f[8]*t),s=(f[3]*a+f[4]*r+f[5]*t)/(f[6]*a+f[7]*r+f[8]*t),v=o**2+s**2;let b=0,M=0,w=0,R=0,P=0,x=0,O=0;d&&(b=d[0]??0,M=d[1]??0,w=d[2]??0),h&&(R=h[0],P=h[1]),p&&(x=p[0]??0,O=p[1]??0);const z=1+(b||0)*v+(M||0)*v*v+(w||0)*v*v*v;let S=o*z+(R||0)*(v+2*o**2)+2*(P||0)*o*s,E=s*z+(P||0)*(v+2*s**2)+2*(R||0)*o*s;S=-(g??0)*S+x,E=-(g??0)*E+O;return{x:Number(y[0])+Number(y[1])*S+Number(y[2])*E,y:Number(y[3])+Number(y[4])*S+Number(y[5])*E}}})))}e.transformPoints=p,e.updateElevation=g,e.updateElevationUsingElevationSource=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
