/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../LOD","../RasterInfo","../RasterStorageInfo","../TileInfo","./BaseRaster","./DBFParser","../rasterTransforms/utils","../../../rest/support/FeatureSet","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,r,i,a,n,o,s,l,f,c,d,u,p,m,h,g,y,x){"use strict";const S=new Map;S.set("int16","esriFieldTypeSmallInteger"),S.set("int32","esriFieldTypeInteger"),S.set("int64","esriFieldTypeInteger"),S.set("float32","esriFieldTypeSingle"),S.set("float64","esriFieldTypeDouble"),S.set("text","esriFieldTypeString");const I=8;let w=class extends u{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(e){await this.init();const{data:t}=await this.request(this.url+"/conf.json",{signal:e?.signal});if(!this._validateHeader(t))throw new r("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:i,rasterInfo:a}=this._parseHeader(t);if("thematic"===a.dataType){const e=await this._fetchAuxiliaryInformation();a.attributeTable=e}this._set("storageInfo",i),this._set("rasterInfo",a),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(e,t,r,i={}){const{transposeInfo:a}=this.rasterInfo.storageInfo,{transposedVariableName:n}=i,o=!(!a||!n),s=o?0:this.rasterInfo.storageInfo.maximumPyramidLevel-e;if(s<0)return null;const l=this._buildCacheFilePath(s,t,r,i.multidimensionalDefinition,n),f=this._getIndexRecordFromBundle(t,r,o),c=await this.request(l,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:i.signal});if(!c)return null;const d=new Uint8Array(c.data),u=this._getTileEndAndContentType(d,f);if(0===u.recordSize)return null;const p=await this.request(l,{range:{from:u.position,to:u.position+u.recordSize},responseType:"array-buffer",signal:i.signal});if(!p)return null;const[m,h]=this._getTileSize(o);return this.decodePixelBlock(p.data,{width:m,height:h,planes:null,pixelType:null,returnInterleaved:o})}_validateHeader(e){const t=["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"];return e&&"RasterInfo"===e.type&&!t.some((t=>!e[t]))}_parseHeader(e){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][e.pixelType],{bandCount:r,colormap:i,blockWidth:a,blockHeight:n,firstPyramidLevel:o,maximumPyramidLevel:s}=e,u=e.statistics?.map((e=>({min:e.min,max:e.max,avg:e.mean,stddev:e.standardDeviation,median:e.median,mode:e.mode}))),p=e.histograms?.[0]?.counts?.length?e.histograms:null,m=e.extent.spatialReference,h=e.geodataXform?.spatialReference,S=new g(m?.wkid||m?.wkt||m?.wkt2?m:h);let w=new y({xmin:e.extent.xmin,ymin:e.extent.ymin,xmax:e.extent.xmax,ymax:e.extent.ymax,spatialReference:S});const _=new x({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:S}),v=Math.round((w.xmax-w.xmin)/_.x),b=Math.round((w.ymax-w.ymin)/_.y),T=this._parseTransform(e.geodataXform),z=T?w:null;T&&(w=T.forwardTransform(w),_.x=(w.xmax-w.xmin)/v,_.y=(w.ymax-w.ymin)/b);const k=e.properties??{},C=e.format.toLowerCase().replace("cache/",""),R=new x(e.origin.x,e.origin.y,S);let F,P,H,D;if(i?.colors)for(F=[],P=0;P<i.colors.length;P++)H=i.colors[P],D=i.values?i.values[P]:P,F.push([D,255&H,H<<16>>>24,H<<8>>>24,H>>>24]);const L=e.LODInfos,M=[];for(P=0;P<L.levels.length;P++)M.push(new l({level:L.levels[P],resolution:L.resolutions[P],scale:96/.0254*L.resolutions[P]}));const O=new d({dpi:96,lods:M,format:C,origin:R,size:[a,n],spatialReference:S}),B={recordSize:I,packetSize:e.packetSize,headerSize:e.packetSize*e.packetSize*I+64},$=[{maxCol:Math.ceil(v/a)-1,maxRow:Math.ceil(b/n)-1,minCol:0,minRow:0}];let N=2;if(s>0)for(P=0;P<s;P++)$.push({maxCol:Math.ceil(v/N/a)-1,maxRow:Math.ceil(b/N/n)-1,minCol:0,minRow:0}),N*=2;const q=e.mdInfo;let A=null;if(q&&k._yxs){const e=k._yxs;A={packetSize:e.PacketSize,tileSize:[e.TileXSize,e.TileYSize]}}return{storageInfo:B,rasterInfo:new f({width:v,height:b,pixelType:t,bandCount:r,extent:w,nativeExtent:z,transform:T,spatialReference:S,pixelSize:_,keyProperties:k,statistics:u,histograms:p,multidimensionalInfo:q,colormap:F,storageInfo:new c({blockWidth:a,blockHeight:n,pyramidBlockWidth:a,pyramidBlockHeight:n,origin:R,tileInfo:O,transposeInfo:A,firstPyramidLevel:o,maximumPyramidLevel:s,blockBoundary:$})})}}_parseTransform(e){if(!m.isTransformSupported(e))throw new r("cloudraster:open","the data contains unsupported geodata transform types");const t=m.readTransform(e);if("identity"===t.type)return null;if("polynomial"!==t.type||!t.forwardCoefficients?.length||!t.inverseCoefficients?.length)throw new r("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return t}async _fetchAuxiliaryInformation(e){const t=this.request(this.url+"/conf.vat.json",{signal:e}).then((e=>e.data)).catch((()=>null)),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:e}).then((e=>e.data)).catch((()=>null)),i=await Promise.all([t,r]);let a;if(i[0]){let e=i[0].fields;const t=i[0].values;if(e&&t){e=e.map((e=>({type:"OID"===e.name?"esriFieldTypeOID":S.get(e.type),name:e.name,alias:e.alias||e.name})));const r=t.map((e=>({attributes:e})));e&&t&&(a={fields:e,features:r})}}if(!a&&i[1]){a=p.parse(i[1]).recordSet}return h.fromJSON(a)}_buildCacheFilePath(e,t,r,i,a){const n=this._getPackageSize(!!a),o=Math.floor(t/n)*n,s=Math.floor(r/n)*n,l="R"+this._toHexString4(o)+"C"+this._toHexString4(s);let f="L";f+=e>=10?e.toString():"0"+e.toString();const{multidimensionalInfo:c}=this.rasterInfo,d=i?.[0];if(null==c||!d)return`${this.url}/_alllayers/${f}/${l}.bundle`;let u="_yxs";if(!a){u=c.variables.find((e=>e.name===d.variableName)).dimensions[0].values.indexOf(d.values[0]).toString(16);const e=4-u.length;for(let t=0;t<e;t++)u="0"+u;u="S"+u}const p=this._getVariableFolderName(a||d.variableName);return`${this.url}/_alllayers/${p}/${u}/${f}/${l}.bundle`}_getPackageSize(e=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return e&&null!=t?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(e=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:r}=t;return e&&null!=r?r.tileSize:t.tileInfo.size}_getVariableFolderName(e){return""===(e=e.trim())?"_v":e.replaceAll(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(e,t,r=!1){const i=this._getPackageSize(r),a=i*(e%i)+t%i;if(a<0)throw new Error("Invalid level / row / col");return 20+a*this.storageInfo.recordSize+44}_getTileEndAndContentType(e,t){const r=e.subarray(t,t+8);let i,a=0;for(i=0;i<5;i++)a|=(255&r[i])<<8*i;const n=0xffffffffff&a;for(a=0,i=5;i<8;i++)a|=(255&r[i])<<8*(i-5);return{position:n,recordSize:0xffffffffff&a}}_toHexString4(e){let t=e.toString(16);if(4!==t.length){let e=4-t.length;for(;e-- >0;)t="0"+t}return t}};e.__decorate([i.property({readOnly:!0})],w.prototype,"storageInfo",void 0),e.__decorate([i.property({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),w=e.__decorate([s.subclass("esri.layers.support.rasterDatasets.CloudRaster")],w);return w}));
