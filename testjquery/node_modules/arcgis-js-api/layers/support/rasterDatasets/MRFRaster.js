/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo","../RasterStorageInfo","./BaseRaster","./pamParser","./xmlUtilities","../rasterFormats/utils","../rasterFunctions/stretchUtils","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,r,s,a,n,i,o,l,c,h,f,u,g,p,m,d,y,x){"use strict";const w=new Map;w.set("Int8","s8"),w.set("UInt8","u8"),w.set("Int16","s16"),w.set("UInt16","u16"),w.set("Int32","s32"),w.set("UInt32","u32"),w.set("Float32","f32"),w.set("Float64","f32"),w.set("Double64","f32");const I=new Map;I.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),I.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),I.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),I.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let b=class extends f{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(e){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?e.signal:null,r=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:s,files:a}=this._parseHeader(r.data);if(-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")){const t=await this._fetchAuxiliaryData(e);null!=t&&(s.statistics=t.statistics??s.statistics,s.histograms=t.histograms,t.histograms&&null==s.statistics&&(s.statistics=m.estimateStatisticsFromHistograms(t.histograms)))}this._set("rasterInfo",s),this._files=a;const n=await this.request(a.index,{responseType:"array-buffer",signal:t});this._storageIndex=this._parseIndex(n.data);const{blockWidth:i,blockHeight:o}=this.rasterInfo.storageInfo,l=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:c,height:h}=this.rasterInfo,f=[],u=this._getBandSegmentCount();let g=0,p=-1;for(;g<this._storageIndex.length;){p++;const e=Math.ceil(c/i/l**p)-1,t=Math.ceil(h/o/l**p)-1;g+=(e+1)*(t+1)*u*4,f.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=f,p>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=p),this.updateTileInfo()}async fetchRawTile(e,t,r,s={}){const{blockWidth:a,blockHeight:n,blockBoundary:i}=this.rasterInfo.storageInfo,o=i[e];if(!o||o.maxRow<t||o.maxCol<r||o.minRow>t||o.minCol>r)return null;const{bandCount:c,pixelType:h}=this.rasterInfo,{ranges:f,actualTileWidth:u,actualTileHeight:g}=this._getTileLocation(e,t,r);if(!f||0===f.length)return null;if(0===f[0].from&&0===f[0].to){const e=new Uint8Array(a*n);return new l({width:a,height:n,pixels:null,mask:e,validPixelCount:0})}const{bandIds:p}=this.ioConfig,m=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<m;y++)p&&!p.includes(y)||d.push(this.request(this._files.data,{range:{from:f[y].from,to:f[y].to},responseType:"array-buffer",signal:s.signal}));const x=await Promise.all(d),w=x.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),b=new Uint8Array(w);let _=0;for(y=0;y<m;y++)b.set(new Uint8Array(x[y].data),_),_+=x[y].data.byteLength;const A=I.get(this.rasterInfo.storageInfo.compression).decoderFormat,F=await this.decodePixelBlock(b.buffer,{width:a,height:n,format:A,planes:p?.length||c,pixelType:h});if(null==F)return null;let{noDataValue:R}=this.rasterInfo;if(null!=R&&"lerc"!==A&&!F.mask&&(R=R[0],null!=R)){const e=F.width*F.height,t=new Uint8Array(e);if(Math.abs(R)>1e24)for(y=0;y<e;y++)Math.abs((F.pixels[0][y]-R)/R)>1e-6&&(t[y]=1);else for(y=0;y<e;y++)F.pixels[0][y]!==R&&(t[y]=1);F.mask=t}let S=0,E=0;if(u!==a||g!==n){let e=F.mask;if(e)for(y=0;y<n;y++)if(E=y*a,y<g)for(S=u;S<a;S++)e[E+S]=0;else for(S=0;S<a;S++)e[E+S]=0;else for(e=new Uint8Array(a*n),F.mask=e,y=0;y<g;y++)for(E=y*a,S=0;S<u;S++)e[E+S]=1}return F}_parseIndex(e){if(e.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,r,s,a,n,i;if(p.isPlatformLittleEndian){for(r=new Uint8Array(e),a=new ArrayBuffer(e.byteLength),s=new Uint8Array(a),n=0;n<e.byteLength/4;n++)for(i=0;i<4;i++)s[4*n+i]=r[4*n+3-i];t=new Uint32Array(a)}else t=new Uint32Array(e);return t}_getBandSegmentCount(){return I.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(e,t,r){const{blockWidth:s,blockHeight:a,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:i,height:o}=this.rasterInfo,l=this._getBandSegmentCount();let c,h,f,u=0,g=0;for(f=0;f<e;f++)g=n**f,c=Math.ceil(i/s/g),h=Math.ceil(o/a/g),u+=c*h;g=n**e,c=Math.ceil(i/s/g),h=Math.ceil(o/a/g),u+=t*c+r,u*=4*l;const p=this._storageIndex.subarray(u,u+4*l);let m=0,d=0;const y=[];for(let x=0;x<l;x++)m=p[4*x]*2**32+p[4*x+1],d=m+p[4*x+2]*2**32+p[4*x+3],y.push({from:m,to:d});return{ranges:y,actualTileWidth:r<c-1?s:Math.ceil(i/g)-s*(c-1),actualTileHeight:t<h-1?a:Math.ceil(o/g)-a*(h-1)}}_parseHeader(e){const t=g.getElement(e,"MRF_META/Raster");if(!t)throw new r("mrf:open","not a valid MRF format");const s=g.getElement(t,"Size"),a=parseInt(s.getAttribute("x"),10),n=parseInt(s.getAttribute("y"),10),i=parseInt(s.getAttribute("c"),10),o=(g.getElementValue(t,"Compression")||"none").toLowerCase();if(!I.has(o))throw new r("mrf:open","currently does not support compression "+o);const l=g.getElementValue(t,"DataType")||"UInt8",f=w.get(l);if(null==f)throw new r("mrf:open","currently does not support pixel type "+l);const p=g.getElement(t,"PageSize"),m=parseInt(p.getAttribute("x"),10),b=parseInt(p.getAttribute("y"),10),_=g.getElement(t,"DataValues");let A,F;_&&(F=_.getAttribute("NoData"),null!=F&&(A=F.trim().split(" ").map((e=>parseFloat(e)))));if(g.getElement(e,"MRF_META/CachedSource"))throw new r("mrf:open","currently does not support MRF referencing other data files");const R=g.getElement(e,"MRF_META/GeoTags"),S=g.getElement(R,"BoundingBox");let E,M=!1;if(null!=S){const e=parseFloat(S.getAttribute("minx")),t=parseFloat(S.getAttribute("miny")),r=parseFloat(S.getAttribute("maxx")),s=parseFloat(S.getAttribute("maxy")),a=g.getElementValue(R,"Projection")||"";let n=d.WGS84;if("LOCAL_CS[]"!==a)if(a.toLowerCase().startsWith("epsg:")){const e=Number(a.slice(5));isNaN(e)||0===e||(n=new d({wkid:e}))}else n=u.parseSpatialReference(a)??d.WGS84;else M=!0,n=new d({wkid:3857});E=new y(e,t,r,s),E.spatialReference=n}else M=!0,E=new y({xmin:-.5,ymin:.5-n,xmax:a-.5,ymax:.5,spatialReference:new d({wkid:3857})});const k=g.getElement(e,"MRF_META/Rsets"),T=parseInt(k?.getAttribute("scale")||"2",10),C=E.spatialReference,U=new h({origin:new x({x:E.xmin,y:E.ymax,spatialReference:C}),blockWidth:m,blockHeight:b,pyramidBlockWidth:m,pyramidBlockHeight:b,compression:o,pyramidScalingFactor:T}),B=new x({x:E.width/a,y:E.height/n,spatialReference:C}),L=new c({width:a,height:n,extent:E,isPseudoSpatialReference:M,spatialReference:C,bandCount:i,pixelType:f,pixelSize:B,noDataValue:A,storageInfo:U}),P=g.getElementValue(e,"datafile"),H=g.getElementValue(e,"IndexFile");return{rasterInfo:L,files:{mrf:this.url,index:H||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",I.get(o).blobExtension)}}}async _fetchAuxiliaryData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return u.parsePAMInfo(t)}catch{return null}}};e.__decorate([s.property()],b.prototype,"_files",void 0),e.__decorate([s.property()],b.prototype,"_storageIndex",void 0),e.__decorate([s.property({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),b=e.__decorate([o.subclass("esri.layers.support.rasterIO.MRFRaster")],b);return b}));
