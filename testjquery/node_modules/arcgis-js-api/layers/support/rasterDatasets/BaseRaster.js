/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../geometry","../../../request","../../../core/Error","../../../core/JSONSupport","../../../core/Logger","../../../core/Promise","../../../core/promiseUtils","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../arcgisLayerUrl","../commonProperties","../DimensionalDefinition","../LOD","../RasterStorageInfo","../TileInfo","./multidimensionalUtils","./RawBlockCache","../rasterFormats/pixelRangeUtils","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/vectorFieldUtils","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,i,o,r,n,s,l,a,c,u,h,f,m,p,d,x,y,g,I,R,S,w,k,T,_,b,v){"use strict";const P=8,B=256;let W=class extends(s.EsriPromiseMixin(r.JSONSupport)){constructor(){super(...arguments),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=T.load();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:g.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=T.getWorldWidth(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}set url(e){this._set("url",m.sanitizeUrl(e,n.getLogger(this)))}async open(e){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,i,o={}){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,i,r);return this.fetchPixels(n,r.size[0],r.size[1],o)}async identify(e,t={}){e=c.ensureClass(v,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:o}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:s}=r;let{transposedVariableName:l}=t;const a=null!=s&&n&&(null!=o||I.isMultiSliceOrRangeDefinition(i));if(a&&!l){l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:u,extent:h}=r,{datumTransformation:f}=t;let m=T.projectPoint(e,u,f);if(!h.intersects(m))return{location:m,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(m);if(!r.nativeExtent.intersects(e))return{location:e,value:null};m=e}let p=0;const d=null!=l&&null!=s&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(d)return e.identify(m,t);const{pixelSize:i}=r,o=3,n=i.x*o/2,s=i.y*o/2,l=new b({xmin:m.x-n,xmax:m.x+n,ymin:m.y-s,ymax:m.y+s,spatialReference:u}),a={interpolation:"nearest"},{pixelBlock:c}=await e.fetchPixels(l,o,o,a),{pixelBlock:h}=await this.fetchPixels(l,o,o,a);if(null==c)return{location:m,value:null};const f=Math.floor(o*o*.5),p=!c.mask||c.mask[f]?c.pixels.map((e=>e[f])):null;let x;return null!=h&&(x=!h.mask||h.mask[f]?h.pixels.map((e=>e[f])):void 0),{location:m,value:p,processedValue:x,pyramidLevel:0}}if(!d)if(t.srcResolution){p=T.snapPyramid(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel}else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:m,value:null};const x=this.identifyPixelLocation(m,p,null,d);if(null===x)return{location:m,value:null};const{row:y,col:g,rowOffset:S,colOffset:w,blockWidth:k}=x,_=l??t.sliceId,P=R.getRasterId(this.url,_),B=`${p}/${y}/${g}`;let W=R.getBlock(P,null,B);null==W&&(W=this.fetchRawTile(p,y,g,t),R.putBlock(P,null,B,W));const M=await W;if(!M?.pixels?.length)return{location:m,value:null};const C=S*k+w;return this._processIdentifyResult(M,{srcLocation:m,position:C,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:a,identifyOptions:t})}async fetchPixels(e,t,i,o={}){e=T.shiftExtent(e),o=this._getRequestOptionsWithSliceId(o);const{_hasNoneOrGCSShiftTransform:r}=this;if(o.requestRawData&&r)return this._fetchPixels(e,t,i,o);const n=T.getWorldWidth(e.spatialReference),s=T.getWorldWrapCount(e);if(null==n||0===s||1===s&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,o);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,u=Math.round(n/(c-a)*t),h=u-Math.round((n/2-a)/(c-a)*t);let f=0;const m=[];for(let y=0;y<=s;y++){const r=new b({xmin:0===y?a:-n/2,xmax:y===s?c-n*y:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===y?u-h:y===s?t-f:u;f+=p,m.push(p);const d=o.disableWrapAround&&y>0?null:this._fetchPixels(r,p,i,o);l.push(d)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},o)).pixelBlock}else d=k.mosaic(p,x,{blockWidths:m});return{extent:e,srcExtent:T.projectExtent(e,this.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:d}}async fetchRawPixels(e,t,i,o={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,o),{nativeExtent:n,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,u=s.y*a,h=new b({xmin:n.xmin+c*t.x,xmax:n.xmin+c*(t.x+i.width-1),ymin:n.ymax-u*(t.y+i.height-1),ymax:n.ymax-u*t.y,spatialReference:n.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:f,mosaicSize:m}=r;if(1===f.length&&null!=f[0]&&f[0].width===i.width&&f[0].height===i.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,d=e>0?l.pyramidBlockHeight:l.blockHeight,x={x:t.x%p,y:t.y%d};let y;if(this.rasterJobHandler){y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:m,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:o.interpolation,alignmentInfo:null,blockWidths:null},o)).pixelBlock}else y=k.mosaic(f,m,{clipOffset:x,clipSize:i});return{extent:h,srcExtent:h,pixelBlock:y}}fetchRawTile(e,t,i,r){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return T.projectExtent(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?w.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,o=0){const{customFetchParameters:r}=this.ioConfig,{range:n,query:s,headers:l}=t;o=o??t.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await i(e,{...t,query:{...s,...r},headers:{...l,...a}})}catch(c){if(o>0)return o--,this.request(e,t,o);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:I.getSliceIndex(e,t)}getTileExtentFromTileInfo(e,t,i,o){const r=o.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const r=[],n=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),l=1/.0254*96*s;for(let e=0;e<=n;e++)r.unshift(new x({level:n-e,resolution:s,scale:l})),s*=2,l*=2;const a=new v({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new g({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:r}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,o){const{width:r,height:n,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new v({x:s.xmin,y:s.ymax,spatialReference:a});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],o);e.storageInfo=new y({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,o,r,n=0,s=2){if(1===r.length&&n>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<n;i++)e*=s,t*=s,r.push({x:e,y:t})}const l=[],{x:a,y:c}=o;for(let u=0;u<r.length;u++){const{x:o,y:n}=r[u];l.push({minCol:Math.floor((e.xmin-a+.1*o)/t/o),maxCol:Math.floor((e.xmax-a-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/i/n),maxRow:Math.floor((c-e.ymin-.1*n)/i/n)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=o**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,o){const{spatialReference:r,nativeExtent:n,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,u=o&&null!=c?c.tileSize[0]:s.blockWidth,h=o&&null!=c?c.tileSize[1]:s.blockHeight,f=T.projectPoint(e,r,i);if(!n.intersects(f))return null;if(t<0||t>l)return null;const m=this.getPyramidPixelSize(t),{x:p,y:d}=m,x=(a.y-f.y)/d/h,y=(f.x-a.x)/p/u,g=Math.min(h-1,Math.floor((x-Math.floor(x))*h)),I=Math.min(u-1,Math.floor((y-Math.floor(y))*u));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:u,srcLocation:f}}getTileExtent(e,t,i,o,r,n){const[s,l]=n,a=o.x+i*s*e.x,c=a+s*e.x,u=o.y-t*l*e.y,h=u-l*e.y;return new b({xmin:a,xmax:c,ymin:h,ymax:u,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<i||o.minRow>t||o.minCol>i}async _fetchPixels(e,t,i,o={}){let r=T.getWorldWrapCount(e);if(r>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,i,o),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:u,ul:h}=n;if(0===c||0===u)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:f}=this,m=f.transform,p="gcs-shift"===m?.type,d=null!=T.getWorldWidth(e.spatialReference);!p&&d||(r=T.getWorldWrapCount(n.srcExtent,p));const x=await this._fetchRawTiles(s,h,{width:c,height:u,wrapCount:r},o);if(!x)return{extent:e,srcExtent:a,pixelBlock:null};const y=f.storageInfo,g=s>0?y.pyramidBlockWidth:y.blockWidth,I=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:R,y:S}=f.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=y;if(null!=e&&e[s-1])({x:R,y:S}=e[s-1]);else{const e=t**s;R*=e,S*=e}}const w=f.spatialReference,b=new v({x:R,y:S,spatialReference:w}),P=g===c&&I===u&&h.x%g==0&&h.y%I==0,B=new v({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),W=!e.spatialReference.equals(w),M=w.isGeographic?1e-9:1e-4,{datumTransformation:C}=o;if(!W&&P&&1===x.pixelBlocks.length&&g===t&&I===i&&this._isSameResolution(l,B,M))return{extent:e,srcExtent:a,srcTilePixelSize:b,pixelBlock:x.pixelBlocks[0]};const E=d&&null!=T.getWorldWidth(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,H=o.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");H&&!this.rasterJobHandler&&await T.load();const L=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:B.toJSON(),datumTransformation:C,rasterTransform:m,hasWrapAround:r>0||E,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:H},o):T.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:B,datumTransformation:C,rasterTransform:m,hasWrapAround:r>0||E,isAdaptive:!1,includeGCSGrid:H});let z;const D=!o.requestRawData,O={rows:L.spacing[0],cols:L.spacing[1]},A=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:F,mosaicSize:G,isPartiallyFilled:N}=x;let q=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:G,destDimension:D?{width:t,height:i}:null,coefs:D?L.coefficients:null,sampleSpacing:D?O:null,projectDirections:H,gcsGrid:H?L.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:o.interpolation,alignmentInfo:A,blockWidths:null},o);({pixelBlock:z,localNorthDirections:q}=e)}else{const e=k.mosaic(F,G,{alignmentInfo:A});z=D?k.approximateTransform(e,{width:t,height:i},L.coefficients,O,o.interpolation):e,H&&L.gcsGrid&&(q=k.getLocalArithmeticNorthRotations({width:t,height:i},L.gcsGrid),z=_.convertToLocalDirections(z,this.rasterInfo.dataType,q))}return o.requestRawData||H?{extent:e,srcExtent:a,srcTilePixelSize:b,pixelBlock:z,transformGrid:L,localNorthDirections:q,isPartiallyFilled:N}:{extent:e,srcExtent:a,srcTilePixelSize:b,pixelBlock:z}}async _fetchRawTiles(e,t,i,o){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:u,height:h,wrapCount:f}=i;const m=this._getRasterTileAlignmentInfo(e,0);o.buffer&&(a-=o.buffer.cols,c-=o.buffer.rows,u+=2*o.buffer.cols,h+=2*o.buffer.rows);let p=0,d=0,x=0;if(f&&null!=m){({worldColumnCountFromOrigin:d,originColumnOffset:x,rightPadding:p}=m);d*m.blockWidth-p>=a+u&&(p=0)}const y=Math.floor(a/s),g=Math.floor(c/l),I=Math.floor((a+u+p-1)/s),R=Math.floor((c+h+p-1)/l),S=n[e];if(!S)return null;const{minRow:w,minCol:k,maxCol:T,maxRow:_}=S;if(0===f&&(R<w||I<k||g>_||y>T))return null;const v=new Array;let P=!1;const B=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let b=g;b<=R;b++)for(let t=y;t<=I;t++){let i=t;if(!o.disableWrapAround&&f&&null!=m&&d<=t&&(i=t-d-x),b>=w&&i>=k&&_>=b&&T>=i){const t=this._fetchRawTile(e,b,i,o);B?v.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):v.push(t)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const W=await Promise.all(v),M={height:(R-g+1)*l,width:(I-y+1)*s},{spatialReference:C}=this.rasterInfo,E=this.getPyramidPixelSize(e),{x:H,y:L}=E;return{extent:new b({xmin:r.x+y*s*H,xmax:r.x+(I+1)*s*H,ymin:r.y-(R+1)*l*L,ymax:r.y-g*l*L,spatialReference:C}),pixelBlocks:W,mosaicSize:M,isPartiallyFilled:P}}_isSameResolution(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}_fetchRawTile(e,t,i,o){const r=this.rasterInfo.storageInfo.blockBoundary[e];if(!r)return Promise.resolve(null);const{minRow:n,minCol:s,maxCol:a,maxRow:c}=r;if(t<n||i<s||t>c||i>a)return Promise.resolve(null);const u=R.getRasterId(this.url,o.sliceId),h=`${e}/${t}/${i}`;let f=R.getBlock(u,o.registryId,h);if(null==f){const r=new AbortController;f=this.fetchRawTile(e,t,i,{...o,signal:r.signal}),R.putBlock(u,o.registryId,h,f,r),f.catch((()=>R.deleteBlock(u,o.registryId,h)))}return o.signal&&l.onAbort(o,(()=>{R.decreaseRefCount(u,o.registryId,h)})),f}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const o=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,n]=e,s=[],l=[];for(let a=0;a<o;a++){const[e,t]=_.uvComponentToVector([r[a],n[a]]);s.push(e),l.push(t)}return[s,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=T.getRasterDatasetAlignmentInfo(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,o={}){const r={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};o.srcResolution&&(r.srcResolution=o.srcResolution,this._updateSourceDataInfo(e,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=r,c=s/t,u=l/i,h=a<n&&c*u>=16,f=a===n&&this._requireTooManySrcTiles(s,l,t,i);if(h||f||(0===s||0===l)){const s=new v({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=T.projectResolution(s,this.rasterInfo.spatialReference,e,r.datumTransformation);const f=!l||o.srcResolution&&l.x+l.y<o.srcResolution.x+o.srcResolution.y;if(h&&o.srcResolution&&f){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-a+3>=e){const t=2**e;l={x:o.srcResolution.x*t,y:o.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,o){const{tileInfo:r}=this.rasterInfo.storageInfo;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=B||e/i>P||t/o>P}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,o=i.spatialReference,{srcResolution:r,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=T.snapPyramid(r,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||T.projectExtent(e,o,n);if(null==c)return;const u=i.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:h,y:f}=i.storageInfo.origin,m=Math.floor((c.xmin-h)/l.x+.1),p=Math.floor((f-c.ymax)/l.y+.1),d=Math.floor((c.xmax-h)/l.x-.1),x=Math.floor((f-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-m+1,g=c.height<.1*l.y?0:x-p+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:m,y:p}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:o,pyramidLevel:r,useTransposedTile:n}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[o]))return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!n){const t=e.pixels.map((e=>e[o])),n={location:i,value:t,pyramidLevel:r},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(n.magdirValue=s.map((e=>e[0]))),n}let a=e.pixels.map((e=>e.slice(o*s,o*s+s))),c=this._computeMagDirValues(a);const{requestSomeSlices:u,identifyOptions:h}=t;let f=I.createSlices(l,h.transposedVariableName);if(u){const e=I.getSliceIds(f,h.multidimensionalDefinition,h.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),f=e.map((e=>f[e]))}const m=e.noDataValues||this.rasterInfo.noDataValue,p={pixels:a,pixelType:e.pixelType};let x;null!=m&&(S.convertNoDataToMask(p,m),x=p.mask);return{location:i,value:null,dataSeries:f.map(((e,t)=>{const i={value:0===x?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new d({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:r}}};e.__decorate([a.property()],W.prototype,"_rasterTileAlighmentInfo",void 0),e.__decorate([a.property({readOnly:!0})],W.prototype,"_isGlobalWrappableSource",null),e.__decorate([a.property({readOnly:!0})],W.prototype,"_hasNoneOrGCSShiftTransform",null),e.__decorate([a.property()],W.prototype,"rasterJobHandler",null),e.__decorate([a.property(p.url)],W.prototype,"url",null),e.__decorate([a.property({type:String,json:{write:!0}})],W.prototype,"datasetName",void 0),e.__decorate([a.property({type:String,json:{write:!0}})],W.prototype,"datasetFormat",void 0),e.__decorate([a.property()],W.prototype,"hasUniqueSourceStorageInfo",void 0),e.__decorate([a.property()],W.prototype,"rasterInfo",void 0),e.__decorate([a.property()],W.prototype,"ioConfig",void 0),e.__decorate([a.property()],W.prototype,"sourceJSON",void 0),W=e.__decorate([f.subclass("esri.layers.support.rasterDatasets.BaseRaster")],W);return W}));
