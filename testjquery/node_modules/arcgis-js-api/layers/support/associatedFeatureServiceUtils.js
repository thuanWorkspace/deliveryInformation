/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../kernel","../../request","../../core/Error","../../core/promiseUtils","./arcgisLayerUrl","../../portal/Portal","../../portal/PortalItem"],(function(e,r,t,n,a,o,i,l){"use strict";async function s(e,r){const t=o.parse(e);if(!t)throw new n("invalid-url","Invalid scene service url");const a={...r,sceneServerUrl:t.url.path,layerId:t.sublayer??void 0};if(a.sceneLayerItem??(a.sceneLayerItem=await c(a)),null==a.sceneLayerItem)return f(a.sceneServerUrl.replace("/SceneServer","/FeatureServer"),a);const i=await d(a);if(!i?.url)throw new n("related-service-not-found","Could not find feature service through portal item relationship");const l=await f(i.url,a);return l.portalItem=i,l}async function c(e){const r=(await u(e)).serviceItemId;if(!r)return null;const t=new l({id:r,apiKey:e.apiKey}),n=await y(e);null!=n&&(t.portal=new i({url:n}));try{return t.load({signal:e.signal})}catch(o){return a.throwIfAbortError(o),null}}async function u(e){if(e.rootDocument)return e.rootDocument;const r={query:{f:"json",token:e.apiKey},responseType:"json",signal:e.signal};try{const n=await t(e.sceneServerUrl,r);e.rootDocument=n.data}catch{e.rootDocument={}}return e.rootDocument}async function y(e){const n=r.id?.findServerInfo(e.sceneServerUrl);if(n?.owningSystemUrl)return n.owningSystemUrl;const o=e.sceneServerUrl.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const r=(await t(o,{query:{f:"json"},responseType:"json",signal:e.signal})).data.owningSystemUrl;if(r)return r}catch(i){a.throwIfAbortError(i)}return null}async function f(e,r){const a=o.parse(e);if(!a)throw new n("invalid-feature-service-url","Invalid feature service url");const i=a.url.path,l=r.layerId;if(null==l)return{serverUrl:i};const s=u(r),c=e=>{const n={query:{f:"json"},responseType:"json",authMode:e,signal:r.signal};return t(i,n)},y=c("anonymous").catch((()=>c("no-prompt"))),[f,d]=await Promise.all([y,s]),p=d?.layers,w=f.data&&f.data.layers;if(!Array.isArray(w))throw new Error("expected layers array");if(Array.isArray(p))for(let t=0;t<Math.min(p.length,w.length);t++){if(p[t].id===l)return{serverUrl:i,layerId:w[t].id}}else if(null!=l&&l<w.length)return{serverUrl:i,layerId:w[l].id};throw new Error("could not find matching associated sublayer")}async function d({sceneLayerItem:e,signal:r}){if(!e)return null;try{const t=(await e.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:r})).find((e=>"Feature Service"===e.type))||null;if(!t)return null;const n=new l({portal:t.portal,id:t.id});return await n.load(),n}catch(t){return a.throwIfAbortError(t),null}}e.findAssociatedFeatureService=s,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
