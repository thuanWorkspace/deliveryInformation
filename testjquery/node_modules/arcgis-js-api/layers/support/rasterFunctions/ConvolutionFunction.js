/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../rasterFunctionConstants","../rasterFormats/pixelRangeUtils","./BaseRasterFunction","./ConvolutionFunctionArguments","./convolutionUtils"],(function(e,t,n,o,s,r,u,c,i,l,p){"use strict";const a=25;let h=class extends i{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{convolutionType:e,rows:t,cols:n,kernel:o}=this.functionArguments;if(!Object.values(u.convolutionKernel).includes(e))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${e}`};if(e!==u.convolutionKernel.none&&t*n!==o.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const s=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(s.pixelType);const r=s.clone();r.pixelType=this.outputPixelType;const c=[u.convolutionKernel.none,u.convolutionKernel.sharpen,u.convolutionKernel.sharpen2,u.convolutionKernel.sharpening3x3,u.convolutionKernel.sharpening5x5];"u8"===this.outputPixelType||c.includes(e)||(r.statistics=null,r.histograms=null),r.colormap=null,r.attributeTable=null,this.rasterInfo=r;return{success:!0,supportsGPU:o.length<=a}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t||this.functionArguments.convolutionType===u.convolutionKernel.none)return t;let{kernel:n,rows:o,cols:s}=this.functionArguments;const r=n.reduce(((e,t)=>e+t));return 0!==r&&1!==r&&(n=n.map((e=>e/r))),p.convolute(t,{kernel:n,rows:o,cols:s,outputPixelType:this.outputPixelType})}_getWebGLParameters(){let{kernel:e}=this.functionArguments;const t=e.reduce(((e,t)=>e+t));0!==t&&1!==t&&(e=e.map((e=>e/t)));const n=new Float32Array(a);return n.set(e),{kernelRows:this.functionArguments.rows,kernelCols:this.functionArguments.cols,kernel:n,clampRange:c.getPixelValueRange(this.outputPixelType)}}};e.__decorate([t.property({json:{write:!0,name:"rasterFunction"}})],h.prototype,"functionName",void 0),e.__decorate([t.property({type:l,json:{write:!0,name:"rasterFunctionArguments"}})],h.prototype,"functionArguments",void 0),e.__decorate([t.property()],h.prototype,"rasterArgumentNames",void 0),h=e.__decorate([r.subclass("esri.layers.support.rasterFunctions.ConvolutionFunction")],h);return h}));
