/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../core/JSONSupport","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/cast","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo"],(function(t,e,s,r,n,o,i,a,p){"use strict";const u=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let c=class extends e.JSONSupport{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let r=s.rasters||s.raster&&[s.raster];for(;r?.length;){e.unshift(...r);const t=[];for(let e=0;e<r.length;e++){const{parameters:s}=r[e],n=s.rasters||s.raster&&[s.raster];n?.length&&t.push(...n)}r=t}for(let i=e.length-1;i>=0;i--)e[i].isNoopProcess&&e.splice(i,1);let n=!1;for(let i=0;i<e.length;i++){const t=e[i];t.id=e.length-i-1;const{rasters:s}=t.parameters;n=n||null!=s&&s.length>1}const o=e.some((({name:t})=>u.has(t.toLowerCase())));return{functions:e,hasBranches:n,hasFocalFunction:o}}bind(t,e=!1,s=-1){this.id=s+1;const r=this._getRasterValues();let n=!0;for(let o=0;o<r.length;o++){const s=r[o];if(null!=s&&this._isRasterFunctionValue(s)){const r=s.bind(t,e,this.id+o);if(!r.success)return this._bindingResult=r,r;n=n&&r.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),this._bindingResult.success&&this._patchRasterInfo(),this._bindingResult.supportsGPU=n&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)}process(t){const e=this._getRasterValues(),s=0===e.length?t.pixelBlocks??t.primaryPixelBlocks:e.map((e=>this._readRasterValue(e,t)));return this._processPixels({...t,pixelBlocks:s})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);let e;if(t.length>1){const e=t.map((t=>t.processInputBandIds()[0]));this.rawInputBandIds=e,this.isInputBandIdsSwizzled=this.rawInputBandIds.some(((t,e)=>t!==e));const s=t.filter((t=>"ExtractBand"===t.functionName));return s.length&&s.forEach(((t,e)=>{t.isInputBandIdsSwizzled=!0,t.swizzledBandSelection=[e,e,e]})),this.rawInputBandIds}const s=t[0];if(s){if(e=s.processInputBandIds(),s.isInputBandIdsSwizzled)return this.rawInputBandIds=e,e}else{e=[];const{bandCount:t}=this.sourceRasterInfos[0];for(let s=0;s<t;s++)e.push(s)}const r=this._getInputBandIds(e);return this.isInputBandIdsSwizzled=r.some(((t,e)=>t!==e)),this.rawInputBandIds=r,this.rawInputBandIds}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map((t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((t=>null!=t))||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}_getOutputPixelType(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_isOutputRoundingNeeded(){const{outputPixelType:t}=this;return(t?.startsWith("u")||t?.startsWith("s"))??!1}_getRasterValues(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.flatMap((t=>this.functionArguments[t]))}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:r}=t;if(0===e.length)return s;const n=e.map((t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&r.includes(t)?s[r.indexOf(t)]:"number"!=typeof t?s[0]:void 0)),o=n.find((t=>t))??s[0];return n.forEach(((t,e)=>{void 0===t&&(n[e]=o)})),n}_getPrimaryRasterId(t){return t?.url}_getPrimaryRasters(t,e=[],s=[]){for(let r=0;r<t.sourceRasters.length;r++){const n=t.sourceRasters[r];if("number"!=typeof n)if("bind"in n)this._getPrimaryRasters(n,e,s);else{const t=n,r=this._getPrimaryRasterId(t);if(null==r)continue;s.includes(r)||(this.mainPrimaryRasterId===r?(e.unshift(t),s.unshift(r)):(e.push(t),s.push(r)))}}}_isRasterFunctionValue(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,e){const{primaryPixelBlocks:s}=e;if(null==t||"$$"===t){const t=s[0];return null==t?null:t.clone()}if("string"==typeof t){const r=e.primaryRasterIds.indexOf(t);return-1===r?null:s[r]}if("number"==typeof t){const e=s[0];if(null==e)return null;const{width:r,height:n,pixelType:o,mask:i}=e,p=i?new Uint8Array(i):null,u=new Float32Array(r*n);u.fill(t);const c=this.sourceRasterInfos[0].bandCount,l=new Array(c).fill(u);return new a({width:r,height:n,pixelType:o,pixels:l,mask:p})}return t.process(e)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!t?.keyProperties)return;const{bandCount:e,keyProperties:s,statistics:r,histograms:n}=t,o=s.BandProperties;o&&o.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),r&&r.length!==e&&(t.statistics=r.length>e?r.slice(0,e):null),n&&n.length!==e&&(t.histograms=n.length>e?n.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:"string"==typeof s.BAND_COUNT?String(e):e})}};t.__decorate([s.property({json:{write:!0}})],c.prototype,"functionName",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"functionArguments",void 0),t.__decorate([s.property()],c.prototype,"rasterArgumentNames",void 0),t.__decorate([s.property({json:{write:!0}}),r.cast((t=>t?.toLowerCase()))],c.prototype,"outputPixelType",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"mainPrimaryRasterId",void 0),t.__decorate([s.property()],c.prototype,"sourceRasters",void 0),t.__decorate([s.property({type:[p],json:{write:!0}})],c.prototype,"sourceRasterInfos",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"rasterInfo",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"readingBufferSize",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"id",void 0),t.__decorate([s.property()],c.prototype,"isNoopProcess",void 0),t.__decorate([s.property()],c.prototype,"supportsGPU",null),t.__decorate([s.property()],c.prototype,"rawInputBandIds",void 0),t.__decorate([s.property()],c.prototype,"isInputBandIdsSwizzled",void 0),t.__decorate([s.property()],c.prototype,"swizzledBandSelection",void 0),t.__decorate([s.property()],c.prototype,"isBranch",void 0),t.__decorate([s.property()],c.prototype,"flatWebGLFunctionChain",null),t.__decorate([s.property()],c.prototype,"_bindingResult",void 0),c=t.__decorate([i.subclass("esri.layers.support.rasterFunctions.BaseRasterFunction")],c);return c}));
