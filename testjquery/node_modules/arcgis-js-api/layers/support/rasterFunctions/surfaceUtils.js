/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../PixelBlock","./pixelUtils"],(function(t,e,i){"use strict";const s=1,l=1/111e3;function a(t){let{altitude:e,azimuth:i}=t;const{hillshadeType:s,pixelSizePower:a=1,pixelSizeFactor:n=1,scalingType:o,isGCS:r,resolution:c}=t,u="multi-directional"===s?2*t.zFactor:t.zFactor,{x:h,y:d}=c;let f=u/(8*h),x=u/(8*d);if(r&&u>.001&&(f/=l,x/=l),"adjusted"===o)if(r){const t=h*l,e=d*l;f=(u+t**a*n)/(8*t),x=(u+e**a*n)/(8*e)}else f=(u+h**a*n)/(8*h),x=(u+d**a*n)/(8*d);let p=(90-e)*Math.PI/180,y=Math.cos(p),w=(360-i+90)*Math.PI/180,M=Math.sin(p)*Math.cos(w),k=Math.sin(p)*Math.sin(w);const m=[315,270,225,360,180,0],g=[60,60,60,60,60,90],A=new Float32Array([3,5,3,2,1,4]),P=A.reduce(((t,e)=>t+e)),z=A.map((t=>t/P)),F="multi-directional"===s?m.length:1,v=new Float32Array(6),C=new Float32Array(6),Z=new Float32Array(6);if("multi-directional"===s)for(let l=0;l<F;l++)e=g[l],i=m[l],p=(90-e)*Math.PI/180,y=Math.cos(p),w=(360-i+90)*Math.PI/180,M=Math.sin(p)*Math.cos(w),k=Math.sin(p)*Math.sin(w),v[l]=y,C[l]=M,Z[l]=k;else v.fill(y),C.fill(M),Z.fill(k);return{resolution:c,factor:[f,x],sinZcosA:M,sinZsinA:k,cosZ:y,sinZcosAs:C,sinZsinAs:Z,cosZs:v,weights:z,hillshadeType:["traditional","multi-directional"].indexOf(s)}}function n(t,e){const{width:i,height:l}=t,a=i*l,n=new Uint8Array(a),o=null!=t.mask;let r;if(o){r=new Uint8Array(t.mask);for(let t=0;t<r.length;t++)r[t]&&(n[t]=1,r[t]=1)}const c=t.pixels[0],u=new Float32Array(a),h=new Float32Array(a);let d,f=0;if(e){const{resolution:t}=e,i=t?(t.x+t.y)/2:1;f=200*e.zFactor/(i*i),d=new Float32Array(a)}const x=e?.curvatureType;let p,y,w,M,k,m,g,A;for(let P=s;P<l-s;P++){const t=P*i;for(let e=s;e<i-s;e++){const s=t+e;if(!r||0!==r[s]){if(r){if(r[s-i-1]+r[s-i]+r[s-i+1]+r[s-1]+r[s+1]+r[s+i-1]+r[s+i]+r[s+i+1]<7){n[s]=0;continue}p=r[s-i-1]?c[s-i-1]:c[s],y=r[s-i]?c[s-i]:c[s],w=r[s-i+1]?c[s-i+1]:c[s],M=r[s-1]?c[s-1]:c[s],k=r[s+1]?c[s+1]:c[s],m=r[s+i-1]?c[s+i-1]:c[s],g=r[s+i]?c[s+i]:c[s],A=r[s+i+1]?c[s+i+1]:c[s]}else p=c[s-i-1],y=c[s-i],w=c[s-i+1],M=c[s-1],k=c[s+1],m=c[s+i-1],g=c[s+i],A=c[s+i+1];if(u[s]=w+k+k+A-(p+M+M+m),h[s]=m+g+g+A-(p+y+y+w),null!=d){const t=c[s],e=.5*(M+k)-t,i=.5*(y+g)-t;if("standard"===x)d[s]=-f*(e+i);else{const t=(-p+w+m-A)/4,l=(-M+k)/2,a=(y-g)/2,n=l*l,o=a*a,r=n+o;r&&(d[s]="profile"===x?f*(e*n+i*o+t*l*a)/r:-f*(e*o+i*n-t*l*a)/r)}}}}}return{outMask:o?n:null,dzxs:u,dzys:h,curvatures:d}}function o(t,e,i){for(let s=0;s<i;s++)t[s*e]=t[s*e+1],t[(s+1)*e-1]=t[(s+1)*e-2];for(let s=1;s<e-1;s++)t[s]=t[s+e],t[s+(i-1)*e]=t[s+(i-2)*e]}function r(t,l){if(!i.isValidPixelBlock(t))return t;const{factor:r,sinZcosA:c,sinZsinA:u,cosZ:h,sinZcosAs:d,sinZsinAs:f,cosZs:x,weights:p}=a(l),[y,w]=r,M="traditional"===l.hillshadeType,{width:k,height:m}=t,g=new Uint8Array(k*m),{dzxs:A,dzys:P,outMask:z}=n(t);for(let e=s;e<m-s;e++){const t=e*k;for(let e=s;e<k-s;e++){const i=t+e;if(!z||z[i]){const t=A[i]*y,e=P[i]*w,s=Math.sqrt(1+t*t+e*e);let l=0;if(M){let i=255*(h+u*e-c*t)/s;i<0&&(i=0),l=i}else{const i=f.length;for(let a=0;a<i;a++){let i=255*(x[a]+f[a]*e-d[a]*t)/s;i<0&&(i=0),l+=i*p[a]}}g[i]=255&l}}}o(g,k,m);return new e({width:k,height:m,pixels:[g],mask:z,pixelType:"u8",validPixelCount:t.validPixelCount,statistics:[{minValue:0,maxValue:255}]})}function c(t,e,s,l){if(!i.isValidPixelBlock(t)||!i.isValidPixelBlock(e))return;const{min:a,max:n}=l,o=t.pixels[0],{pixels:r,mask:c}=e,u=r[0],h=255.00001/(n-a),d=new Uint8ClampedArray(u.length),f=new Uint8ClampedArray(u.length),x=new Uint8ClampedArray(u.length),p=s.length-1;for(let i=0;i<u.length;i++){if(c&&0===c[i])continue;const t=Math.floor((u[i]-a)*h),[e,l]=s[t<0?0:t>p?p:t],n=o[i],r=n*l,y=r*(1-Math.abs(e%2-1)),w=n-r;switch(Math.floor(e)){case 0:d[i]=r+w,f[i]=y+w,x[i]=w;break;case 1:d[i]=y+w,f[i]=r+w,x[i]=w;break;case 2:d[i]=w,f[i]=r+w,x[i]=y+w;break;case 3:d[i]=w,f[i]=y+w,x[i]=r+w;break;case 4:d[i]=y+w,f[i]=w,x[i]=r+w;break;case 5:case 6:d[i]=r+w,f[i]=w,x[i]=y+w}}t.pixels=[d,f,x],t.updateStatistics()}function u(t,a){if(!i.isValidPixelBlock(t))return t;const r=a.zFactor,c=a.pixelSizePower??1,u=a.pixelSizeFactor??1,h=a.slopeType,d=a.isGCS,{x:f,y:x}=a.resolution;let p=r/(8*f),y=r/(8*x);d&&Math.abs(r-1)<1e-4&&(p/=l,y/=l),"adjusted"===h&&(p=(r+f**c*u)/(8*f),y=(r+x**c*u)/(8*x));const{dzxs:w,dzys:M,outMask:k}=n(t),{width:m,height:g}=t,A=new Float32Array(m*g);for(let e=s;e<g-s;e++){const t=e*m;for(let e=s;e<m-s;e++){const i=t+e;if(!k||k[i]){const s=w[i]*p,l=M[i]*y,a=Math.sqrt(s*s+l*l);A[t+e]="percent-rise"===h?100*a:57.2957795*Math.atan(a)}}}o(A,m,g);const P=new e({width:m,height:g,pixels:[A],mask:k,pixelType:"f32",validPixelCount:t.validPixelCount});return P.updateStatistics(),P}function h(t,l={}){if(!i.isValidPixelBlock(t))return t;const{resolution:a}=l,r=a?1/a.x:1,c=a?1/a.y:1,{dzxs:u,dzys:h,outMask:d}=n(t),{width:f,height:x}=t,p=new Float32Array(f*x);for(let e=s;e<x-s;e++){const t=e*f;for(let e=s;e<f-s;e++){const i=t+e;if(!d||d[i]){const s=u[i]*r,l=h[i]*c;let a=-1;0===s&&0===l||(a=90-57.29578*Math.atan2(l,-s),a<0&&(a+=360),360===a?a=0:a>360&&(a%=360)),p[t+e]=a}}}o(p,f,x);return new e({width:f,height:x,pixels:[p],mask:d,pixelType:"f32",validPixelCount:t.validPixelCount,statistics:[{minValue:-1,maxValue:360}]})}function d(t,s){if(!i.isValidPixelBlock(t))return t;const{curvatures:l,outMask:a}=n(t,s),{width:r,height:c}=t;o(l,r,c);const u=new e({width:r,height:c,pixels:[l],mask:a,pixelType:"f32",validPixelCount:t.validPixelCount});return u.updateStatistics(),u}t.aspect=h,t.calculateHillshadeParams=a,t.curvature=d,t.gcsFactor=l,t.hillshade=r,t.slope=u,t.tintHillshade=c,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
