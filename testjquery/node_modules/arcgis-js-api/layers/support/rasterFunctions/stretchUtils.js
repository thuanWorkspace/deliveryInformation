/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../PixelBlock","../rasterFormats/pixelRangeUtils","../../../renderers/support/stretchRendererUtils"],(function(t,e,n,s,i){"use strict";const a=1,o=[.299,.587,.114];function r(t,e=256){e=Math.min(e,256);const{size:n,counts:s}=t,i=new Uint8Array(n),a=s.reduce(((t,n)=>t+n/e),0);let o=0,r=0,l=0,u=a;for(let f=0;f<n;f++)if(l+=s[f],!(f<n-1&&l+s[f+1]<u)){for(;o<e-1&&u<l;)o++,u+=a;for(let t=r;t<=f;t++)i[t]=o;r=f+1}for(let f=r;f<n;f++)i[f]=e-1;return i}function l(t){const{minCutOff:e,maxCutOff:n,gamma:s,pixelType:i,rounding:a}=t,o=t.outMin||0,r=t.outMax||255;if(!["u8","u16","s8","s16"].includes(i))return null;const l=e.length;let f,c,m=0;"s8"===i?m=-127:"s16"===i&&(m=-32767);let h=256;["u16","s16"].includes(i)&&(h=65536);const g=[],d=[],p=r-o;for(f=0;f<l;f++)d[f]=n[f]-e[f],g[f]=0===d[f]?0:p/d[f];let x;const y=[];let b,v,C;if(s&&s.length>=l){const t=M(l,s);for(f=0;f<l;f++){for(C=[],c=0;c<h;c++)if(0!==d[f])if(b=c+m,x=(b-e[f])/d[f],v=1,s[f]>1&&(v-=(1/p)**(x*t[f])),b<n[f]&&b>e[f]){const t=v*p*x**(1/s[f])+o;C[c]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}else b>=n[f]?C[c]=r:C[c]=o;else C[c]=o;y[f]=C}}else for(f=0;f<l;f++){for(C=[],c=0;c<h;c++)if(b=c+m,b<=e[f])C[c]=o;else if(b>=n[f])C[c]=r;else{const t=(b-e[f])*g[f]+o;C[c]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}y[f]=C}if(null!=t.contrastOffset){const e=u(t.contrastOffset,t.brightnessOffset);for(f=0;f<l;f++)for(C=y[f],c=0;c<h;c++)C[c]=e[C[c]]}return{lut:y,offset:m}}function u(t,e){const n=Math.min(Math.max(t,-100),100),s=Math.min(Math.max(e??0,-100),100),i=255,a=128;let o=0,r=0;const l=new Uint8Array(256);for(o=0;o<256;o++)n>0&&n<100?r=(200*o-100*i+2*i*s)/(2*(100-n))+a:n<=0&&n>-100?r=(200*o-100*i+2*i*s)*(100+n)/2e4+a:100===n?(r=200*o-100*i+(i+1)*(100-n)+2*i*s,r=r>0?i:0):-100===n&&(r=a),l[o]=r>i?i:r<0?0:r;return l}function f(t,e,n){const s=[];for(let i=0;i<e.length;i++){let a=0,r=0,l=0;"min"in e[i]?({min:a,max:r,avg:l}=e[i]):[a,r,l]=e[i];let u=l??0;"u8"!==t&&(u=255*(u-a)/(r-a)),n&&(u*=o[i]),s.push(c(u))}return s}function c(t){if(t<=0||t>=255)return a;let e=0;150!==t&&(e=t<=150?45*Math.cos(.01047*t):17*Math.sin(.021*t));const n=255,s=t+e,i=Math.log(t/n),o=Math.log(s/n);if(0===o)return a;const r=i/o;return isNaN(r)?a:Math.min(9.9,Math.max(.01,r))}function m(t,e,n,s){let i=1/0,a=-1/0,o=0,r=0,l=0,u=0;const f=t.length,c=new Map,m=[];for(let k=0;k<f;k++){const n=t[k];if(!e||e[k]){m.push(n);const t=(c.get(n)??0)+1;c.set(n,t),t>u&&(u=t,l=n),i=n<i?n:i,a=n>a?n:a,o+=n,r++}}if(0===r)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const h=o/r;let g=0;for(let k=0;k<f;k++)e&&!e[k]||(g+=(t[k]-h)**2);const d=e?e.filter((t=>t)).length:f,p=d<=1?0:Math.sqrt(g/(d-1));m.sort(((t,e)=>t-e));const x=r>>>1,M={min:i,max:a,avg:h,stddev:p,mode:l,median:r%2?m[Math.floor(x)]:(m[x-1]+m[x])/2};if(!s)return{statistics:M,histogram:null};if(["u8","s8","u4","u2","u1"].includes(n)){const n=a-i+1,s=new Uint32Array(n);for(let a=0;a<f;a++)e&&!e[a]||s[t[a]-i]++;return{statistics:M,histogram:{min:i-.5,max:a+.5,size:n,counts:s}}}const y=256,b=new Uint32Array(y),v=(a-i)/y;if(0===v)return{statistics:M,histogram:{min:i,max:a,size:1,counts:new Uint32Array(1).fill(r)}};const C=new Uint32Array(y+1);for(let k=0;k<f;k++)e&&!e[k]||C[Math.floor((t[k]-i)/v)]++;for(let k=0;k<y-1;k++)b[k]=C[k];return b[y-1]=C[y-1]+C[y],{statistics:M,histogram:{min:i,max:a,size:y,counts:b}}}function h(t){const{pixels:e,mask:n,pixelType:s,bandMasks:i}=t,a=e.map(((t,e)=>m(t,i?.[e]??n,s,!0)));return{statistics:a.map((({statistics:t})=>t)),histograms:a.map((({histogram:t})=>t))}}function g(t){if(!t?.pixels?.length)return null;const{pixels:e,mask:n,bandMasks:s,pixelType:i}=t,a=t.width*t.height,o=e.length;let r,l,u,f,c;const m=[],h=[];let g,d,p,x,M,y,b,v,C,k;const w=256;for(f=0;f<o;f++){g=new Uint32Array(w),p=e[f];const o=s?.[f]??n;if("u8"===i)if(r=-.5,l=255.5,o)for(c=0;c<a;c++)o[c]&&g[p[c]]++;else for(c=0;c<a;c++)g[p[c]]++;else{let e=!1;t.statistics||(t.updateStatistics(),e=!0);const n=t.statistics;if(r=n[f].minValue,l=n[f].maxValue,u=(l-r)/w,0===u){!n||t.validPixelCount||e||t.updateStatistics();const s=(t.validPixelCount||t.width*t.height)/w;for(let t=0;t<w;t++)g[t]=Math.round(s*(t+1))-Math.round(s*t)}else{for(d=new Uint32Array(w+1),c=0;c<a;c++)o&&!o[c]||d[Math.floor((p[c]-r)/u)]++;for(c=0;c<w-1;c++)g[c]=d[c];g[w-1]=d[w-1]+d[w]}}for(m.push({min:r,max:l,size:w,counts:g}),x=0,M=0,v=0,c=0;c<w;c++)x+=g[c],M+=c*g[c];for(C=M/x,c=0;c<w;c++)v+=g[c]*(c-C)**2;k=Math.sqrt(v/(x-1)),u=(l-r)/w,y=(C+.5)*u+r,b=k*u,h.push({min:r,max:l,avg:y,stddev:b})}return{statistics:h,histograms:m}}function d(t){const e=[];for(let n=0;n<t.length;n++){const{min:s,max:i,size:a,counts:o}=t[n];let r=0,l=0;for(let t=0;t<a;t++)r+=o[t],l+=t*o[t];const u=l/r;let f=0;for(let t=0;t<a;t++)f+=o[t]*(t-u)**2;const c=(i-s)/a,m=(u+.5)*c+s,h=Math.sqrt(f/(r-1))*c;e.push({min:s,max:i,avg:m,stddev:h})}return e}function p(t,n){const{pixelBlock:a,bandIds:o,returnHistogramLut:l,rasterInfo:u}=n;let f=null,c=null,m=t.stretchType;if("number"==typeof m&&(m=i.stretchTypeFunctionEnum[m]),t.dra)if("minMax"===m&&a?.statistics)f=a.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=g(a);f=null!=t?t.statistics:null,c=null!=t?t.histograms:null}else f=t.statistics?.length?t.statistics:u.statistics,c="histograms"in t?t.histograms:void 0,c||(c=u.histograms);"percentClip"!==m&&"histogramEqualization"!==m||c?.length||(m="minMax");const h=f?.length||c?.length||u.bandCount,d=[],p=[];let M,y,b,v,C,k,w,z,O;f&&!Array.isArray(f[0])&&(f=f.map((t=>[t.min,t.max,t.avg,t.stddev])));const[S,U]=s.getPixelValueRange(u.pixelType);if(!f?.length){for(f=[],z=0;z<h;z++)f.push([S,U,1,1]);"standardDeviation"===m&&(m="minMax")}switch(m){case"none":for(z=0;z<h;z++)d[z]=S,p[z]=U;break;case"minMax":for(z=0;z<h;z++){const t=f[z];d[z]=t[0],p[z]=t[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:e=2}=t;for(z=0;z<h;z++){const t=f[z];d[z]=t[2]-e*t[3],p[z]=t[2]+e*t[3],d[z]<t[0]&&(d[z]=t[0]),p[z]>t[1]&&(p[z]=t[1])}}break;case"histogramEqualization":for(e.assertIsSome(c),z=0;z<h;z++)d[z]=c[z].min,p[z]=c[z].max;break;case"percentClip":for(e.assertIsSome(c),z=0;z<c.length;z++){for(M=c[z],C=new Uint32Array(M.size),v=[...M.counts],v.length>=20&&(v[0]=v[1]=v[2]=v[v.length-1]=v[v.length-2]=0),b=0,y=(M.max-M.min)/M.size,w=-.5===M.min&&1===y?.5:0,O=0;O<M.size;O++)b+=v[O],C[O]=b;for(k=(t.minPercent||0)*b/100,d[z]=M.min+w,O=0;O<M.size;O++)if(C[O]>k){d[z]=M.min+y*(O+w);break}for(k=(1-(t.maxPercent||0)/100)*b,p[z]=M.max+w,O=M.size-2;O>=0;O--)if(C[O]<k){p[z]=M.min+y*(O+2-w);break}if(p[z]<d[z]){const t=d[z];d[z]=p[z],p[z]=t}}break;default:for(z=0;z<h;z++){const t=f[z];d[z]=t[0],p[z]=t[1]}}let A,T,P;"histogramEqualization"===m?(e.assertIsSome(c),T=c[0].size||256,A=0,l&&(P=c.map((t=>r(t))))):(T=t.max||255,A=t.min||0);return x({minCutOff:d,maxCutOff:p,outMax:T,outMin:A,histogramLut:P},o)}function x(t,e){if(null==e||0===e.length)return t;const n=Math.max.apply(null,e),{minCutOff:s,maxCutOff:i,outMin:a,outMax:o,histogramLut:r}=t;return s.length===e.length||s.length<=n?t:{minCutOff:e.map((t=>s[t])),maxCutOff:e.map((t=>i[t])),histogramLut:r?e.map((t=>r[t])):null,outMin:a,outMax:o}}function M(t,e){const n=new Float32Array(t);for(let s=0;s<t;s++)e[s]>1?e[s]>2?n[s]=6.5+(e[s]-2)**2.5:n[s]=6.5+100*(2-e[s])**4:n[s]=1;return n}function y(t,e){if(!t?.pixels?.length)return t;const{mask:s,bandMasks:i,width:a,height:o,pixels:r}=t,{minCutOff:l,maxCutOff:u,gamma:f}=e,c=e.outMin||0,m=e.outMax||255,h=a*o,g=e.outputPixelType||"u8",d=t.pixels.map((()=>n.createEmptyBand(g,h))),p=d.length,x=m-c,y=[],b=[];for(let n=0;n<p;n++)b[n]=u[n]-l[n],y[n]=0===b[n]?0:x/b[n];const v=g.startsWith("u")||g.startsWith("s"),C=f&&f.length>=p,k=!!e.isRenderer;if(C){const t=M(p,f);for(let e=0;e<p;e++){const n=i?.[e]??s;for(let s=0;s<h;s++)if(null==n||n[s]){if(0===b[e]){d[e][s]=c;continue}const n=r[e][s],i=(n-l[e])/b[e];let a=1;if(f[e]>1&&(a-=(1/x)**(i*t[e])),n<u[e]&&n>l[e]){const t=a*x*i**(1/f[e])+c;d[e][s]=k?Math.floor(t):v?Math.round(t):t}else n>=u[e]?d[e][s]=m:d[e][s]=c}}}else for(let n=0;n<p;n++){const t=i?.[n]??s;for(let e=0;e<h;e++)if(null==t||t[e]){const t=r[n][e];if(t<u[n]&&t>l[n]){const s=(t-l[n])*y[n]+c;d[n][e]=k?Math.floor(s):v?Math.round(s):s}else t>=u[n]?d[n][e]=m:d[n][e]=c}}const w=new n({width:a,height:o,mask:s,bandMasks:i,pixels:d,pixelType:g});return w.updateStatistics(),w}t.computeGammaCorrection=M,t.computeGammaValues=f,t.computeStatisticsHistograms=h,t.createContrastBrightnessLUT=u,t.createHistogramEqualizationLUT=r,t.createStretchLUT=l,t.estimateStatisticsFromHistograms=d,t.estimateStatisticsHistograms=g,t.getStretchCutoff=p,t.stretch=y,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
