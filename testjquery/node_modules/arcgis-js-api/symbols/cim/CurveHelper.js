/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../geometry/GeometryCursor","./enums"],(function(t,e,n){"use strict";const s=.03;class r{constructor(t=0,e=!1){}isEmpty(t){if(!t.nextPoint())return!0;let e,n,s,r;for(e=t.x,n=t.y;t.nextPoint();e=n,n=r)if(s=t.x,r=t.y,s!==e||r!==n)return t.seekPathStart(),!1;return t.seekPathStart(),!0}normalize(t){const e=Math.sqrt(t[0]*t[0]+t[1]*t[1]);0!==e&&(t[0]/=e,t[1]/=e)}getLength(t,e,n,s){const r=n-t,o=s-e;return Math.sqrt(r*r+o*o)}getSegLength(t){const[[e,n],[s,r]]=t;return this.getLength(e,n,s,r)}getCoord2D(t,e,n,s,r){return[t+(n-t)*r,e+(s-e)*r]}getSegCoord2D(t,e){const[[n,s],[r,o]]=t;return this.getCoord2D(n,s,r,o,e)}getAngle(t,e,n,s,r){const o=n-t,i=s-e;return Math.atan2(i,o)}getAngleCS(t,e,n,s,r){const o=n-t,i=s-e,u=Math.sqrt(o*o+i*i);return u>0?[o/u,i/u]:[1,0]}getSegAngleCS(t,e){const[[n,s],[r,o]]=t;return this.getAngleCS(n,s,r,o,e)}cut(t,e,n,s,r,o){return[r<=0?[t,e]:this.getCoord2D(t,e,n,s,r),o>=1?[n,s]:this.getCoord2D(t,e,n,s,o)]}getSubCurve(t,n,s){const r=e.GeometryCursor.createEmptyOptimizedCIM("esriGeometryPolyline");return this.appendSubCurve(r,t,n,s)?r:null}appendSubCurve(t,e,n,s){t.startPath(),e.seekPathStart();let r=0,o=!0;if(!e.nextPoint())return!1;let i=e.x,u=e.y;for(;e.nextPoint();){const h=this.getLength(i,u,e.x,e.y);if(0!==h){if(o){if(r+h>n){const l=(n-r)/h;let c=1,f=!1;r+h>=s&&(c=(s-r)/h,f=!0);const a=this.cut(i,u,e.x,e.y,l,c);if(a&&t.pushPoints(a),f)break;o=!1}}else{if(r+h>s){const n=this.cut(i,u,e.x,e.y,0,(s-r)/h);n&&t.pushPoint(n[1]);break}t.pushXY(e.x,e.y)}r+=h,i=e.x,u=e.y}else i=e.x,u=e.y}return!0}getCIMPointAlong(t,e){if(!t.nextPoint())return null;let n,s,r,o,i=0;for(n=t.x,s=t.y;t.nextPoint();n=r,s=o){r=t.x,o=t.y;const u=this.getLength(n,s,r,o);if(0!==u){if(i+u>e){const t=(e-i)/u;return this.getCoord2D(n,s,r,o,t)}i+=u}}return null}offset(t,e,s,r,o){if(!t||t.length<2)return null;let i=0,u=t[i++],h=i;for(;i<t.length;){const e=t[i];e[0]===u[0]&&e[1]===u[1]||(i!==h&&(t[h]=t[i]),u=t[h++]),i++}const l=t[0][0]===t[h-1][0]&&t[0][1]===t[h-1][1];if(l&&--h,h<(l?3:2))return null;const c=[];u=l?t[h-1]:null;let f=t[0];for(let a=0;a<h;a++){const o=a===h-1?l?t[0]:null:t[a+1];if(u)if(o){const t=[o[0]-f[0],o[1]-f[1]];this.normalize(t);const i=[f[0]-u[0],f[1]-u[1]];this.normalize(i);const h=i[0]*t[1]-i[1]*t[0],l=i[0]*t[0]+i[1]*t[1];if(0===h&&1===l){f=o;continue}if(h>=0==e<=0){if(l<1){const n=[t[0]-i[0],t[1]-i[1]];this.normalize(n);const s=Math.sqrt((1+l)/2);if(s>1/r){const t=-Math.abs(e)/s;c.push([f[0]-n[0]*t,f[1]-n[1]*t])}}}else switch(s){case n.GeometricEffectOffsetMethod.Mitered:{const n=Math.sqrt((1+l)/2);if(n>0&&1/n<r){const s=[t[0]-i[0],t[1]-i[1]];this.normalize(s);const r=Math.abs(e)/n;c.push([f[0]-s[0]*r,f[1]-s[1]*r]);break}}case n.GeometricEffectOffsetMethod.Bevelled:c.push([f[0]+i[1]*e,f[1]-i[0]*e]),c.push([f[0]+t[1]*e,f[1]-t[0]*e]);break;case n.GeometricEffectOffsetMethod.Rounded:if(l<1){c.push([f[0]+i[1]*e,f[1]-i[0]*e]);const n=Math.floor(2.5*(1-l));if(n>0){const s=1/n;let r=s;for(let o=1;o<n;o++,r+=s){const n=[i[1]*(1-r)+t[1]*r,-i[0]*(1-r)-t[0]*r];this.normalize(n),c.push([f[0]+n[0]*e,f[1]+n[1]*e])}}c.push([f[0]+t[1]*e,f[1]-t[0]*e])}break;case n.GeometricEffectOffsetMethod.Square:default:if(h<0)c.push([f[0]+(i[1]+i[0])*e,f[1]+(i[1]-i[0])*e]),c.push([f[0]+(t[1]-t[0])*e,f[1]-(t[0]+t[1])*e]);else{const n=Math.sqrt((1+Math.abs(l))/2),s=[t[0]-i[0],t[1]-i[1]];this.normalize(s);const r=e/n;c.push([f[0]-s[0]*r,f[1]-s[1]*r])}}}else{const t=[f[0]-u[0],f[1]-u[1]];this.normalize(t),c.push([f[0]+t[1]*e,f[1]-t[0]*e])}else{const t=[o[0]-f[0],o[1]-f[1]];this.normalize(t),c.push([f[0]+t[1]*e,f[1]-t[0]*e])}u=f,f=o}return c.length<(l?3:2)?null:(l&&c.push([c[0][0],c[0][1]]),c)}}t.CurveHelper=r,t.pixelTolerance=s,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
