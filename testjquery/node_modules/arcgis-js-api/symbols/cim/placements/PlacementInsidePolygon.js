/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/RandomLCG","../CIMPlacements","../enums"],(function(t,s,i,e){"use strict";const n=512,h=10,_=24,r=1e-6;class a{static local(){return null===a.instance&&(a.instance=new a),a.instance}execute(t,s,i,e,n){return new o(t,s,i,e,n)}}a.instance=null;class o{constructor(t,h,_,r,a){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(h.stepX??16)*_,this._stepY=Math.abs(h.stepY??16)*_,this._stepX=Math.round(128*this._stepX)/128,this._stepY=Math.round(128*this._stepY)/128,0!==this._stepX&&0!==this._stepY){if(this._gridType=h.gridType??e.PlacementGridType.Fixed,this._gridType===e.PlacementGridType.Random){const t=h.seed??13,i=1;this._randomLCG=new s(t*i),this._randomness=(h.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues()}else{if(this._randomness=0,this._gridAngle=h.gridAngle??0,this._shiftOddRows=h.shiftOddRows??!1,this._offsetX=(h.offsetX??0)*_,this._offsetY=(h.offsetY??0)*_,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=r){const[t,s,i,e]=r.split("/"),h=parseFloat(t),_=parseFloat(s),a=parseFloat(i),o=parseFloat(e);this._graphicOriginX=-(o*2**h+a)*n,this._graphicOriginY=_*n,this._testInsidePolygon=!0}this._internalPlacement=new i.Placement,this._calculateMinMax(t),this._geometryCursor=t}}next(){return this._geometryCursor?this._nextInside():null}_buildRandomValues(){if(!o._randValues){o._randValues=[];for(let t=0;t<_;t++)for(let s=0;s<_;s++)o._randValues.push(this._randomLCG.getFloat()),o._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(t){let s,i,e,h,_,r,a,o,l,c,f,u,p,M;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,a=o=p=f=Number.MAX_VALUE,l=c=M=u=-Number.MAX_VALUE;const g=1!==this._cosAngle;for(t.reset();t.nextPath();)for(;t.nextPoint();)r=t.x,_=t.y,s=r-this._graphicOriginX-this._offsetX,i=_-this._graphicOriginY-this._offsetY,g?(e=this._cosAngle*s-this._sinAngle*i,h=this._sinAngle*s+this._cosAngle*i):(e=s,h=i),a=Math.min(a,e),l=Math.max(l,e),o=Math.min(o,h),c=Math.max(c,h),f=Math.min(f,_),u=Math.max(u,_),p=Math.min(p,r),M=Math.max(M,r);f=f!==Number.MAX_VALUE?f:-n-this._stepY,u=u!==-Number.MAX_VALUE?u:this._stepY,p=p!==Number.MAX_VALUE?p:-this._stepX,M=M!==-Number.MAX_VALUE?M:n+this._stepX;const d=u-f,X=M-p;if(this._verticalSubdivision=d>=X,this._polygonMin=this._verticalSubdivision?f:p,this._testInsidePolygon){let t=0-this._graphicOriginX-this._offsetX-this._stepX,s=n-this._graphicOriginX-this._offsetX+this._stepX,i=-n-this._graphicOriginY-this._offsetY-this._stepY,e=0-this._graphicOriginY-this._offsetY+this._stepY;if(g){const n=[[t,i],[t,e],[s,i],[s,e]];t=i=Number.MAX_VALUE,s=e=-Number.MAX_VALUE;for(const h of n){const n=this._cosAngle*h[0]-this._sinAngle*h[1],_=this._sinAngle*h[0]+this._cosAngle*h[1];t=Math.min(t,n),s=Math.max(s,n),i=Math.min(i,_),e=Math.max(e,_)}}a=a!==Number.MAX_VALUE?Math.max(a,t):t,o=o!==Number.MAX_VALUE?Math.max(o,i):i,l=l!==-Number.MAX_VALUE?Math.min(l,s):s,c=c!==-Number.MAX_VALUE?Math.min(c,e):e}this._xMin=Math.round(a/this._stepX),this._xMax=Math.round(l/this._stepX),this._yMin=Math.round(o/this._stepY),this._yMax=Math.round(c/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._buildAccelerationMap(t,p,M,f,u)}_buildAccelerationMap(t,s,i,e,_){t.reset();const r=new Map,a=this._verticalSubdivision,o=a?_-e:i-s;let l=Math.ceil(o/h);if(l<=1)return;const f=Math.floor(o/l);let u,p,M,g,d,X,m,x,A,Y,y;for(l++,this._delta=f,a?(A=-n-this._stepY,Y=this._stepY,y=e):(A=-this._stepX,Y=n+this._stepX,y=s);t.nextPath();)if(!(t.pathSize<2)&&t.nextPoint())for(u=t.x,p=t.y;t.nextPoint();u=M,p=g){if(M=t.x,g=t.y,a){if(p===g||p<A&&g<A||p>Y&&g>Y)continue;d=Math.min(p,g),X=Math.max(p,g)}else{if(u===M||u<A&&M<A||u>Y&&M>Y)continue;d=Math.min(u,M),X=Math.max(u,M)}for(;d<X;)m=Math.floor((d-y)/f),c(m,u,p,M,g,r),d+=f;x=Math.floor((X-y)/f),x>m&&c(x,u,p,M,g,r)}this._accelerationMap=r}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let t=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(t+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,n;if(this._currentX++,this._gridType===e.PlacementGridType.Random){const e=(this._currentX%_+_)%_,h=(this._currentY%_+_)%_;i=this._graphicOriginX+t+this._stepX*this._randomness*(.5-o._randValues[h*_+e])*2/3,n=this._graphicOriginY+s+this._stepY*this._randomness*(.5-o._randValues[h*_+e+1])*2/3}else i=this._graphicOriginX+this._cosAngle*t+this._sinAngle*s,n=this._graphicOriginY-this._sinAngle*t+this._cosAngle*s;if(!this._testInsidePolygon||this._isInsidePolygon(i,n,this._geometryCursor))return this._internalPlacement.setTranslate(i,n),this._internalPlacement}}_isInsidePolygon(t,s,i){if(null==this._accelerationMap)return l(t,s,i);t+=r,s+=r;const e=this._verticalSubdivision,n=e?s:t,h=Math.floor((n-this._polygonMin)/this._delta),_=this._accelerationMap.get(h);if(!_)return!1;let a,o,c,f=0;for(const r of _){if(a=r[0],o=r[1],e){if(a[1]>s==o[1]>s)continue;c=(o[0]-a[0])*(s-a[1])-(o[1]-a[1])*(t-a[0])}else{if(a[0]>t==o[0]>t)continue;c=(o[1]-a[1])*(t-a[0])-(o[0]-a[0])*(s-a[1])}c>0?f++:f--}return 0!==f}}function l(t,s,i){let e,n,h,_,a=0;for(t+=r,s+=r,i.reset();i.nextPath();)if(i.nextPoint())for(e=i.x,n=i.y;i.nextPoint();e=h,n=_){if(h=i.x,_=i.y,n>s==_>s)continue;(h-e)*(s-n)-(_-n)*(t-e)>0?a++:a--}return 0!==a}function c(t,s,i,e,n,h){let _=h.get(t);_||(_=[],h.set(t,_)),_.push([[s,i],[e,n]])}t.PlacementInsidePolygon=a,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
