/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../geometry/GeometryCursor","../../../geometry/geometryCursorCollectUtils","../CIMCursor","../enums"],(function(t,s,e,i,h){"use strict";class r{static local(){return null===r.instance&&(r.instance=new r),r.instance}execute(t,s,e,i,h){return new c(t,s,e)}}r.instance=null;class c{constructor(t,s,e){this._defaultPointSize=20,this._inputGeometries=t,this._geomUnitsPerPoint=e,this._rule=s.rule??h.GeometricEffectControlMeasureLineRule.FullGeometry,this._defaultSize=this._defaultPointSize*e}next(){let t;for(;t=this._inputGeometries.next();){const i=this._processGeom(e.collectMultipath(t));if(i&&i.length)return s.GeometryCursor.fromJSONCIM({paths:i})}return null}_clone(t){return[t[0],t[1]]}_mid(t,s){return[(t[0]+s[0])/2,(t[1]+s[1])/2]}_mix(t,s,e,i){return[t[0]*s+e[0]*i,t[1]*s+e[1]*i]}_add(t,s){return[t[0]+s[0],t[1]+s[1]]}_add2(t,s,e){return[t[0]+s,t[1]+e]}_sub(t,s){return[t[0]-s[0],t[1]-s[1]]}_dist(t,s){return Math.sqrt((t[0]-s[0])*(t[0]-s[0])+(t[1]-s[1])*(t[1]-s[1]))}_norm(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}_normalize(t,s=1){const e=s/this._norm(t);t[0]*=e,t[1]*=e}_leftPerpendicular(t){const s=-t[1],e=t[0];t[0]=s,t[1]=e}_leftPerp(t){return[-t[1],t[0]]}_rightPerpendicular(t){const s=t[1],e=-t[0];t[0]=s,t[1]=e}_rightPerp(t){return[t[1],-t[0]]}_dotProduct(t,s){return t[0]*s[0]+t[1]*s[1]}_crossProduct(t,s){return t[0]*s[1]-t[1]*s[0]}_rotateDirect(t,s,e){const i=t[0]*s-t[1]*e,h=t[0]*e+t[1]*s;t[0]=i,t[1]=h}_makeCtrlPt(t){const s=[t[0],t[1]];return i.setId(s,1),s}_addAngledTicks(t,s,e,i){const h=this._sub(e,s);this._normalize(h);const r=this._crossProduct(h,this._sub(i,s));let c;c=r>0?this._rightPerp(h):this._leftPerp(h);const o=Math.abs(r)/2,u=[];u.push([s[0]+(c[0]-h[0])*o,s[1]+(c[1]-h[1])*o]),u.push(s),u.push(e),u.push([e[0]+(c[0]+h[0])*o,e[1]+(c[1]+h[1])*o]),t.push(u)}_addBezier2(t,s,e,i,h){if(0==h--)return void t.push(i);const r=this._mid(s,e),c=this._mid(e,i),o=this._mid(r,c);this._addBezier2(t,s,r,o,h),this._addBezier2(t,o,c,i,h)}_addBezier3(t,s,e,i,h,r){if(0==r--)return void t.push(h);const c=this._mid(s,e),o=this._mid(e,i),u=this._mid(i,h),_=this._mid(c,o),n=this._mid(o,u),a=this._mid(_,n);this._addBezier3(t,s,c,_,a,r),this._addBezier3(t,a,n,u,h,r)}_add90DegArc(t,s,e,i,h){const r=h??this._crossProduct(this._sub(e,s),this._sub(i,s))>0,c=this._mid(s,e),o=this._sub(c,s);r?this._leftPerpendicular(o):this._rightPerpendicular(o),c[0]+=o[0],c[1]+=o[1],this._addBezier3(t,s,this._mix(s,.33333,c,.66667),this._mix(e,.33333,c,.66667),e,4)}_addArrow(t,s,e){const i=s[0],h=s[1],r=s[s.length-1],c=this._sub(i,h);this._normalize(c);const o=this._crossProduct(c,this._sub(r,h)),u=.5*o,_=this._leftPerp(c),n=[r[0]-_[0]*o,r[1]-_[1]*o],a=s.length-1,l=[];l.push(e?[-_[0],-_[1]]:_);let p=[-c[0],-c[1]];for(let d=1;d<a-1;d++){const t=this._sub(s[d+1],s[d]);this._normalize(t);const e=this._dotProduct(t,p),i=this._crossProduct(t,p),h=Math.sqrt((1+e)/2),r=this._sub(t,p);this._normalize(r),r[0]/=h,r[1]/=h,l.push(i<0?[-r[0],-r[1]]:r),p=t}l.push(this._rightPerp(p));for(let d=l.length-1;d>0;d--)t.push([s[d][0]+l[d][0]*u,s[d][1]+l[d][1]*u]);t.push([n[0]+l[0][0]*u,n[1]+l[0][1]*u]),t.push([n[0]+l[0][0]*o,n[1]+l[0][1]*o]),t.push(i),t.push([n[0]-l[0][0]*o,n[1]-l[0][1]*o]),t.push([n[0]-l[0][0]*u,n[1]-l[0][1]*u]);for(let d=1;d<l.length;d++)t.push([s[d][0]-l[d][0]*u,s[d][1]-l[d][1]*u])}_cp2(t,s,e){return t.length>=2?t[1]:this._add2(t[0],s*this._defaultSize,e*this._defaultSize)}_cp3(t,s,e,i){if(t.length>=3)return t[2];const h=this._mix(t[0],1-e,s,e),r=this._sub(s,t[0]);return this._normalize(r),this._rightPerpendicular(r),[h[0]+r[0]*i*this._defaultSize,h[1]+r[1]*i*this._defaultSize]}_arrowPath(t){if(t.length>2)return t;const s=t[0],e=this._cp2(t,-4,0),i=this._sub(s,e);this._normalize(i);const h=this._rightPerp(i);return[s,e,[s[0]+(h[0]-i[0])*this._defaultSize,s[1]+(h[1]-i[1])*this._defaultSize]]}_arrowLastSeg(t){const s=t[0],e=this._cp2(t,-4,0);let i;if(t.length>=3)i=t[t.length-1];else{const t=this._sub(s,e);this._normalize(t);const h=this._rightPerp(t);i=[s[0]+(h[0]-t[0])*this._defaultSize,s[1]+(h[1]-t[1])*this._defaultSize]}return[e,i]}_processGeom(t){if(!t)return null;const s=[];for(const e of t){if(!e||0===e.length)continue;const t=e.length;let r=e[0];switch(this._rule){case h.GeometricEffectControlMeasureLineRule.PerpendicularFromFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=[];h.push(i),h.push(this._mid(r,t)),s.push(h);break}case h.GeometricEffectControlMeasureLineRule.ReversedFirstSegment:{const t=this._cp2(e,0,-1);s.push([t,r]);break}case h.GeometricEffectControlMeasureLineRule.PerpendicularToSecondSegment:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=[];h.push(this._mid(t,i)),h.push(r),s.push(h);break}case h.GeometricEffectControlMeasureLineRule.SecondSegmentWithTicks:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);let c;c=this._crossProduct(h,this._sub(r,t))>0?this._rightPerp(c):this._leftPerp(h);const o=[];o.push([t[0]+(c[0]-h[0])/3,t[1]+(c[1]-h[1])/3]),o.push(t),o.push(i),o.push([i[0]+(c[0]+h[0])/3,i[1]+(c[1]+h[1])/3]),s.push(o);break}case h.GeometricEffectControlMeasureLineRule.DoublePerpendicular:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,3),h=this._mid(r,t),c=this._sub(h,i);this._normalize(c);const o=this._crossProduct(c,this._sub(r,i));this._leftPerpendicular(c);const u=[];u.push(r),u.push([i[0]+c[0]*o,i[1]+c[1]*o]),s.push(u);const _=[];_.push([i[0]-c[0]*o,i[1]-c[1]*o]),_.push(t),s.push(_);break}case h.GeometricEffectControlMeasureLineRule.OppositeToFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,3),h=this._mid(r,t),c=this._sub(h,i);this._normalize(c);const o=this._crossProduct(c,this._sub(r,i));this._leftPerpendicular(c);const u=[];u.push([i[0]+c[0]*o,i[1]+c[1]*o]),u.push([i[0]-c[0]*o,i[1]-c[1]*o]),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.TriplePerpendicular:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=this._mid(r,t),c=this._sub(h,i);this._normalize(c);const o=this._crossProduct(c,this._sub(r,i));this._leftPerpendicular(c);const u=[];u.push([i[0]+c[0]*o*.8,i[1]+c[1]*o*.8]),u.push([h[0]+.8*(r[0]-h[0]),h[1]+.8*(r[1]-h[1])]),s.push(u),s.push([i,h]);const _=[];_.push([i[0]-c[0]*o*.8,i[1]-c[1]*o*.8]),_.push([h[0]+.8*(t[0]-h[0]),h[1]+.8*(t[1]-h[1])]),s.push(_);break}case h.GeometricEffectControlMeasureLineRule.HalfCircleFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=this._mid(r,t);let c=this._sub(t,r);const o=Math.cos(Math.PI/18),u=Math.sin(Math.PI/18),_=Math.sqrt((1+o)/2),n=Math.sqrt((1-o)/2),a=[];let l;this._crossProduct(c,this._sub(i,r))>0?(a.push(r),c=this._sub(r,h),l=t):(a.push(t),c=this._sub(t,h),l=r),this._rotateDirect(c,_,n),c[0]/=_,c[1]/=_;for(let s=1;s<=18;s++)a.push(this._add(h,c)),this._rotateDirect(c,o,u);a.push(l),s.push(a);break}case h.GeometricEffectControlMeasureLineRule.HalfCircleSecondSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,1,-1);let h=this._sub(r,t);this._normalize(h);const c=this._crossProduct(h,this._sub(i,t))/2;this._leftPerpendicular(h);const o=[t[0]+h[0]*c,t[1]+h[1]*c];h=this._sub(t,o);const u=Math.cos(Math.PI/18);let _=Math.sin(Math.PI/18);c>0&&(_=-_);const n=[t];for(let s=1;s<=18;s++)this._rotateDirect(h,u,_),n.push(this._add(o,h));s.push(n);break}case h.GeometricEffectControlMeasureLineRule.HalfCircleExtended:{const i=this._cp2(e,0,-2),h=this._cp3(e,i,1,-1);let c;if(t>=4)c=e[3];else{const t=this._sub(r,i);c=this._add(h,t)}const o=this._dist(i,h)/2/.75,u=this._sub(i,r);this._normalize(u,o);const _=this._sub(h,c);this._normalize(_,o);const n=[c,h];s.push(n);const a=[this._clone(h)];this._addBezier3(a,h,this._add(h,_),this._add(i,u),i,4),a.push(r),s.push(a);break}case h.GeometricEffectControlMeasureLineRule.OpenCircle:{const t=this._cp2(e,-2,0),i=this._sub(t,r),h=Math.cos(Math.PI/18),c=-Math.sin(Math.PI/18),o=[t];for(let s=1;s<=33;s++)this._rotateDirect(i,h,c),o.push(this._add(r,i));s.push(o);break}case h.GeometricEffectControlMeasureLineRule.CoverageEdgesWithTicks:{const i=this._cp2(e,0,-1);let h,c;if(t>=3)h=e[2];else{const t=this._sub(i,r),s=this._leftPerp(t);h=[r[0]+s[0]-.25*t[0],r[1]+s[1]-.25*t[1]]}if(t>=4)c=e[3];else{const t=this._mid(r,i),s=this._sub(r,i);this._normalize(s),this._leftPerpendicular(s);const e=this._crossProduct(s,this._sub(h,t));this._rightPerpendicular(s),c=[h[0]+s[0]*e*2,h[1]+s[1]*e*2]}const o=this._sub(i,r);let u,_;u=this._crossProduct(o,this._sub(h,r))>0?this._rightPerp(o):this._leftPerp(o),_=[],_.push(h),_.push(r),_.push([r[0]+(u[0]-o[0])/3,r[1]+(u[1]-o[1])/3]),s.push(_),u=this._crossProduct(o,this._sub(c,i))>0?this._rightPerp(u):this._leftPerp(o),_=[],_.push([i[0]+(u[0]+o[0])/3,i[1]+(u[1]+o[1])/3]),_.push(i),_.push(c),s.push(_);break}case h.GeometricEffectControlMeasureLineRule.GapExtentWithDoubleTicks:{const i=this._cp2(e,0,2),h=this._cp3(e,i,0,1);let c;if(t>=4)c=e[3];else{const t=this._sub(i,r);c=this._add(h,t)}this._addAngledTicks(s,r,i,this._mid(h,c)),this._addAngledTicks(s,h,c,this._mid(r,i));break}case h.GeometricEffectControlMeasureLineRule.GapExtentMidline:{const i=this._cp2(e,2,0),h=this._cp3(e,i,0,1);let c;if(t>=4)c=e[3];else{const t=this._sub(i,r);c=this._add(h,t)}const o=[];o.push(this._mid(r,h)),o.push(this._mid(i,c)),s.push(o);break}case h.GeometricEffectControlMeasureLineRule.Chevron:{const i=this._cp2(e,-1,-1);let h;if(t>=3)h=e[2];else{const t=this._sub(i,r);this._leftPerpendicular(t),h=this._add(r,t)}s.push([i,this._makeCtrlPt(r),h]);break}case h.GeometricEffectControlMeasureLineRule.PerpendicularWithArc:{const t=this._cp2(e,0,-2),i=this._cp3(e,t,.5,-1);let h=this._sub(t,r);const c=this._norm(h);h[0]/=c,h[1]/=c;const o=this._crossProduct(h,this._sub(i,r));let u=this._dotProduct(h,this._sub(i,r));u<.05*c?u=.05*c:u>.95*c&&(u=.95*c);const _=[r[0]+h[0]*u,r[1]+h[1]*u];this._leftPerpendicular(h);let n=[];n.push([_[0]-h[0]*o,_[1]-h[1]*o]),n.push([_[0]+h[0]*o,_[1]+h[1]*o]),s.push(n);const a=[t[0]+h[0]*o,t[1]+h[1]*o];h=this._sub(t,a);const l=Math.cos(Math.PI/18);let p=Math.sin(Math.PI/18);o<0&&(p=-p),n=[r,t];for(let s=1;s<=9;s++)this._rotateDirect(h,l,p),n.push(this._add(a,h));s.push(n);break}case h.GeometricEffectControlMeasureLineRule.ClosedHalfCircle:{const t=this._cp2(e,2,0),i=this._mid(r,t),h=this._sub(t,i),c=Math.cos(Math.PI/18),o=Math.sin(Math.PI/18),u=[r,t];for(let s=1;s<=18;s++)this._rotateDirect(h,c,o),u.push(this._add(i,h));s.push(u);break}case h.GeometricEffectControlMeasureLineRule.TripleParallelExtended:{const t=this._cp2(e,0,-2),h=this._cp3(e,t,1,-2),c=this._mid(r,t),o=this._sub(h,t);this._normalize(o);const u=Math.abs(this._crossProduct(o,this._sub(c,t)))/2,_=this._dist(t,h),n=[t,r];n.push([r[0]+o[0]*_*.5,r[1]+o[1]*_*.5]),s.push(n);const a=[];a.push([c[0]-o[0]*u,c[1]-o[1]*u]),a.push([c[0]+o[0]*_*.375,c[1]+o[1]*_*.375]),i.setId(a[a.length-1],1),a.push([c[0]+o[0]*_*.75,c[1]+o[1]*_*.75]),s.push(a);const l=[t,h];s.push(l);break}case h.GeometricEffectControlMeasureLineRule.ParallelWithTicks:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(i,t);this._normalize(h);const c=this._crossProduct(h,this._sub(i,r));this._leftPerpendicular(h),this._addAngledTicks(s,r,t,i),this._addAngledTicks(s,this._mix(r,1,h,c),this._mix(t,1,h,c),this._mid(r,t));break}case h.GeometricEffectControlMeasureLineRule.Parallel:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,r);this._normalize(h);const c=this._leftPerp(h),o=this._crossProduct(h,this._sub(i,r));let u=[r,t];s.push(u),u=[],u.push([r[0]+c[0]*o,r[1]+c[1]*o]),u.push([t[0]+c[0]*o,t[1]+c[1]*o]),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.PerpendicularToFirstSegment:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._mid(r,t),c=this._sub(t,r);this._normalize(c);const o=this._crossProduct(c,this._sub(i,r));this._leftPerpendicular(c);const u=[];u.push([h[0]-c[0]*o*.25,h[1]-c[1]*o*.25]),u.push([h[0]+c[0]*o*1.25,h[1]+c[1]*o*1.25]),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.ParallelOffset:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,r);this._normalize(h);const c=this._crossProduct(h,this._sub(i,r));this._leftPerpendicular(h);const o=[];o.push([r[0]-h[0]*c,r[1]-h[1]*c]),o.push([t[0]-h[0]*c,t[1]-h[1]*c]),s.push(o);const u=[];u.push([r[0]+h[0]*c,r[1]+h[1]*c]),u.push([t[0]+h[0]*c,t[1]+h[1]*c]),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.OffsetOpposite:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,r);this._normalize(h);const c=this._crossProduct(h,this._sub(i,r));this._leftPerpendicular(h);const o=[];o.push([r[0]-h[0]*c,r[1]-h[1]*c]),o.push([t[0]-h[0]*c,t[1]-h[1]*c]),s.push(o);break}case h.GeometricEffectControlMeasureLineRule.OffsetSame:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,r);this._normalize(h);const c=this._crossProduct(h,this._sub(i,r));this._leftPerpendicular(h);const o=[];o.push([r[0]+h[0]*c,r[1]+h[1]*c]),o.push([t[0]+h[0]*c,t[1]+h[1]*c]),s.push(o);break}case h.GeometricEffectControlMeasureLineRule.CircleWithArc:{let h=this._cp2(e,3,0);const c=this._cp3(e,h,.5,-1);let o,u;if(t>=4)o=e[3],u=this._crossProduct(this._sub(o,h),this._sub(c,h))>0;else{o=h,u=this._crossProduct(this._sub(o,r),this._sub(c,r))>0;const t=24*this._geomUnitsPerPoint,s=this._sub(o,r);this._normalize(s,t);const e=Math.sqrt(2)/2;this._rotateDirect(s,e,u?e:-e),h=this._add(r,s)}const _=this._sub(h,r),n=Math.cos(Math.PI/18),a=Math.sin(Math.PI/18),l=[h];for(let t=1;t<=36;t++)this._rotateDirect(_,n,a),l.push(this._add(r,_));this._add90DegArc(l,h,o,c,u),i.setId(l[l.length-8],1),s.push(l);break}case h.GeometricEffectControlMeasureLineRule.DoubleJog:{let i,h,c=this._cp2(e,-3,1);if(i=t>=3?e[2]:this._add(r,this._sub(r,c)),t>=4)h=e[3];else{const t=r;r=c,h=i;const s=this._dist(r,t),e=this._dist(h,t);let o=30*this._geomUnitsPerPoint;.5*s<o&&(o=.5*s),.5*e<o&&(o=.5*e),c=this._mix(r,o/s,t,(s-o)/s),i=this._mix(h,o/e,t,(e-o)/e)}const o=this._mid(r,c),u=this._mid(h,i),_=this._dist(r,c),n=this._dist(i,h);let a=Math.min(_,n)/8;a=Math.min(a,24*this._geomUnitsPerPoint);const l=Math.cos(Math.PI/4);let p=this._sub(r,c);this._normalize(p,a),this._crossProduct(p,this._sub(h,c))>0?this._rotateDirect(p,l,-l):this._rotateDirect(p,l,l);let d=[];d.push(c),d.push(this._add(o,p)),d.push(this._sub(o,p)),d.push(r),s.push(d),p=this._sub(h,i),this._normalize(p,a),this._crossProduct(p,this._sub(r,i))<0?this._rotateDirect(p,l,l):this._rotateDirect(p,l,-l),d=[],d.push(i),d.push(this._add(u,p)),d.push(this._sub(u,p)),d.push(h),s.push(d);break}case h.GeometricEffectControlMeasureLineRule.PerpendicularOffset:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);this._crossProduct(h,this._sub(r,t))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const c=[h[0]/8,h[1]/8],o=this._sub(this._mid(t,i),c);s.push([o,r]);break}case h.GeometricEffectControlMeasureLineRule.LineExcludingLastSegment:{const t=this._arrowPath(e),i=[];let h=t.length-2;for(;h--;)i.push(t[h]);s.push(i);break}case h.GeometricEffectControlMeasureLineRule.MultivertexArrow:{const t=this._arrowPath(e),i=[];this._addArrow(i,t,!1),s.push(i);break}case h.GeometricEffectControlMeasureLineRule.CrossedArrow:{const t=this._arrowPath(e),i=[];this._addArrow(i,t,!0),s.push(i);break}case h.GeometricEffectControlMeasureLineRule.ChevronArrow:{const[t,i]=this._arrowLastSeg(e),h=10*this._geomUnitsPerPoint,c=this._sub(r,t);this._normalize(c);const o=this._crossProduct(c,this._sub(i,t)),u=this._leftPerp(c),_=[i[0]-u[0]*o*2,i[1]-u[1]*o*2],n=[];n.push([i[0]+c[0]*h,i[1]+c[1]*h]),n.push(r),n.push([_[0]+c[0]*h,_[1]+c[1]*h]),s.push(n);break}case h.GeometricEffectControlMeasureLineRule.ChevronArrowOffset:{const[t,i]=this._arrowLastSeg(e),h=this._sub(r,t);this._normalize(h);const c=this._crossProduct(h,this._sub(i,t));this._leftPerpendicular(h);const o=[i[0]-h[0]*c,i[1]-h[1]*c],u=[];u.push([o[0]+h[0]*c*.5,o[1]+h[1]*c*.5]),u.push(this._mid(o,r)),u.push([o[0]-h[0]*c*.5,o[1]-h[1]*c*.5]),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.PartialFirstSegment:{const[t,i]=this._arrowLastSeg(e),h=this._sub(r,t);this._normalize(h);const c=this._crossProduct(h,this._sub(i,t));this._leftPerpendicular(h);const o=[i[0]-h[0]*c,i[1]-h[1]*c];s.push([t,o]);break}case h.GeometricEffectControlMeasureLineRule.Arch:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,1),h=this._sub(r,t),c=this._mix(i,1,h,.55),o=this._mix(i,1,h,-.55),u=[r];this._addBezier2(u,r,c,i,4),this._addBezier2(u,i,o,t,4),s.push(u);break}case h.GeometricEffectControlMeasureLineRule.CurvedParallelTicks:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);this._crossProduct(h,this._sub(r,t))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const c=[h[0]/8,h[1]/8],o=this._sub(this._mid(t,i),c),u=this._sub(this._mix(t,.75,i,.25),c),_=this._sub(this._mix(t,.25,i,.75),c),n=[t];this._addBezier2(n,t,u,o,3),this._addBezier2(n,o,_,i,3),s.push(n);for(let e=0;e<8;e++){const t=n[2*e+1],i=[this._clone(t)];i.push(this._add(t,[h[0]/4,h[1]/4])),s.push(i)}break}case h.GeometricEffectControlMeasureLineRule.Arc90Degrees:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,1),h=[t];this._add90DegArc(h,t,r,i),s.push(h);break}case h.GeometricEffectControlMeasureLineRule.FullGeometry:default:s.push(e)}}return s}}t.EffectControlMeasureLine=r,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
