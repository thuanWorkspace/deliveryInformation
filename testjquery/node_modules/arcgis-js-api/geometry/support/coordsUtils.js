/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../core/arrayUtils","./Axis","./spatialReferenceUtils"],(function(n,t,e,r){"use strict";function i(n){if(!n)return null;if(Array.isArray(n))return n;const t=n.hasZ,e=n.hasM;if("point"===n.type)return e&&t?[n.x,n.y,n.z,n.m]:t?[n.x,n.y,n.z]:e?[n.x,n.y,n.m]:[n.x,n.y];if("polygon"===n.type)return n.rings.slice(0);if("polyline"===n.type)return n.paths.slice(0);if("multipoint"===n.type)return n.points.slice(0);if("extent"===n.type){const t=n.clone().normalize();if(!t)return null;let e=!1,r=!1;return t.forEach((n=>{n.hasZ&&(e=!0),n.hasM&&(r=!0)})),t.map((n=>{const t=[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]];if(e&&n.hasZ){const e=.5*(n.zmax-n.zmin);for(let n=0;n<t.length;n++)t[n].push(e)}if(r&&n.hasM){const e=.5*(n.mmax-n.mmin);for(let n=0;n<t.length;n++)t[n].push(e)}return t}))}return null}function o(n,t){const e=t[0]-n[0],r=t[1]-n[1];if(n.length>2&&t.length>2){const i=n[2]-t[2];return Math.sqrt(e*e+r*r+i*i)}return Math.sqrt(e*e+r*r)}function s(n,t,e){const r=n[0]+e*(t[0]-n[0]),i=n[1]+e*(t[1]-n[1]);return n.length>2&&t.length>2?[r,i,n[2]+e*(t[2]-n[2])]:[r,i]}function l(n,t,e,r){return u(n,t,e[r],e[r+1])}function u(n,t,e,r){const[i,o]=t,[s,l]=e,[u,c]=r,f=u-s,a=c-l,g=f*f+a*a,h=(i-s)*f+(o-l)*a,p=Math.min(1,Math.max(0,h/g));return n[0]=s+f*p,n[1]=l+a*p,n}function c(n,t,e){let r,i,o,s,l=!1,u=1/0;for(e.reset();e.nextPath();)if(e.nextPoint())for(r=e.x,i=e.y;e.nextPoint();)o=e.x,s=e.y,i>t!=s>t&&n<(o-r)*(t-i)/(s-i)+r&&(l=!l),u=Math.min(u,f(n,t,r,i,o,s)),r=o,i=s;return 0===u?0:(l?1:-1)*Math.sqrt(u)}function f(n,t,e,r,i,o){let s=e,l=r,u=i-s,c=o-l;if(0!==u||0!==c){const e=((n-s)*u+(t-l)*c)/(u*u+c*c);e>1?(s=i,l=o):e>0&&(s+=u*e,l+=c*e)}return u=n-s,c=t-l,u*u+c*c}function a(n,t){return s(n,t,.5)}function g(n){const t=n.length;let e=0;for(let r=0;r<t-1;++r)e+=o(n[r],n[r+1]);return e}function h(n,t){if(t<=0)return n[0];const e=n.length;let r=0;for(let i=0;i<e-1;++i){const e=o(n[i],n[i+1]);if(t-r<e){const o=(t-r)/e;return s(n[i],n[i+1],o)}r+=e}return n[e-1]}function p(n,t=e.Axis.X,r=e.Axis.Y){let i=0;const o=n.length;let s=n[0];for(let e=0;e<o-1;e++){const o=n[e+1];i+=(o[t]-s[t])*(o[r]+s[r]),s=o}return i>=0}function y(n){const e=n.length;return e>2&&t.equals(n[0],n[e-1])}function m(n){if("rings"in n&&(x(n),n.rings.length>0&&!p(n.rings[0])))for(const t of n.rings)t.reverse()}function x(n){if("rings"in n)for(const t of n.rings)y(t)||t.push(t[0].slice())}function d(n){if("polygon"!==n.type&&"polyline"!==n.type)return n;return M("polygon"===n.type?n.rings:n.paths,n.spatialReference),n}function M(n,t){const e=r.getInfo(t);if(!e)return;const i=e.valid[0],o=e.valid[1],s=o-i;for(const r of n){let n=1/0,t=-1/0;for(const s of r){const e=P(s[0],i,o);n=Math.min(n,e),t=Math.max(t,e),s[0]=e}const e=t-n;s-e<e&&r.forEach((n=>{n[0]<0&&(n[0]+=s)}))}}function P(n,t,e){const r=e-t;return n<t?e-(t-n)%r:n>e?t+(n-t)%r:n}function z(n){if(!n||n.length<3)return 0;let t=0;const e=n.length-1;for(let r=0;r<e;r++)t+=(n[r][0]-n[r+1][0])*(n[r][1]+n[r+1][1]);return t+=(n[e][0]-n[0][0])*(n[e][1]+n[0][1]),-.5*t}function A(n,t){if(n===t)return!0;if(n.type!==t.type)return!1;if("point"===n.type||"mesh"===n.type||"extent"===n.type)return!0;if("multipoint"===n.type)return n.points.length===t.points.length;const[e,r]="polyline"===n.type?[n.paths,t.paths]:[n.rings,t.rings];return e.length===r.length&&e.every(((n,t)=>n.length===r[t].length))}n.closeRings=x,n.closeRingsAndFixWinding=m,n.distanceFromPointToPolygon=c,n.distanceToSegmentSquared=f,n.geometryToCoordinates=i,n.getLength=o,n.getMidpoint=a,n.getPathLength=g,n.getPointOnPath=h,n.getRingArea=z,n.hasCompatibleTopology=A,n.isClockwise=p,n.isClosed=y,n.projectPointOnLine=l,n.projectPointOnLineSeg=u,n.unnormalizeGeometryOnDatelineCrossing=d,n.unnormalizeVerticesOnDatelineCrossing=M,n.unnormalizedCoordinate=P,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})}));
