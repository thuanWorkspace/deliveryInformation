/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/mat3f64","../../../chunks/vec3","../../../chunks/vec3f64","../MeshComponent","../MeshVertexAttributes","./georeference"],(function(e,t,n,r,o,a,s){"use strict";function i(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=y,r=4*e.length,o=new Float64Array(3*r),a=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(2*e.length*3);let c=0,l=0,f=0,u=0;for(let h=0;h<e.length;h++){const r=e[h],w=c/3;for(const e of t)i[u++]=w+e;const p=r.corners;for(let e=0;e<4;e++){const t=p[e];let i=0;s[f++]=.25*n[e][0]+r.uvOrigin[0],s[f++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[c++]=.5*r.axis[e],a[l++]=r.axis[e]):(o[c++]=.5*t[i++],a[l++]=0)}}return{position:o,normal:a,uv:s,faces:i}}function c(e,t){const n=e.components[0],r=n.faces,a=d[t],s=6*a,i=new Array(6),c=new Array(r.length-6);let l=0,f=0;for(let o=0;o<r.length;o++)o>=s&&o<s+6?i[l++]=r[o]:c[f++]=r[o];if(null!=e.vertexAttributes.uv){const t=new Float32Array(e.vertexAttributes.uv),n=4*a*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new o({faces:i,material:n.material}),new o({faces:c})],e}function l(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),a=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(3*((t-1)*n*2));let c=0,l=0,f=0,u=0;for(let h=0;h<=t;h++){const e=h/t*Math.PI+.5*Math.PI,r=Math.cos(e),w=Math.sin(e);M[2]=w;const p=0===h||h===t,v=p?n-1:n;for(let g=0;g<=v;g++){const e=g/v*2*Math.PI;M[0]=-Math.sin(e)*r,M[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[c]=.5*M[t],a[c]=M[t],++c;s[l++]=(g+(p?.5:0))/n,s[l++]=h/t,0!==h&&g!==n&&(h!==t&&(i[f++]=u,i[f++]=u+1,i[f++]=u-n),1!==h&&(i[f++]=u,i[f++]=u-n,i[f++]=u-n-1)),u++}}return{position:o,normal:a,uv:s,faces:i}}function f(e=0){const t=5,n=Math.round(16*2**e),r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),a=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(3*(4*n));let c=0,l=0,f=0,u=0,h=0;for(let w=0;w<=t;w++){const e=0===w||w===t,r=w<=1||w>=t-1,p=2===w||4===w,v=e?n-1:n;for(let g=0;g<=v;g++){const m=g/v*2*Math.PI,A=e?0:.5;M[0]=A*Math.sin(m),M[1]=A*-Math.cos(m),M[2]=w<=2?.5:-.5;for(let e=0;e<3;e++)o[c++]=M[e],a[l++]=r?2===e?w<=1?1:-1:0:2===e?0:M[e]/A;s[f++]=(g+(e?.5:0))/n,s[f++]=w<=1?1*w/3:w<=3?1*(w-2)/3+1/3:1*(w-4)/3+2/3,p||0===w||g===n||(w!==t&&(i[u++]=h,i[u++]=h+1,i[u++]=h-n),1!==w&&(i[u++]=h,i[u++]=h-n,i[u++]=h-n-1)),h++}}return{position:o,normal:a,uv:s,faces:i}}function u(e,t){const n="number"==typeof t?t:null!=t?t.width:1,r="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}function h(e){const t=g.facingAxisOrderSwap[e],n=g.position,r=g.normal,o=new Float64Array(n.length),a=new Float32Array(r.length);let s=0;for(let i=0;i<4;i++){const e=s;for(let i=0;i<3;i++){const c=t[i],l=Math.abs(c)-1,f=c>=0?1:-1;o[s]=n[e+l]*f,a[s]=r[e+l]*f,s++}}return{position:o,normal:a,uv:new Float32Array(g.uv),faces:new Uint32Array(g.faces),isPlane:!0}}const w=1,p=2,v=3,g={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[v,w,p],west:[-v,-w,p],north:[-w,v,p],south:[w,-v,p],up:[w,p,v],down:[w,-p,-v]}};function m(e,t,n){e.isPlane||A(e),x(e,n?.size);const{vertexAttributes:r,vertexSpace:i,transform:c}=s.georeferenceByTransform(e,t,n);return{vertexAttributes:new a.MeshVertexAttributes({...r,uv:e.uv}),vertexSpace:i,transform:c,components:[new o({faces:e.faces,material:n?.material||null})],spatialReference:t.spatialReference}}function A(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}function x(e,t){if(null==t)return;const r="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];F[0]=r[0],F[4]=r[1],F[8]=r[2];for(let o=0;o<e.position.length;o+=3){for(let t=0;t<3;t++)M[t]=e.position[o+t];n.transformMat3(M,M,F);for(let t=0;t<3;t++)e.position[o+t]=M[t]}if(r[0]!==r[1]||r[1]!==r[2]){F[0]=1/r[0],F[4]=1/r[1],F[8]=1/r[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)M[n]=e.normal[t+n];n.transformMat3(M,M,F),n.normalize(M,M);for(let n=0;n<3;n++)e.normal[t+n]=M[n]}}}const y={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},d={south:0,east:1,north:2,west:3,up:4,down:5},M=r.create(),F=t.create();e.boxFaceOrder=d,e.convertPlaneSizeParameter=u,e.convertUnitGeometry=m,e.createUnitSizeBox=i,e.createUnitSizeCylinder=f,e.createUnitSizePlane=h,e.createUnitSizeSphere=l,e.extractSingleFaceOfBox=c,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
