/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../config","../../core/Error","../../core/Logger","../Polygon","../Polyline","./normalizeUtilsCommon","./spatialReferenceUtils","./webMercatorUtils","../../rest/geometryService/cut","../../rest/geometryService/simplify"],(function(e,t,n,o,s,r,i,l,c,a,f){"use strict";const u=o.getLogger("esri.geometry.support.normalizeUtils");function h(e){return"polygon"===e.type}function p(e){return"polygon"===e[0].type}function g(e){return"polyline"===e[0].type}function m(e){const t=[];let n=0,o=0;for(let s=0;s<e.length;s++){const r=e[s];let i=null;for(let e=0;e<r.length;e++)i=r[e],t.push(i),0===e?(n=i[0],o=n):(n=Math.min(n,i[0]),o=Math.max(o,i[0]));i&&t.push([(n+o)/2,0])}return t}function y(e,t){if(!(e instanceof r||e instanceof s)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw u.error(e),new n(e)}const o=i.getGeometryParts(e),l=[];for(const n of o){const e=[];l.push(e),e.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const s=n[o][0],r=n[o][1],i=n[o+1][0],l=n[o+1][1],c=Math.sqrt((i-s)*(i-s)+(l-r)*(l-r)),a=(l-r)/c,f=(i-s)/c,u=c/t;if(u>1){for(let l=1;l<=u-1;l++){const n=l*t,o=f*n+s,i=a*n+r;e.push([o,i])}const n=(c+Math.floor(u-1)*t)/2,o=f*n+s,i=a*n+r;e.push([o,i])}e.push([i,l])}}return h(e)?new s({rings:l,spatialReference:e.spatialReference}):new r({paths:l,spatialReference:e.spatialReference})}function x(e,t,n){if(t){const t=y(e,1e6);e=c.webMercatorToGeographic(t,!0)}return n&&(e=i.updatePolyGeometry(e,n)),e}function d(e,t,n){if(Array.isArray(e)){const o=e[0];if(o>t){const n=i.offsetMagnitude(o,t);e[0]=o+n*(-2*t)}else if(o<n){const t=i.offsetMagnitude(o,n);e[0]=o+t*(-2*n)}}else{const o=e.x;if(o>t){const n=i.offsetMagnitude(o,t);e=e.clone().offset(n*(-2*t),0)}else if(o<n){const t=i.offsetMagnitude(o,n);e=e.clone().offset(t*(-2*n),0)}}return e}function M(e,t){let n=-1;for(let o=0;o<t.cutIndexes.length;o++){const s=t.cutIndexes[o],r=t.geometries[o],l=i.getGeometryParts(r);for(let e=0;e<l.length;e++){const t=l[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const o=t[e][0];n=o>n?o:n}n=Number(n.toFixed(9));const o=-360*i.offsetMagnitude(n,180);for(let s=0;s<t.length;s++){const t=r.getPoint(e,s);r.setPoint(e,s,t.clone().offset(o,0))}return!0}}))}if(s===n){if(p(e))for(const t of i.getGeometryParts(r))e[s]=e[s].addRing(t);else if(g(e))for(const t of i.getGeometryParts(r))e[s]=e[s].addPath(t)}else n=s,e[s]=r}return e}async function P(e,n,o){if(!Array.isArray(e))return P([e],n);n&&"string"!=typeof n&&u.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const h="string"==typeof n?n:n?.url??t.geometryServiceUrl;let p,g,m,y,b,w,R,z,v=0;const G=[],T=[];for(const t of e)if(null!=t)if(p||(p=t.spatialReference,g=l.getInfo(p),m=p.isWebMercator,w=m?102100:4326,y=i.cutParams[w].maxX,b=i.cutParams[w].minX,R=i.cutParams[w].plus180Line,z=i.cutParams[w].minus180Line),g)if("mesh"===t.type)T.push(t);else if("point"===t.type)T.push(d(t.clone(),y,b));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((e=>d(e,y,b))),T.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,g);T.push(e.rings?new s(e):e)}else if(t.extent){const e=t.extent,n=i.offsetMagnitude(e.xmin,b)*(2*y);let o=0===n?t.clone():i.updatePolyGeometry(t.clone(),n);e.offset(n,0),e.intersects(R)&&e.xmax!==y?(v=e.xmax>v?e.xmax:v,o=x(o,m),G.push(o),T.push("cut")):e.intersects(z)&&e.xmin!==b?(v=e.xmax*(2*y)>v?e.xmax*(2*y):v,o=x(o,m,360),G.push(o),T.push("cut")):T.push(o)}else T.push(t.clone());else T.push(t);else T.push(t);let I=i.offsetMagnitude(v,y),L=-90;const S=I,U=new r;for(;I>0;){const e=360*I-180;U.addPath([[e,L],[e,-1*L]]),L*=-1,I--}if(G.length>0&&S>0){const t=M(G,await a.cut(h,G,U,o)),n=[],s=[];for(let o=0;o<T.length;o++){const r=T[o];if("cut"!==r)s.push(r);else{const r=t.shift(),i=e[o];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(n.push(r),s.push("simplify")):s.push(m?c.geographicToWebMercator(r):r)}}if(!n.length)return s;const r=await f.simplify(h,n,o),i=[];for(let e=0;e<s.length;e++){const t=s[e];"simplify"!==t?i.push(t):i.push(m?c.geographicToWebMercator(r.shift()):r.shift())}return i}const A=[];for(let t=0;t<T.length;t++){const e=T[t];if("cut"!==e)A.push(e);else{const e=G.shift();A.push(!0===m?c.geographicToWebMercator(e):e)}}return A}function b(e){if(!e)return null;const t=e.extent;if(!t)return null;const n=e.spatialReference&&l.getInfo(e.spatialReference);if(!n)return t;const[o,s]=n.valid,r=2*s,{width:i}=t;let c,{xmin:a,xmax:f}=t;if([a,f]=[f,a],"extent"===e.type||0===i||i<=s||i>r||a<o||f>s)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;c=m(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;c=m(e.paths);break;case"multipoint":c=e.points}const u=t.clone();for(let l=0;l<c.length;l++){let e=c[l][0];e<0?(e+=s,f=Math.max(e,f)):(e-=s,a=Math.min(e,a))}return u.xmin=a,u.xmax=f,u.width<i?(u.xmin-=s,u.xmax-=s,u):t}function w(e,t,n){const o=l.getInfo(n);if(null==o)return e;const[s,r]=o.valid,i=2*r;let c=0,a=0;t>r?c=Math.ceil(Math.abs(t-r)/i):t<s&&(c=-Math.ceil(Math.abs(t-s)/i)),e>r?a=Math.ceil(Math.abs(e-r)/i):e<s&&(a=-Math.ceil(Math.abs(e-s)/i));let f=e+(c-a)*i;const u=f-t;return u>r?f-=i:u<s&&(f+=i),f}function R(e,t){const n=l.getInfo(t);if(n){const[t,o]=n.valid,s=o-t;if(e<t)for(;e<t;)e+=s;if(e>o)for(;e>o;)e-=s}return e}e.getClosestDenormalizedXToReference=w,e.getDenormalizedExtent=b,e.normalizeCentralMeridian=P,e.normalizeMapX=R,e.straightLineDensify=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
