/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","../chunks/tslib.es6","../core/Error","../core/Loadable","../core/Logger","../core/Promise","../core/promiseUtils","../core/reactiveUtils","../core/accessorSupport/decorators/property","../core/accessorSupport/ensureType","../core/arrayUtils","../core/has","../core/accessorSupport/decorators/subclass","../chunks/vec3f64","./Extent","./Geometry","./Point","./Polygon","./support/axisAngleDegrees","./support/MeshComponent","./support/meshErrors","./support/MeshGeoreferencedRelativeVertexSpace","./support/MeshGeoreferencedVertexSpace","./support/MeshLocalVertexSpace","./support/MeshTransform","./support/MeshVertexAttributes","./support/triangulationUtils","./support/meshUtils/bounds","./support/meshUtils/centerAt","./support/meshUtils/georeference","./support/meshUtils/loadExternal","./support/meshUtils/Metadata","./support/meshUtils/offset","./support/meshUtils/primitives","./support/meshUtils/rotate","./support/meshUtils/scale","../layers/support/infoFor3D","../support/zipUtils"],(function(e,t,r,o,s,n,a,i,c,l,p,h,u,d,m,g,f,x,y,v,w,S,E,_,L,F,M,b,A,U,P,R,z,C,G,j,N,O){"use strict";var V;const I="esri.geometry.Mesh",T={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:E,"georeferenced-relative":S,local:_}};let B=V=class extends(o.LoadableMixin(n.EsriPromiseMixin(g))){constructor(e){super(e),this.components=null,this.vertexSpace=new E,this.transform=null,this.metadata=new R.Metadata,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new F.MeshVertexAttributes,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(i.watch((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:r,vertexSpace:o}=this,s=r.position;if(0===s.length||e&&0===e.length)return new m({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if("local"===o.type){const{_untransformedExtent:e,transform:r}=this;return b.getProjectedExtent(e,r,o,t)}if("georeferenced-relative"===o.type){const{transform:e}=this,r=U.project({positions:s,transform:e,vertexSpace:o,inSpatialReference:t,outSpatialReference:t});return b.getExtentFromPositions(r,t)}return b.getExtentFromPositions(s,t)}get _untransformedExtent(){return b.getExtentFromPositions(this.vertexAttributes.position,this.spatialReference)}get anchor(){const{vertexSpace:e}=this;if(e.isRelative)return e.getOriginPoint(this.spatialReference);const{center:t,zmin:r}=this._transformedExtent;return new f({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get origin(){const{vertexSpace:e}=this;return e.isRelative?e.getOriginPoint(this.spatialReference):this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){if(!this.loaded)return s.getLogger(this).error("addComponent()",(new w.MeshNotLoadedError).message);this.components||(this.components=[]),this.components.push(v.from(e)),this.notifyChange("components")}removeComponent(e){if(!this.loaded)return s.getLogger(this).error("removeComponent()",(new w.MeshNotLoadedError).message);if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}s.getLogger(this).error("removeComponent()",(new w.ComponentNotFoundError).message)}rotate(e,t,r,o){return y.composeAxes(e,t,r,W),G.rotate(this,W,o),this}offset(e,t,r,o){return this.loaded?(D[0]=e,D[1]=t,D[2]=r,z.offset(this,D,o),this):(s.getLogger(this).error("offset()",(new w.MeshNotLoadedError).message),this)}scale(e,t){return this.loaded?(j.scale(this,e,t),this):(s.getLogger(this).error("scale()",(new w.MeshNotLoadedError).message),this)}centerAt(e,t){return this.loaded?(A.centerAt(this,e,t),this):(s.getLogger(this).error("centerAt()",(new w.MeshNotLoadedError).message),this)}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(P.loadExternal(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(e){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map((t=>t.cloneWithDeduplication(e,r)))}const r={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:e,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new V(r)}cloneShallow(){return new V({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const r=new Promise(((t,r)=>e(["./support/meshUtils/exporters/gltf/gltfexport"],t,r))),o=this.load(),s=await Promise.all([r,o]),{toBinaryGLTF:n}=s[0];return n(this,t)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}static createBox(e,t){if(!(e instanceof f))return s.getLogger(I).error(".createBox()",(new w.InvalidLocationError).message),null;const r=new V(C.convertUnitGeometry(C.createUnitSizeBox(),e,t));return t?.imageFace&&"all"!==t.imageFace?C.extractSingleFaceOfBox(r,t.imageFace):r}static createSphere(e,t){return e instanceof f?new V(C.convertUnitGeometry(C.createUnitSizeSphere(t?.densificationFactor||0),e,t)):(s.getLogger(I).error(".createSphere()",(new w.InvalidLocationError).message),null)}static createCylinder(e,t){return e instanceof f?new V(C.convertUnitGeometry(C.createUnitSizeCylinder(t?.densificationFactor||0),e,t)):(s.getLogger(I).error(".createCylinder()",(new w.InvalidLocationError).message),null)}static createPlane(e,t){if(!(e instanceof f))return s.getLogger(I).error(".createPlane()",(new w.InvalidLocationError).message),null;const r=t?.facing??"up",o=C.convertPlaneSizeParameter(r,t?.size);return new V(C.convertUnitGeometry(C.createUnitSizePlane(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof x))return s.getLogger(I).error(".createFromPolygon()",(new w.InvalidPolygonError).message),null;const r=M.triangulate(e);return new V({vertexAttributes:new F.MeshVertexAttributes({position:r.position}),components:[new v({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new E})}static async createFromGLTF(t,r,o){if(!(t instanceof f)){const e=new w.InvalidLocationError;throw s.getLogger(I).error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:n}=await a.whenOrAbort(new Promise(((t,r)=>e(["./support/meshUtils/loadGLTFMesh"],t,r))),o);return new V(await n(t,r,o))}static async createFromFiles(e,t,r){const o=e=>s.getLogger(I).error(".createFromFiles()",e.message);if(!(e instanceof f)){const e=new w.InvalidLocationError;throw o(e),e}const n=r?.layer;if(!n){const e=new w.NoLayerError;throw o(e),e}const a=await V.extractAndFilterFiles(t,n),i=a.reduce(((e,t)=>N.isFileEditFormat(n.infoFor3D,t)?e+1:e),0);if(0===i){const e=new w.NoModelError;throw o(e),e}if(i>1){const e=new w.MultipleModelsError;throw o(e),e}const c=V.createWithExternalSource(e,a),[l]=await n.uploadAssets([c],r);return l}static async extractAndFilterFiles(e,t){const r=t?.infoFor3D;if(!r)return e;return(await O.extractZipFiles(e)).filter((e=>N.isFileSupported(r,e)))}static createWithExternalSource(e,t,r){const o=r?.extent??null,{x:s,y:n,z:a,spatialReference:i}=e,c=r?.transform?.clone()??new L,l=r?.vertexSpace??new _({origin:[s,n,a??0]}),p={source:t,extent:o},h=new R.Metadata;return h.externalSources.push(p),new V({metadata:h,transform:c,vertexSpace:l,spatialReference:i})}static createIncomplete(e,t){const{x:o,y:s,z:n,spatialReference:a}=e,i=t?.transform?.clone()??new L,c=t?.vertexSpace??new _({origin:[o,s,n??0]}),l=new V({transform:i,vertexSpace:c,spatialReference:a});return l.addResolvingPromise(Promise.reject(new r("mesh-incomplete","Mesh resources are not complete"))),l}};t.__decorate([c.property({type:[v],json:{write:!0}})],B.prototype,"components",void 0),t.__decorate([c.property({nonNullable:!0,types:T,constructOnly:!0,json:{write:!0}})],B.prototype,"vertexSpace",void 0),t.__decorate([c.property({type:L,json:{write:!0}})],B.prototype,"transform",void 0),t.__decorate([c.property({constructOnly:!0})],B.prototype,"metadata",void 0),t.__decorate([c.property()],B.prototype,"hasExtent",null),t.__decorate([c.property()],B.prototype,"_transformedExtent",null),t.__decorate([c.property()],B.prototype,"_untransformedExtent",null),t.__decorate([c.property()],B.prototype,"anchor",null),t.__decorate([c.property()],B.prototype,"origin",null),t.__decorate([c.property({readOnly:!0,json:{read:!1}})],B.prototype,"extent",null),t.__decorate([c.property({readOnly:!0,json:{read:!1,write:!0,default:!0}})],B.prototype,"hasZ",void 0),t.__decorate([c.property({readOnly:!0,json:{read:!1,write:!0,default:!1}})],B.prototype,"hasM",void 0),t.__decorate([c.property({type:F.MeshVertexAttributes,nonNullable:!0,json:{write:!0}})],B.prototype,"vertexAttributes",void 0),B=V=t.__decorate([u.subclass(I)],B);const D=d.create(),W=y.create();return B}));
