/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","exports","../core/Error","../core/promiseUtils","../core/accessorSupport/tracking","../core/accessorSupport/tracking/SimpleObservable","../chunks/vec3f64","./ellipsoidUtils","./Extent","./Multipoint","../chunks/pe","./Point","./Polygon","./Polyline","./SpatialReference","./projection/projectBuffer","./projection/projectors","./projection/projectXYZToVector","./support/GeographicTransformation","./support/spatialReferenceUtils","./support/zscale"],(function(e,n,t,r,l,o,i,a,u,s,c,p,f,h,m,d,g,y,j,R,P){"use strict";let x=null,w=null,S=null,Z={};const M=new o.SimpleObservable;function v(){return!!x&&c.isLoaded()}function z(){return!!v()||(l.trackAccess(M),C(),!1)}function C(n){return null==S&&(S=Promise.all([c.load(),new Promise(((n,t)=>e(["../chunks/geometryEngineBase"],n,t))).then((e=>e.geometryEngineBase)),new Promise(((n,t)=>e(["./geometryAdapters/hydrated"],n,t)))])),S.then((([,e,{hydratedAdapter:t}])=>{r.throwIfAborted(n),w=t,x=e.default,x._enableProjection(c.pe),M.notify()}))}function E(e,n,t=null,r=null){return Array.isArray(e)?0===e.length?[]:T(w,e,e[0].spatialReference,n,t,r):T(w,[e],e.spatialReference,n,t,r)[0]}function T(e,n,t,r,l=null,o=null){if(null==t||null==r)return n;if(O(t,r,l))return n.map((e=>q(e,t,r)));if(null==l&&a.isSphericalECEF(t)){return n.map((e=>q(e,t,m.WGS84))).map((e=>F(e,r)))}if(null==l&&a.isSphericalECEF(r)){return n.map((e=>F(e,m.WGS84))).map((e=>q(e,m.WGS84,r)))}if(null==l){const e=j.cacheKey(t,r);void 0!==Z[e]?l=Z[e]:(null==(l=L(t,r,void 0))&&(l=new j),Z[e]=l)}if(null==x||null==e)throw new G;return null!=o?x._project(e,n,t,r,l,o):x._project(e,n,t,r,l)}function b(e,n){const t=A([e],n);return null!=t.pending?{pending:t.pending,geometry:null}:null!=t.geometries?{pending:null,geometry:t.geometries[0]}:{pending:null,geometry:null}}function A(e,n){if(!v())for(const t of e)if(null!=t&&!R.equals(t.spatialReference,n)&&R.isValid(t.spatialReference)&&R.isValid(n)&&!O(t.spatialReference,n))return l.trackAccess(M),{pending:C(),geometries:null};return{pending:null,geometries:e.map((e=>null==e?null:R.equals(e.spatialReference,n)?e:R.isValid(e.spatialReference)&&R.isValid(n)?F(e,n):null))}}function L(e,n,t=null){if(null==e||null==n)return null;if(null==x||null==w)throw new G;const r=x._getTransformation(w,e,n,t,t?.spatialReference);return null!==r?j.fromGE(r):null}function k(e,n,t=null){if(null==x||null==w)throw new G;const r=x._getTransformationBySuitability(w,e,n,t,t?.spatialReference);if(null!==r){const e=[];for(const n of r)e.push(j.fromGE(n));return e}return[]}class G extends t{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function V(){x=null,w=null,S=null,Z={}}const W={get loadPromise(){return S}};function F(e,n){try{const t=E(e,n);if(null==t)return null;"xmin"in e&&"xmin"in t&&(t.zmin=e.zmin,t.zmax=e.zmax);const r=P.getGeometryZScaler(t.type,e.spatialReference,n);return null!=r&&r(t),t}catch(t){if(!(t instanceof G))throw t;return null}}async function B(e,n,t){const r=e.spatialReference;return null!=r&&null!=n&&await _(r,n,null,t),F(e,n)}function O(e,n,t){return!t&&(!!R.equals(e,n)||R.isValid(e)&&R.isValid(n)&&!!g.getProjector(e,n,g.projectorCache))}async function _(e,n,t,l){if(v())return r.waitTick(l);if(Array.isArray(e)){for(const{source:r,dest:o,geographicTransformation:i}of e)if(!O(r,o,i))return C(l)}else if(!O(e,n,t))return C(l);return r.waitTick(l)}function q(e,n,t){return e?"x"in e?X(e,n,new p,t,0):"xmin"in e?Q(e,n,new u,t,0):"rings"in e?J(e,n,new f,t,0):"paths"in e?D(e,n,new h,t,0):"points"in e?I(e,n,new s,t,0):null:null}function U(e,n,t=n.spatialReference,r=0){return null!=t&&null!=e.spatialReference&&null!=X(e,e.spatialReference,n,t,r)}function X(e,n,t,r,l){ne[0]=e.x,ne[1]=e.y;const o=e.z;return ne[2]=void 0!==o?o:l,d.projectBuffer(ne,n,0,ne,r,0,1)?(t.x=ne[0],t.y=ne[1],t.spatialReference=r,void 0!==o||a.isSphericalPCPF(r)?(t.z=ne[2],t.hasZ=!0):(t.z=void 0,t.hasZ=!1),void 0===e.m?(t.m=void 0,t.hasM=!1):(t.m=e.m,t.hasM=!0),t):null}function Y(e,n,t=n.spatialReference,r=0){return null!=e.spatialReference&&null!=t&&null!=I(e,e.spatialReference,n,t,r)}function I(e,n,t,r,l){const{points:o,hasZ:i,hasM:u}=e,s=[],c=o.length,p=[];for(const a of o)p.push(a[0],a[1],i?a[2]:l);if(!d.projectBuffer(p,n,0,p,r,0,c))return null;const f=i||a.isSphericalPCPF(r);for(let a=0;a<c;++a){const e=3*a,n=p[e],t=p[e+1];f&&u?s.push([n,t,p[e+2],o[a][3]]):f?s.push([n,t,p[e+2]]):u?s.push([n,t,o[a][2]]):s.push([n,t])}return t.points=s,t.spatialReference=r,t.hasZ=i,t.hasM=u,t}function K(e,n,t=n.spatialReference,r=0){return null!=e.spatialReference&&null!=t&&null!=D(e,e.spatialReference,n,t,r)}function D(e,n,t,r,l){const{paths:o,hasZ:i,hasM:u}=e,s=[];if(!$(o,i??!1,u??!1,n,s,r,l))return null;const c=i||a.isSphericalPCPF(r);return t.paths=s,t.spatialReference=r,t.hasZ=c,t.hasM=u,t}function H(e,n,t=n.spatialReference,r=0){return null!=e.spatialReference&&null!=t&&null!=J(e,e.spatialReference,n,t,r)}function J(e,n,t,r,l){const{rings:o,hasZ:i,hasM:u}=e,s=[];if(!$(o,i??!1,u??!1,n,s,r,l))return null;const c=i||a.isSphericalPCPF(r);return t.rings=s,t.spatialReference=r,t.hasZ=c,t.hasM=u,t}function N(e,n,t=n.spatialReference,r=0){return null!=e.spatialReference&&null!=t&&null!=Q(e,e.spatialReference,n,t,r)}function Q(e,n,t,r,l){const{xmin:o,ymin:i,xmax:u,ymax:s,hasZ:c,hasM:p}=e,f=c?e.zmin:l;if(!y.projectXYZToVector(o,i,f,n,ne,r))return null;const h=c||a.isSphericalPCPF(r);t.xmin=ne[0],t.ymin=ne[1],h&&(t.zmin=ne[2]);const m=c?e.zmax:l;return y.projectXYZToVector(u,s,m,n,ne,r)?(t.xmax=ne[0],t.ymax=ne[1],h&&(t.zmax=ne[2]),p&&(t.mmin=e.mmin,t.mmax=e.mmax),t.spatialReference=r,t):null}function $(e,n,t,r,l,o,i=0){const u=new Array;for(const a of e)for(const e of a)u.push(e[0],e[1],n?e[2]:i);if(!d.projectBuffer(u,r,0,u,o,0,u.length/3))return!1;let s=0;l.length=0;const c=n||a.isSphericalPCPF(o);for(const a of e){const e=new Array;for(const n of a)c&&t?e.push([u[s++],u[s++],u[s++],n[3]]):c?e.push([u[s++],u[s++],u[s++]]):t?(e.push([u[s++],u[s++],n[2]]),s++):(e.push([u[s++],u[s++]]),s++);l.push(e)}return!0}function ee(e){return null!=e&&null!=g.getWGS84ComparableLonLatProjector(e)}const ne=i.create();n.canProjectToWGS84ComparableLonLat=ee,n.canProjectWithoutEngine=O,n.getTransformation=L,n.getTransformations=k,n.initializeProjection=_,n.isLoaded=v,n.isLoadedOrLoad=z,n.load=C,n.project=E,n.projectExtent=N,n.projectMany=T,n.projectMultipoint=Y,n.projectOrLoad=b,n.projectOrLoadMany=A,n.projectPoint=U,n.projectPolygon=H,n.projectPolyline=K,n.projectWithZConversion=B,n.projectWithoutEngine=q,n.test=W,n.tryProjectWithZConversion=F,n.unload=V,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})}));
