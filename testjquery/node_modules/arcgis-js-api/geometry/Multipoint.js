/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../chunks/tslib.es6","../core/lang","../core/accessorSupport/decorators/property","../core/accessorSupport/ensureType","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","./Extent","./Geometry","./Point","./support/zmUtils"],(function(t,e,s,i,r,n,o,a,p,h){"use strict";var c;function l(t){return(e,s)=>null==e?s:null==s?e:t(e,s)}function u(t){return t&&("esri.geometry.SpatialReference"===t.declaredClass||null!=t.wkid)}let m=c=class extends a{constructor(...t){super(...t),this.points=[],this.type="multipoint"}normalizeCtorArgs(t,e){if(!t&&!e)return{};const s={};Array.isArray(t)?(s.points=t,s.spatialReference=e):u(t)?s.spatialReference=t:(t.points&&(s.points=t.points),t.spatialReference&&(s.spatialReference=t.spatialReference),t.hasZ&&(s.hasZ=t.hasZ),t.hasM&&(s.hasM=t.hasM));const i=s.points?.[0];return i&&(void 0===s.hasZ&&void 0===s.hasM?(s.hasZ=i.length>2,s.hasM=!1):void 0===s.hasZ?s.hasZ=i.length>3:void 0===s.hasM&&(s.hasM=i.length>3)),s}get cache(){return this.commitProperty("points"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get extent(){const t=this.points;if(!t.length)return null;const e=new o,s=this.hasZ,i=this.hasM,r=s?3:2,n=t[0],a=l(Math.min),p=l(Math.max);let h,c,u,m,[y,d]=n,[f,g]=n;for(let o=0,l=t.length;o<l;o++){const e=t[o],[n,l]=e;if(y=a(y,n),d=a(d,l),f=p(f,n),g=p(g,l),s&&e.length>2){const t=e[2];h=a(h,t),u=p(u,t)}if(i&&e.length>r){const t=e[r];c=a(c,t),m=p(m,t)}}return e.xmin=y,e.ymin=d,e.xmax=f,e.ymax=g,e.spatialReference=this.spatialReference,s?(e.zmin=h,e.zmax=u):(e.zmin=void 0,e.zmax=void 0),i?(e.mmin=c,e.mmax=m):(e.mmin=void 0,e.mmax=void 0),e}writePoints(t,s){s.points=e.clone(this.points)}addPoint(t){return h.updateSupportFromPoint(this,t),Array.isArray(t)?this.points.push(t):this.points.push(t.toArray()),this.notifyChange("points"),this}clone(){const t={points:e.clone(this.points),spatialReference:this.spatialReference};return this.hasZ&&(t.hasZ=!0),this.hasM&&(t.hasM=!0),new c(t)}getPoint(t){if(!this._validateInputs(t))return null;const e=this.points[t],s={x:e[0],y:e[1],spatialReference:this.spatialReference};let i=2;return this.hasZ&&(s.z=e[2],i=3),this.hasM&&(s.m=e[i]),new p(s)}removePoint(t){if(!this._validateInputs(t))return null;const e=new p(this.points.splice(t,1)[0],this.spatialReference);return this.notifyChange("points"),e}setPoint(t,e){return this._validateInputs(t)?(h.updateSupportFromPoint(this,e),Array.isArray(e)||(e=e.toArray()),this.points[t]=e,this.notifyChange("points"),this):this}toJSON(t){return this.write({},t)}_validateInputs(t){return null!=t&&t>=0&&t<this.points.length}};t.__decorate([s.property({readOnly:!0})],m.prototype,"cache",null),t.__decorate([s.property()],m.prototype,"extent",null),t.__decorate([s.property({type:[[Number]],json:{write:{isRequired:!0}}})],m.prototype,"points",void 0),t.__decorate([n.writer("points")],m.prototype,"writePoints",null),m=c=t.__decorate([r.subclass("esri.geometry.Multipoint")],m),m.prototype.toJSON.isDefaultToJSON=!0;return m}));
