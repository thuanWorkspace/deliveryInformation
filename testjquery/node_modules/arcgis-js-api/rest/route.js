/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../request","../core/accessorSupport/get","../geometry/support/normalizeUtils","./networkService","./utils","./route/utils","./support/FeatureSet","./support/RouteSolveResult"],(function(e,r,t,s,o,a,n,i,u){"use strict";function c(e){return e instanceof i}async function l(e,i,u){const l=[],f=[],y={},d={},m=a.parseUrl(e),{path:g}=m;c(i.stops)&&o.collectGeometries(i.stops.features,f,"stops.features",y),c(i.pointBarriers)&&o.collectGeometries(i.pointBarriers.features,f,"pointBarriers.features",y),c(i.polylineBarriers)&&o.collectGeometries(i.polylineBarriers.features,f,"polylineBarriers.features",y),c(i.polygonBarriers)&&o.collectGeometries(i.polygonBarriers.features,f,"polygonBarriers.features",y);const h=await s.normalizeCentralMeridian(f);for(const r in y){const e=y[r];l.push(r),d[r]=h.slice(e[0],e[1])}if(o.isInputGeometryZAware(d,l)){let e=null;try{e=await o.fetchServiceDescription(g,i.apiKey,u)}catch{}e&&!e.hasZ&&o.dropZValuesOffInputGeometry(d,l)}for(const r in d)d[r].forEach(((e,s)=>{t.get(i,r)[s].geometry=e}));const v={...u,query:{...m.query,...n.routeParametersToQueryParameters(i),f:"json"}},R=g.endsWith("/solve")?g:`${g}/solve`,{data:T}=await r(R,v);return p(T)}function p(e){const{barriers:r,directionLines:t,directionPoints:s,directions:o,messages:a,polygonBarriers:n,polylineBarriers:i,routes:c,stops:l,traversedEdges:p,traversedJunctions:f,traversedTurns:y}=e,d=e=>{const r=g.find((r=>r.routeName===e));if(null!=r)return r;const t={routeId:g.length+1,routeName:e};return g.push(t),t},m=e=>{const r=g.find((r=>r.routeId===e));if(null!=r)return r;const t={routeId:e,routeName:null};return g.push(t),t},g=[];c?.features.forEach(((e,r)=>{e.geometry.spatialReference=c.spatialReference??void 0;const t=e.attributes.Name,s=r+1;g.push({routeId:s,routeName:t,route:e})})),o?.forEach((e=>{const{routeName:r}=e;d(r).directions=e}));const h=(l?.features.every((e=>null==e.attributes.RouteName))??!1)&&g.length>0?g[0].routeName:null;return l?.features.forEach((e=>{var r;e.geometry&&((r=e.geometry).spatialReference??(r.spatialReference=l.spatialReference??void 0));const t=h??e.attributes.RouteName,s=d(t);s.stops??(s.stops=[]),s.stops.push(e)})),t?.features.forEach((e=>{const r=e.attributes.RouteID,s=m(r),{geometryType:o,spatialReference:a}=t;s.directionLines??(s.directionLines={features:[],geometryType:o,spatialReference:a}),s.directionLines.features.push(e)})),s?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:o,spatialReference:a}=s;t.directionPoints??(t.directionPoints={features:[],geometryType:o,spatialReference:a}),t.directionPoints.features.push(e)})),p?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:s,spatialReference:o}=p;t.traversedEdges??(t.traversedEdges={features:[],geometryType:s,spatialReference:o}),t.traversedEdges.features.push(e)})),f?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:s,spatialReference:o}=f;t.traversedJunctions??(t.traversedJunctions={features:[],geometryType:s,spatialReference:o}),t.traversedJunctions.features.push(e)})),y?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r);t.traversedTurns??(t.traversedTurns={features:[]}),t.traversedTurns.features.push(e)})),u.fromJSON({routeResults:g,barriers:r,polygonBarriers:n,polylineBarriers:i,messages:a})}e.solve=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
