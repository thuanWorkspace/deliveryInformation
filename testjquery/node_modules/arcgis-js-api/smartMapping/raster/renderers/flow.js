/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../../core/Error","../../../renderers/support/AuthoringInfo","../../../renderers/support/AuthoringInfoVisualVariable","../../../renderers/support/rasterRendererHelper","../../../renderers/visualVariables/ColorVariable","../../../renderers/visualVariables/OpacityVariable","../../../renderers/visualVariables/SizeVariable","../support/utils","../../renderers/support/utils","../../symbology/flow"],(function(e,a,n,t,i,l,r,s,o,m,u){"use strict";const c=5;async function p(e){const a={...e};return a.theme||(a.theme="flow-line"),o.processRasterRendererParameters(a)}async function d(e){let a=e.flowScheme,n=null,t=null;const i=await m.getBasemapInfo(null,e.view);if(n=null!=i.basemapId?i.basemapId:null,t=null!=i.basemapTheme?i.basemapTheme:null,a)return{scheme:u.cloneScheme(a),basemapId:n,basemapTheme:t};const l=u.getSchemes({basemapTheme:t,theme:e.theme,hasSizeVariable:e.hasSizeVariable});return l&&(a=l.primaryScheme,n=l.basemapId,t=l.basemapTheme),{scheme:a,basemapId:n,basemapTheme:t}}async function h(e,o){o.flowRepresentation&&(e.flowRepresentation=o.flowRepresentation);const p=await d({theme:o.theme,flowScheme:o.flowScheme,view:o.view,hasSizeVariable:o.includeSizeVariable}),h=p.scheme;if(!h)throw new a("flow-renderer:insufficient-info","Unable to find flow scheme");e.flowSpeed=h.flowSpeed,e.density=h.density,e.trailLength=h.trailLength,e.trailWidth=h.trailWidth,e.trailCap=h.trailCap,e.color=h.color;const f=[],w=[],b="Magnitude",y=o.layer.rasterInfo,g=null==y.statistics||"vector-magdir"!==y.dataType&&"vector-uv"!==y.dataType?{minMagnitude:0,maxMagnitude:10}:i.estimateMagnitudeRange(y.dataType,y.statistics);if(null==g?.minMagnitude||null==g.maxMagnitude)throw new a("flow-renderer:insufficient-info","stats not available");const S={min:g.minMagnitude,max:g.maxMagnitude},V={min:S.min,max:null!=S.max?S.max/2:null},v=m.getDataRange(V,null,null,null),x=m.createDataValues(v,V,null);if(o.includeColorVariable){const e=m.createColors(h.colors,c);if(e.length<c)throw new a("flow-renderer:insufficient-info","Flow scheme does not have enough colors");const n=new l({field:b,stops:x.map(((a,n)=>({value:a,color:e[n]})))});f.push(n);const i=new t({type:"color",minSliderValue:S.min,maxSliderValue:S.max,theme:"high-to-low"});w.push(i)}if(o.includeOpacityVariable){const e=new r({field:b,stops:[{value:x[0],opacity:h.minOpacity},{value:x[4],opacity:h.maxOpacity}]});f.push(e);const a=new t({type:"opacity",minSliderValue:S.min,maxSliderValue:S.max});w.push(a)}if(o.includeSizeVariable){const e=new s({field:b,stops:[{value:S.min,size:h.minSize},{value:S.max,size:h.maxSize}]});f.push(e);const a=new t({type:"size",minSliderValue:S.min,maxSliderValue:S.max,theme:"high-to-low"});w.push(a)}const I=new n({type:"flow",visualVariables:w.length?w:null,flowTheme:h.theme});return e.visualVariables=f,e.authoringInfo=I,e.legendOptions=o.legendOptions,{renderer:e,visualVariables:f.map((e=>e.clone())),flowScheme:u.cloneScheme(h),basemapId:p.basemapId,basemapTheme:p.basemapTheme,layerEffect:h.layerEffect,statistics:S}}async function f(e){e=await p(e);const n=i.createFlowRenderer(e.layer.rasterInfo);if(null==n)throw new a("flow-renderer:not-supported","Only vector data is supported");return h(n,e)}e.createRenderer=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
