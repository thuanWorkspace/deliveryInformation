/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../core/has","../../core/Error","../../core/screenUtils","../../geometry/support/scaleUtils","../../renderers/visualVariables/SizeVariable","./scaleRange","../support/binningUtils","../support/adapters/support/layerUtils"],(function(e,n,l,a,s,i,t,r){"use strict";const o=1e8,c=1128.497176,u=591657527.591555,p=[10,8,4,2],v=[100,100,60,30],f=[2,1,.75,.5],m=[32,18,12,6],w=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];async function g(e){const{view:l}=e;if(!(e&&l&&e.layer))throw new n("size-range:missing-parameters","'view' and 'layer' parameters are required");e.forBinning&&t.verifyBinningParams(e,"size-range");const{layer:a,...s}=e,i=e.forBinning?r.binningCapableLayerTypes:r.featureCapableLayerTypes,o=r.createLayerAdapter(a,i,e.forBinning);if(!o)throw new n("size-range:invalid-parameters","'layer' must be one of these types: "+r.getLayerTypeLabels(i).join(", "));const c={layerAdapter:o,...s,view:l};await l.when();const u=null!=c.signal?{signal:c.signal}:null;await o.load(u);const p=o.geometryType;if("point"!==p&&"multipoint"!==p&&"polyline"!==p&&"polygon"!==p)throw new n("size-range:not-supported",`sizeRange is not supported for geometryType: ${p}`);return c}function y(e,n){const l=Math.ceil(e/n);let a=Math.ceil(l/4);a<4?a=4:a>16&&(a=16);const s=5*a;return{min:a,max:s<50?50:s}}function S(e,l){const{view:a}=e;if(!a)throw new n("scale-range:invalid-parameters","'view' is required");const s=l.minScale||o,i=a.constraints&&"effectiveLODs"in a.constraints&&a.constraints.effectiveLODs||w,t=[];for(let n=0;n<i.length;n++){if(i[n].scale>s)continue;const e=Number(n),l=[e-3,e,e+3,e+6];for(const n of l)n>-1&&n<i.length&&t.push(i[n].scale);break}return t.sort(((e,n)=>e-n))}function x(e,l){const{view:s,layerAdapter:i}=e;if(!s)throw new n("scale-range:invalid-parameters","'view' is required");const t=i.fullExtent,r=i.minScale||c,o=i.maxScale||u,p=l.minScale||0,v=l.maxScale||0;let f=null!=t?a.getScale(s,t):0;f=f<r&&f>o?f:0;return{scales:[r,o,p,v,f].map(Math.round).sort(((e,n)=>e-n)).filter(((e,n,l)=>!!e&&l.indexOf(e)===n)).filter(((e,n,l)=>!n||Math.abs(e-l[n-1])>5)),fullExtentScale:f}}function h(e,a){const{minScale:i,maxScale:t}=a,r=S(e,{minScale:i,maxScale:t});if(!r.length)throw new n("scale-range:insufficient-info","not enough scale values");return{minSize:new s({valueExpression:"$view.scale",stops:r.map(((e,n)=>({value:e,size:l.px2pt(p[n])})))}),maxSize:new s({valueExpression:"$view.scale",stops:r.map(((e,n)=>({value:e,size:l.px2pt(v[n])})))})}}function d(e,a){const{minScale:i,maxScale:t}=a,r=S(e,{minScale:i,maxScale:t});if(!r.length)throw new n("scale-range:insufficient-info","not enough scale values");return{minSize:new s({valueExpression:"$view.scale",stops:r.map(((e,n)=>({value:e,size:l.px2pt(f[n])})))}),maxSize:new s({valueExpression:"$view.scale",stops:r.map(((e,n)=>({value:e,size:l.px2pt(m[n])})))})}}function z(e,a){const{spatialStatistics:i,minScale:t,maxScale:r}=a;if(!("avgSize"in i)||!i.avgSize)throw new n("size-range:insufficient-info","average polygon size is invalid");const o=i.avgSize,{view:c}=e;if(!c)throw new n("scale-range:invalid-parameters","'view' is required");const{resolution:u,scale:p}=c,v=u/p,{scales:f,fullExtentScale:m}=x(e,{minScale:t,maxScale:r}),w=[],g=[];f.forEach(((e,n)=>{const{min:a,max:s}=y(o,v*e),i=f.indexOf(m),t=i>-1&&n>i?2:1;w.push({value:e,size:l.px2pt(a/t)}),g.push({value:e,size:l.px2pt(s/t)})}));return{minSize:new s({valueExpression:"$view.scale",stops:w}),maxSize:new s({valueExpression:"$view.scale",stops:g})}}async function b(e){const n=await g(e),{view:l,layerAdapter:a,signal:s}=n,t=await i({layer:a,view:l,signal:s});switch(a.geometryType){case"point":case"multipoint":return h(n,t);case"polyline":return d(n,t);case"polygon":return z(n,t);case"mesh":case"multipatch":return null}return null}return b}));
