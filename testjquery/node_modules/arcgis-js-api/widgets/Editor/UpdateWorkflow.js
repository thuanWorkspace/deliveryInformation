/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["../../chunks/tslib.es6","../../Graphic","../../core/Error","../../core/handleUtils","../../core/Logger","../../core/maybe","../../core/promiseUtils","../../core/Queue","../../core/reactiveUtils","../../core/SetUtils","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/has","../../core/accessorSupport/decorators/subclass","../../layers/support/editableLayers","../../layers/support/layerUtils","../../views/draw/support/HighlightHelper","./CreateFeaturesWorkflow","./UpdateFeatureWorkflow","./UpdateRecordWorkflow","./UpdateWorkflowData","./Workflow","./workflowUtils","../Feature/support/featureUtils","../support/templateUtils"],(function(e,t,a,r,o,i,n,s,l,d,c,p,u,w,h,f,k,g,y,v,m,b,_,W,C,S){"use strict";var F;const A="esri.widgets.Editor.UpdateWorkflow",M=o.getLogger(A);let U=F=class extends _{constructor(e){super(e),this._workflowStack=new s(d.last),this._sketchStack=new s(d.last),this.type="update"}get activeEditableItem(){return this.activeWorkflow?.data.editableItem??void 0}get activeWorkflow(){return this._workflowStack.last()}get nestedWorkflowCount(){return this._workflowStack.length}get shouldShowAttachments(){return!!this.activeEditableItem?.attachmentsOnUpdateEnabled}get shouldAllowAttachmentEditing(){return!!this.activeEditableItem?.supports.includes("update")}get hasPendingEdits(){return Array.from(this._workflowStack).some((e=>e.hasPendingEdits))}get helpMessage(){return this.activeWorkflow?.helpMessage?this.activeWorkflow.helpMessage:"awaiting-feature-to-update"===this.stepId?"select":void 0}get reliesOnOwnerAdminPrivileges(){return this.activeWorkflow?.reliesOnOwnerAdminPrivileges??!1}get hasInvalidFormTemplate(){return!!this.activeEditableItem?.hasInvalidFormTemplate}get hasUnsupportedFields(){return!!this.activeEditableItem?.hasUnsupportedFields}async back(e=(()=>Promise.resolve(!0))){const{featureFormViewModel:t}=this.data.viewModel;if(null==t.relationshipId)if(this.activeWorkflow){if(this.activeWorkflow.hasPendingEdits){if(!await e())return}this.activeWorkflow.hasPreviousStep?await this.activeWorkflow.previous({cancelCurrentStep:!0}):await this.cancelActiveWorkflow({force:!0})}else this.hasPreviousStep?await this.previous({cancelCurrentStep:!0}):await this.cancel({force:!0});else t.relationshipId=null}async cancelActiveWorkflow(e){await(this.activeWorkflow?.cancel(e)),await this._popWorkflow()}async commit(){await this._drainWorkflowStack((e=>e.commit())),await super.commit()}static create(e){const{viewModel:t,startAt:a,addAttachmentsCallback:r,applyEditsCallback:o}=e,i=new F({data:new b({addAttachmentsCallback:r,applyEditsCallback:o,viewModel:t}),onCommit:async()=>{}});return i._set("steps",this._createWorkflowSteps(i,a)),i}async save(){this.nestedWorkflowCount>1?(await(this.activeWorkflow?.commit()),await this._popWorkflow()):await this.commit()}async startCreatingRelatedRecord(e){try{const t=await this._createNestedCreateFeaturesWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new a("editor:unable-to-start-creating","Could not begin updating the provided feature or table record.",{error:t})}}async startUpdating(e){try{const t=await this._createNestedUpdateWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new a("editor:unable-to-start-updating","Could not begin updating the provided feature or table record.",{error:t})}}async deleteActiveFeature(){const{activeWorkflow:e}=this;if(!e)throw new a("editor:nothing-to-delete","There is no feature to delete");E(e)?await e.deleteAndCommit():await e.cancel(),1===this.nestedWorkflowCount?await this.reset():await this._popWorkflow()}async cancelAll(){await this._drainWorkflowStack((e=>e.cancel({force:!0})))}async _createNestedCreateFeaturesWorkflow(e){const{relatedLayer:t}=e,{addAttachmentsCallback:r,applyEditsCallback:o,viewModel:i}=this.data;if(!f.isEditableLayer(t))throw new a("editor:unsupported-layer","Editing is not supported on the provided layer");const n=this._getCreationInfoForNestedCreateFeaturesWorkflow(e),s=n.template||n.initialFeature?"creating-features":"awaiting-feature-creation-info",l="create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0;return y.create({addAttachmentsCallback:r,applyEditsCallback:o,creationInfo:n,isNested:!0,parent:l,startAt:s,viewModel:i})}_getCreationInfoForNestedCreateFeaturesWorkflow(e){const{relatedLayer:r}=e;if(!f.isEditableLayer(r)||k.isSubtypeGroupLayer(r))throw new a("editor:unsupported-layer","Editing is not supported on the provided layer");const o={layer:r,maxFeatures:1},i=this._makeRelatedRecordAttributes(e),n=S.getAllTemplatesForLayer(r);return n?.length>0?(o.attributeOverrides=i,1===n.length&&(o.template=n[0])):o.initialFeature=new t({sourceLayer:r,attributes:i}),o}async _createNestedUpdateWorkflow(e){const t=k.isTable(e.sourceLayer)?m.UpdateRecordWorkflow:v.UpdateFeatureWorkflow,{applyEditsCallback:a,viewModel:r}=this.data,o="create-features"!==this.activeWorkflow?.type?this.activeWorkflow:void 0,i=await t.create({feature:e,parent:o,viewModel:r,applyEdits:a});return await l.whenOnce((()=>!i.updating)),i}async _drainWorkflowStack(e){const t=this._workflowStack,a=[];for(;t.length>0;){const r=t.pop();this._sketchStack.pop();const o=e(r).then((()=>r.destroy()));this._updatingHandles.addPromise(o),a.push(o)}await Promise.all(a)}_makeRelatedRecordAttributes(e){const{parentFeature:t,relatedLayer:a,relationshipId:r}=e;if(!C.isGraphicForRelatableFeatureSupportedLayer(t))return;const o=a.relationships?.find((e=>e.id===r));if(!o)return void I("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the destination layer.");if("origin"===o.role)return void I("unsupported-role","Creating new related records in the 'origin' table of a relationship is not yet supported");const i=t.sourceLayer;o.relatedTableId!==i.layerId&&I("invalid-argument-combination","The given parent feature does not belong to the relationship designated by the given relationship ID.");const n=i.relationships?.find((e=>e.id===r));if(!n)return void I("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the origin layer.");const s=t.getAttribute(n.keyField);return s||I("no-key-on-origin-feature","The given parent feature does not have a value for the relationship's origin primary key field."),{[o.keyField]:s}}async _popWorkflow(){this._workflowStack.pop()?.destroy(),this._sketchStack.pop();const e=await this._reconcileWorkflowStack();if(e.failureCount>0)throw new a("editor:next-workflow-failed","Popped the top workflow, but the next workflow in the stack failed to activate",e)}async _pushWorkflow(e){const t=this._workflowRequiresSketchViewModel(e);this.activeWorkflow?.exit({removeSketchHandles:t});const r=this._sketchStack,o=await(e?.start()),i=r.peek();o?(i?.exit(),r.push(o)):r.push(this._cloneSketchController(i)),this._workflowStack.push(e);const n=await this._reconcileWorkflowStack();if(n.failureCount>0)throw new a("editor:failed-to-start-updating-feature","Failed to enter the provided workflow.",n)}async _reconcileWorkflowStack(){const e=this._workflowStack,t=this._sketchStack;try{const a=e.peek();return await(a?.enter()),await(t.peek()?.enter()),{activeWorkflow:a,failureCount:0}}catch(a){e.pop().destroy(),t.pop();const{activeWorkflow:r,failureCount:o}=await this._reconcileWorkflowStack();return{activeWorkflow:r,failureCount:o+1}}}_cloneSketchController(e){return{enter:e?.enter??(async()=>{}),exit:e?.exit??(async()=>{})}}_workflowRequiresSketchViewModel(e){const{type:t}=e;return"update-feature"===t||"create-features"===t&&!k.isTable(e.data.creationInfo?.layer)}static _createWorkflowSteps(e,t="awaiting-feature-to-update"){const{data:o}=e,s={"awaiting-feature-to-update":()=>({id:"awaiting-feature-to-update",async setUp(){const{spinnerViewModel:t}=o.viewModel,a=o.viewModel.view;let s=null;e.addHandles(r.makeHandle((()=>{s=i.abortMaybe(s)})),this.id),o.rootFeature=null,o.candidates=[];const l=a.on("immediate-click",(async r=>{r.stopPropagation(),t.location=r.mapPoint,t.visible=!0,s?.abort();const{editableItems:i}=o.viewModel;s=new AbortController;const l=await new Promise(((e,t)=>{n.onAbort(s?.signal,(()=>t(n.createAbortError()))),e(W.fetchCandidates(i,a,r,s?.signal))}));n.throwIfAborted(s),o.candidates=l.filter((e=>"fulfilled"===e.status)).flatMap((e=>e.value)),t.visible=1===o.candidates.length,0!==o.candidates.length&&(1===o.candidates.length?(o.rootFeature=o.candidates[0],e.go("editing-existing-feature").catch((()=>{})).then((()=>t.visible=!1))):e.next())}));a.focus(),e.addHandles(l,this.id)},async tearDown(){0===o.candidates.length&&(o.viewModel.spinnerViewModel.visible=!1),e.removeHandles(this.id)}}),"awaiting-update-feature-candidate":()=>({id:"awaiting-update-feature-candidate",async setUp(){o.rootFeature=null;const{view:t}=o.viewModel;if(!t)return;const a=new g({view:t});e.addHandles([l.watch((()=>o.rootFeature),((e,t)=>{a.remove(t),a.add(e)}),l.sync),r.makeHandle((()=>a.removeAll()))],this.id)},async tearDown(){e.removeHandles(this.id)}}),"editing-existing-feature":()=>({id:"editing-existing-feature",async setUp(){const{rootFeature:t,viewModel:i}=e.data;if(!t)throw new a("editor:no-feature-specified","Cannot setup the 'updating-existing-feature' step until the root feature is defined");await e.startUpdating(t),i.spinnerViewModel.visible=!1;const s=n.debounce((async()=>{await l.whenOnce((()=>!e.updating)),e.previous()})),{featureFormViewModel:d}=o.viewModel,c=d.relatedRecordCallbacks;d.relatedRecordCallbacks={addRelatedRecord:async t=>{await e.startCreatingRelatedRecord(t),d.relationshipId=null},editRelatedRecord:async({relatedFeature:t})=>{await e.startUpdating(t),d.relationshipId=null},showAllRelatedRecords:e=>d.relationshipId=e.relationshipId},e.addHandles([r.makeHandle((()=>d.relatedRecordCallbacks=c)),l.watch((()=>e.nestedWorkflowCount),((e,t)=>{0===e&&0!==t&&s()}),l.sync)],this.id)},async tearDown(){await e.cancelAll(),e.removeHandles(this.id)}}),"adding-attachment":()=>({id:"adding-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){o.viewModel.attachmentsViewModel.mode="view"}}),"editing-attachment":()=>({id:"editing-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){o.viewModel.attachmentsViewModel.mode="view"}})};return W.createWorkflowSteps(["awaiting-feature-to-update","awaiting-update-feature-candidate","editing-existing-feature","adding-attachment","editing-attachment"],t,s)}};e.__decorate([c.property()],U.prototype,"activeEditableItem",null),e.__decorate([c.property()],U.prototype,"activeWorkflow",null),e.__decorate([c.property()],U.prototype,"nestedWorkflowCount",null),e.__decorate([c.property()],U.prototype,"shouldShowAttachments",null),e.__decorate([c.property()],U.prototype,"shouldAllowAttachmentEditing",null),e.__decorate([c.property()],U.prototype,"hasPendingEdits",null),e.__decorate([c.property()],U.prototype,"helpMessage",null),e.__decorate([c.property()],U.prototype,"reliesOnOwnerAdminPrivileges",null),e.__decorate([c.property()],U.prototype,"hasInvalidFormTemplate",null),e.__decorate([c.property()],U.prototype,"hasUnsupportedFields",null),U=F=e.__decorate([h.subclass(A)],U);const I=(e,t)=>M.warn(`editor:${e}`,t,"The create operation will be allowed to proceed, but the resulting feature may not be related to the given parent feature."),E=e=>!!e&&/update-/.test(e.type);return U}));
