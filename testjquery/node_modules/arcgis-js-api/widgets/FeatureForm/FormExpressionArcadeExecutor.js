/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["exports","../../chunks/tslib.es6","../../arcade","../../core/Accessor","../../core/promiseUtils","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/has","../../core/accessorSupport/decorators/subclass","../../core/support/UpdatingHandles","../../layers/support/fieldUtils"],(function(e,r,t,o,s,a,c,n,l,i,u,d){"use strict";var p;const x=Symbol("FormExpressionArcadeExecutor");e.FormExpressionArcadeExecutor=class extends o{constructor(e){super(e),this[p]=!0,this._lastEvaluatedValue=null,this._abortController=new AbortController,this._stale=!1,this._updatingTracking=new u.UpdatingHandles,this._executeAsyncDebounced=s.debounce((async(e,r,t)=>{const o=await this.executor.executeAsync(e,{...r,abortSignal:t});return t.aborted?this._lastEvaluatedValue:(this._lastEvaluatedValue=o,this._stale=!1,o)}))}get isAsync(){return this.executor.isAsync}get fieldsUsed(){return this.executor.fieldsUsed}get syntaxTree(){return this.executor.syntaxTree}get updating(){return this._updatingTracking.updating}get stale(){return this._stale}get geometryUsed(){return this.executor.geometryUsed}get variablesUsed(){return this.executor.variablesUsed}get lastEvaluatedValue(){return this._lastEvaluatedValue}abort(){this._abortController.abort()}execute(e,r){this._abortController=new AbortController;const t=this.executor.execute(e,{...r,abortSignal:this._abortController.signal});return this._lastEvaluatedValue=t,t}async executeAsync(e,r){return this._abortController=new AbortController,this._updatingTracking.addPromise(this._executeAsyncDebounced(e,r??{},this._abortController.signal))}markStale(){this._stale=!0}reset(){this.abort(),this._lastEvaluatedValue=null,this._stale=!1}},p=x,r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"_lastEvaluatedValue",void 0),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"_stale",void 0),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"_updatingTracking",void 0),r.__decorate([a.property({constructOnly:!0})],e.FormExpressionArcadeExecutor.prototype,"executor",void 0),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"isAsync",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"fieldsUsed",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"syntaxTree",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"updating",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"stale",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"geometryUsed",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"variablesUsed",null),r.__decorate([a.property()],e.FormExpressionArcadeExecutor.prototype,"lastEvaluatedValue",null),e.FormExpressionArcadeExecutor=r.__decorate([i.subclass("esri.widgets.FeatureForm.FormExpressionArcadeExecutor")],e.FormExpressionArcadeExecutor);const _=async(r,o)=>{const s=t.createArcadeProfile("form-calculation"),a=await t.createArcadeExecutor(r,s,{});return o?.fieldsIndex&&(a.fieldsUsed=d.fixFields(o.fieldsIndex,a.fieldsUsed)),new e.FormExpressionArcadeExecutor({executor:a})};e.createFormExpressionArcadeExecutor=_,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
