/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
define(["require","exports","../../../core/Logger","../../../core/promiseUtils","../../../layers/FeatureLayer","./featureUtils"],(function(e,t,r,a,i,n){"use strict";const s=["$datastore","$map","$layer","$aggregatedfeatures"],o="esri.widgets.Feature.support.arcadeFeatureUtils",c=r.getLogger(o);function l(e){return"string"==typeof e?n.applyTextFormattingHTML(n.htmlEntities(e)):Array.isArray(e)?p(e):"esri.arcade.Dictionary"===e?.declaredClass?u(e):e}function p(e){return`<ul class="esri-widget__list">${e.map((e=>`<li>${"string"==typeof e?n.applyTextFormattingHTML(n.htmlEntities(e)):e}</li>`)).join("")}</ul>`}function u(e){return`<table class="esri-widget__table">${e.keys().map((t=>{const r=e.field(t);return`<tr><th>${t}</th><td>${"string"==typeof r?n.applyTextFormattingHTML(n.htmlEntities(r)):r}</td></tr>`})).join("")}</table>`}function f({aggregatedFeatures:e,arcadeUtils:t,featureSetVars:r,context:a,viewInfo:n,map:s,graphic:o,interceptor:c}){r.forEach((r=>{const l=r.toLowerCase(),p=n.sr,u={map:s,spatialReference:p,interceptor:c};if("$map"===l&&(a.vars[l]=t.convertMapToFeatureSetCollection(u)),"$layer"===l&&(a.vars[l]=t.convertFeatureLayerToFeatureSet({layer:o.sourceLayer,spatialReference:p,interceptor:c})),"$datastore"===l&&(a.vars[l]=t.convertServiceUrlToWorkspace({url:o.sourceLayer.url,spatialReference:p,interceptor:c})),"$aggregatedfeatures"===l){const r=o.layer,{fields:n,objectIdField:s,geometryType:p,spatialReference:u,displayField:f}=r,d=new i({fields:n,objectIdField:s,geometryType:p,spatialReference:u,displayField:f,..."feature"===r.type?{templates:r.templates,typeIdField:r.typeIdField,types:r.types}:null,source:e});a.vars[l]=t.convertFeatureLayerToFeatureSet({layer:d,spatialReference:u,interceptor:c})}}))}function d(){return new Promise(((t,r)=>e(["../../../support/arcadeUtils"],t,r)))}function y(e){return"createQuery"in e&&"queryFeatures"in e}async function g({graphic:e,view:t}){const{isAggregate:r,layer:a}=e;if(!r||!a||"2d"!==t?.type)return[];const i=await t.whenLayerView(a);if(!y(i))return[];const n=i.createQuery(),s=e.getObjectId();n.aggregateIds=null!=s?[s]:[];const{features:o}=await i.queryFeatures(n);return o}async function m({expressionInfo:e,arcadeUtils:t,interceptor:r,spatialReference:a,map:i,graphic:n,view:o}){if(!e?.expression)return null;const l=t.createSyntaxTree(e.expression),p=s.filter((e=>t.hasVariable(l,e))),[u]=await Promise.all([g({graphic:n,view:o}),t.loadScriptDependencies(l,!0,p)]),d=t.getViewInfo({spatialReference:a}),y=t.createExecContext(n,d,o?.timeZone);y.interceptor=r,y.useAsync=!0,f({aggregatedFeatures:u,arcadeUtils:t,featureSetVars:p,context:y,viewInfo:d,map:i,graphic:n,interceptor:r});const m=t.createFunction(l,y);return t.executeAsyncFunction(m,y).catch((t=>c.error("arcade-execution-error",{error:t,graphic:n,expressionInfo:e})))}async function F({expressionInfos:e,spatialReference:t,graphic:r,interceptor:i,map:n,view:s}){if(!e?.length)return{};const o=await d(),c={};for(const a of e)c[`expression/${a.name}`]=m({expressionInfo:a,arcadeUtils:o,interceptor:i,spatialReference:t,map:n,graphic:r,view:s});const p=await a.eachAlways(c),u={};for(const a in p)u[a]=l(p[a].value);return u}t.createCompiledExpression=m,t.createCompiledExpressions=F,t.loadArcadeUtils=d,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
